[{"title":"数据分析","url":"/posts/57683/","categories":["python"]},{"title":"Python爬虫库xPath, BeautifulSoup, re, selenium的详细用法","url":"/posts/31710/","content":"\n## 项目代码展示\n\n![部分代码](https://gitee.com/rbozo/picgo_image/raw/master/image/0/20210822143150.png)\n\n* 项目部署方法, 已发GitHub, 项目地址[github地址](https://github.com/Rr210/hot_search)\n\n## 使用技术\n\n* python正则匹配\n* Beautifulsoup4库\n* xpath解析\n\n## 正则匹配\n\n* 和JavaScript语言匹配方式类似\n* 使用前需导入`re`包\n* 有几种正则匹配的方法:match, search, compile, findall, finditer\n\n### re.match(a, b, c)\n\n* 三个参数: 匹配的规则, 要匹配的字符串, 匹配方式\n* 它是从字符串的第一个位置进行匹配如果满足使用`.span()`方法可以返回它所在的索引位置, 如果不满足则返回`None`\n* `返回结果.groups()`返回一个包含所有小组的字符串的元组, 使用`group(num)`方法可以返回一个包含对应值的元组(从1开始)\n\n### re.search(a, b, c)\n\n* 也是三个参数, 与上面相同\n* 获取元组方法也相同, 唯一的不同点就是, search不是从一开始进行匹配, 而是如果字符串中包含所要匹配的内容, 则返回第一个匹配成功的\n* 注意只返回一个不是多个\n\n### re.sub(a, b, c, d, e)\n\n* 执行`替换`操作\n* `a`正则中的模式字符串\n* `b`要替换的字符串, 也可以是一个函数\n* `c`原始字符串\n* `d`匹配后替换的最大次数, 默认是0表示全部匹配替换\n* `e`匹配模式, 数字形式\n\n### re.compile(a, b)\n\n* 用来编译正则表达式, 供match和search这两个函数使用\n* 如果使用的是match方法 在获取匹配的字符时使用group方法获取参数可以省略不写也可以写0\n* group方法参数的数值与你所写的正则表达式元组数有关\n* start, end, span方法都是返回匹配字符在原字符串中所在的索引位置\n\n### findall(a, b, c, d)\n\n* 参数分别表示: 正则表达式, 匹配的字符串, 指定匹配的起始位置, 结束位置\n* 返回满足条件的所有子串, 列表的形式, 如不则返回空列表\n* 如果由有元组则返回满足元组规则的字符 可进行遍历\n\n### finditer(a, b, c)\n\n* 参数分别为: 匹配规则, 匹配的字符串, 匹配模式\n* 和findall方法类似, 返回值使用迭代器方式返回使用`for in`方法\n\n### re.split(a, b, c, d)\n\n* 按照匹配规则将匹配的字符串进行分隔以列表的形式返回\n* 参数分别为: 匹配规则, 匹配字符, `切割次数默认为0, 不限制次数`, 匹配模式\n\n### 正则表达式修饰符\n\n* `re.I` 是匹配时大小写不敏感\n* `re.L` 做本地化识别\n* `re.S` 使. 匹配包括换行在内的所有字符\n* `re.M` 多行匹配影响^$\n* `re.U` 根据Unicode字符集解析字符. 这个标志影响 \\w, \\W, \\b, \\B.\n* `re.X` 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解.\n\n【[Python正则表达式详解 (超详细, 看完必会!)](https://blog.csdn.net/weixin_43347550/article/details/105158003)】\n\n## xPath方法\n\n* 使用之前先安装好lxml库`pip i lxml`\n* xPath使用路径表达式在XML文档中进行导航\n* 可以对本地的html文件进行解析也可以直接对html字符串进行解析\n\n### Xpath常用的规则\n\n* `nodename`选取所有的子节点\n* `/`选取当前节点下的子节点\n* `//`选取当前节点的子孙节点\n* `.` 选取当前节点\n* `..` 选取当前节点的父节点\n* `@`选取属性\n\n### 本地展示\n\n![以下代码中用到该实例](https://gitee.com/rbozo/picgo_image/raw/master/image/0/20210822191052.png)\n\n<!-- 两种方法解析本地文件 -->\n* 第一种使用`etree.parse`方法解析本地\n\n```Python\n# coding= utf-8\nfrom lxml import etree\nhtml = etree.parse('./index.html',etree.HTMLParser())\nprint(etree.tostring(html))\n```\n\n* 第二种方法使用 `etree.HTML` 方法\n\n```Python\n# coding= utf-8\nfrom lxml import etree\nfp = open('./index.html', 'rb')\nhtml = fp.read().decode('utf-8')  \nselector = etree.HTML(html)   #etree.HTML(源码) 识别为可被xpath解析的对象\nprint(selector)\n```\n\n* 匹配所有的节点 使用`//*`规则匹配\n* 匹配所有指定的节点使用`//节点名称`\n* 匹配所有的子节点将//换成`/`\n* 获取父节点属性值的方法 `../@属性名`\n* 属性匹配可以使用`@属性名`的方法\n* 文本获取两种方法 `/text()` 和 `//text()`, 区别第一种直接获取文本, 第二种要获取换行时产生的特殊字符\n* 属性获取使用`/@href`获取\n* 获取属性中包含多个值的情况 属性多值匹配 `contains()`方法\n* 多属性匹配, 使用and运算符 和contains方法搭配使用\n\n### xPath运算符\n\n* 除号和取余特殊, 其他的都与基本运算符一直\n* 除号使用`div`  比如`8 div 4`\n* 取余则是`mod` 比如`1 mod 2`\n* 还有表示并列和或者的 `and` 和 `or`\n\n### 按序选择\n\n* xPath内置了100多种函数方法, 具体参考【[xPath函数](http://www.w3school.com.cn/xpath/xpath_functions.asp)】\n\n![按序](https://gitee.com/rbozo/picgo_image/raw/master/image/0/20210822182351.png)\n\n### 节点轴选择\n\n* 获取当前节点所有子元素的`a`节点的`href`属性值 `child::a/@href`\n* 获取当前节点的指定元素的属性值 `attribute:: 属性名`\n* 获取当前节点的所有的子元素 `child::*`\n* 获取当前节点 的所有属性的属性值 `attribute::*`\n* 获取当前节点所有子节点 `child::node()`\n* 获取当前元素所有文本子节点 `child::text()`\n* 获取当前元素的所有父辈为li元素的节点(包括当前元素) `ancestor-or-self:: 元素`\n\n[xPath轴](https://www.w3school.com.cn/xpath/xpath_axes.asp)\n[xPath避坑指南](https://blog.csdn.net/Ryan_lee9410/article/details/107144213)\n\n![xPath轴](https://gitee.com/rbozo/picgo_image/raw/master/image/0/20210822185037.png)\n\n### 演示代码\n\n```Python\n# coding= utf-8\nfrom lxml import etree\n# fp = open('./index.html', 'rb')\n# html = fp.read().decode('utf-8')   #.decode('gbk')\n# selector = etree.HTML(html)   #etree.HTML(源码) 识别为可被xpath解析的对象\n# print(selector)\n\nhtml = etree.parse('./index.html',etree.HTMLParser())\n# print(etree.tostring(html).decode('utf-8'))\n\nall_node = html.xpath('//*')  # 所有节点的获取 //*\npart_node = html.xpath('//li')  # 部分节点 格式：//节点名\nchild_node = html.xpath('//li/a')  # 匹配子节点\nparent_node = html.xpath('//a[@href=\"//mr90.top\"]/../@class')  # 获取父节点属性值的方法 ../@属性名\nattrs_node = html.xpath('//a[contains(@class,\"a\")]/text()')   # 获取属性中包含多个值的情况 属性多值匹配 contains()方法\n# 按序获取\nfirst_node = html.xpath('//li[1]/a/text()')  # 获取第一个\nlast_node = html.xpath('//li[last()]//text()')   # 获取最后一个节点\nfront_node = html.xpath('//li[position()<3]//text()')    # 获取前两个节点\nend_ndoe = html.xpath('//li[last()-2]//text()')   # 获取到数第三个节点\n\n# 轴节点\nchild_node_z = html.xpath('//li[position()<2]/child::a/@href')  # 获取当前节点所有子元素的a节点的href属性值\nattribute_node = html.xpath('//li[2]//attribute::lang')  # 获取当前节点的指定元素的属性值\nall_child_node = html.xpath('//ul/li[last()-1]//child::*')  # 获取当前节点的所有的文本节点\nall_attrs_node = html.xpath('//li[1]/a/attribute::*')  # 获取当前节点 的所有属性的属性值\nall_child_text_node = html.xpath('//li[1]//child::text()')  # 获取当前节点所有文本子节点\nall_child_node_node = html.xpath('//li[1]/a/child::node()')  # 获取当前节点所有子元素\nancestor_self = html.xpath('//a[@title=\"1\"]/../ancestor-or-self::li') # 获取当前元素的所有父辈为li元素的节点（包括当前元素）\nprint(ancestor_self)\n```\n\n## Beautifulsoup4使用\n\n* `Beautiful Soup`自动将输入文档转换为Unicode编码, 输出文档转换为utf-8编码\n* 使用前安装 `pip install beautifulsoup4`\n* 引入`from bs4 import Beautifulsoup4`\n\n### 获取内容\n\n* 标签有两个重要的属性name, attrs\n* 文本内容的获取有三种方法\n* `.string`方法返回一个迭代器\n* `.text`方法返回节点文本\n* `.get_text()`方法返回节点文本\n\n```Python\n\n## 获取标题对象\n\nprint(soup.title)  # <title>xPath方法</title>\n# 获取标题内容\nprint(soup.title.string)  # 返回迭代器\nprint(soup.title.text)\nprint(soup.title.get_text())\nprint(soup.find('title').get_text())\n```\n\n* 通过上下级获得对象\n\n```Python\n# print(soup.title.parent)   # 返回父节点包括父节点中的内容\nprint(soup.li.child)  # Node\nprint(soup.li.children)  # 返回一个迭代器\n```\n\n### 获取第一个li标签\n\n```Python\nprint(soup.li.get_text())  # 匹配到第一个，返回所有节点的文本信息\nprint(soup.find('li').text)\n# 获取ul的子标签们   (空行也看成了一个children)\nprint(soup.ul.children)\nfor index, item in enumerate(soup.ul.children):\n    print(index, item)\n```\n\n### 获取元素的属性\n\n* 使用 `.属性名` 的方法, 但是只能获取到一个\n* 使用`元素.attrs['属性名']`的方法返回的时一个列表\n* 如果使用两次 `soup.元素` 第一次获取的是匹配到的第一个元素, 第二次是匹配到的第二个元素\n\n### 获取多个元素\n\n* find方法获取一个元素\n* find_all获取多个元素, 可以加上`limit`来达到限制个数的问题,  `recursive = True` 寻找子孙 ; `recursive = False`只找子\n* 多层级查找 find_all返回的是一个列表 可以遍历该列表再次使用find方法或者find_all方法 进行元素的获取\n\n### 通过指定的属性, 获取对象\n\n* id和class选择器, class比较特殊, 因为是关键字 在使用class时改成`class_`\n\n```Python\nprint(soup.find(id='a'))\nprint(soup.find('a', id='a'))\nprint(soup.find_all('a', id='a'))  # 可以使用下标查询\n\n# class是关键字 要这么写class_\n\nprint('class1', soup.find_all('a', class_='a'))\nprint('class2', soup.find_all('a', attrs={'class': 'item'}))  # 更通用\nprint('class3', soup.find_all('a', attrs={'class': 'item', 'id': 'a'}))  # 多条件\n```\n\n### 使用函数作为参数, 返回元素\n\n```Python\ndef judgeTilte1(t):\n    if t == 'a':\n        return True\n\nprint(soup.find_all(class_=judgeTilte1))\n```\n\n* 根据长度来判断\n\n```Python\n# 判断长度\nimport re  # 正则表达式\nreg = re.compile(\"item\")\ndef judgeTilte2(t):\n    # 返回长度为5，且包含'item'的t参数\n    return len(str(t)) == 5 and bool(re.search(reg, t))\nprint(soup.find_all(class_=judgeTilte2))\n```\n\n### 可以使用css选择器\n\n* select方法返回的都是一个列表\n* 可以通过标签名查找, 属性查找, 标签+类名+id, 组合查找\n\n[Python中BeautifulSoup库的用法](https://blog.csdn.net/qq_21933615/article/details/81171951)\n[python beautiful soup库的超详细用法](https://blog.csdn.net/love666666shen/article/details/77512353)\n[python 爬虫 提取文本之BeautifulSoup详细用法](https://blog.csdn.net/IT_arookie/article/details/82824620)\n","categories":["python"]},{"title":"Sass--CSS预处理器","url":"/posts/902/","content":"\n## 认识sass\n\n* 它是一个css的预处理器, 文件的后缀为`.scss`\n\n## 安装\n\n```shell\nnpm i -g sass\n# 使用\n$ sass <input.scss> [output.css]\n```\n\n## 语法规则\n\n### 动态变量\n\n```sass\n// 使用变量,可以在变量中使用变量\n$primary-color:#1269b5;\n\np {\n  width: 20px;\n  color: $primary-color;\n}\n```\n\n### 嵌套\n\n* 使用嵌入式, 使用`&`符号 连接伪元素\n* 属性的嵌套, 如果有多个相同前缀的属性, 使用`前缀名:{后缀属性: 属性值}`\n\n```CSS\n.nav {\n  ul {\n    li {\n      color: $primary-color;\n    }\n\n    a {\n      text-align: center;\n\n      &:hover {\n        font-size: 20px;\n      }\n    }\n  }\n}\n```\n\n```CSS\n/* // 属性的嵌套 前缀有-可以使用  前缀名：{} */\nbody {\n  font: {\n    size: 20px;\n    weight: normal;\n    family: Arial, \"Helvetica Neue\", Helvetica, sans-serif;\n  }\n}\n```\n\n### mixin alert函数\n\n* 可以给alert函数加参数也可以不加, 调用时使用include方法调用alert函数\n* 也可以给alert函数参数定义默认值\n\n```CSS\n/* // mixin */\n\n@mixin alert($text-color, $background) {\n  color: $text-color;\n  background-color: $background;\n\n  a {\n    color: $primary-color;\n    background-color: darken($text-color, 10%);\n  }\n}\n\n.alert-warning {\n  @include alert(#1269b5, #fff);\n}\n```\n\n### 继承extend\n\n```CSS\n/* // 继承 */\n\na {\n  text-decoration: none;\n}\n\n.info {\n  @extend a;\n}\n```\n\n### @import方法\n\n* 导入时不需要加入后缀\n* 多行注释在不压缩编译后也能显示\n\n```CSS\n@import 'base';\n```\n\n### data-type\n\n* 使用type-of方法来判断数据类型\n* 在终端输入`sass -i`\n\n![type-of](https://gitee.com/rbozo/picgo_image/raw/master/image/0/347b8c3814b49d227c2790447075cc3.png)\n\n### 数字函数\n\n* `abs()` 绝对值\n* `round()` 方法 四舍五入\n* `ceil()` 方法 向上取整 取大\n* `floor()` 方法 向下取整  取小\n* `min() max()` 判断大小\n\n#### 字符串处理方法\n\n* `to-upper-case()`方法 将字符串全部改为大写\n* `to-lower-case()`方法 全部改为小写\n* `str-length(变量)` 输出字符串的长度\n* `str-index(变量, 检测的字符串)`  输出当前检测字符串在变量字符串中第一次出现的索引号\n* `str-insert(变量, 输入插入的值, 索引位置)` 在字符串的指定位置插入值\n\n### 颜色函数\n\n* `adjust-hue` 对颜色值进行调整, 对hsl颜色进行调整\n* `darken`函数可以改变颜色的深度, 更暗 `lignten`函数更亮, 第一个参数是要转换的值, 第二个参数是改变的程度百分比\n* `saturate函`数 颜色的饱和度 `desaturate`函数 减少颜色的饱和度 对hsl颜色进行处理\n* opacify函数 设置不透明度\n* transparentize函数 设置透明度\n\n### 列表 List\n\n* length方法, index方法 nth方法 append方法\n* join方法组合 使用comma 会使用', '分隔\n* map-get()方法获取 列表对应的属性值 map-keys 返回所有的key值, map-value 返回列表中的值, 判断是否存在某个属性, 使用map-has-key方法 map-merge()方法将新创建的属性加入到列表中使用map-remove方法来移除列表中的指定属性\n\n### 使用interpolation方法\n\n* `#{}` 格式\n\n```CSS\n// 使用变量,可以在变量中使用变量\n$version:\"0.0.1\";\n/* 当前的版本号#{$version} */\n$name:'info';\n$attr:'border';\n\n.border-#{name} {\n  #{$attr}-radius: 10px;\n}\n```\n\n### 控制指令\n\n* @if\n\n```CSS\n$primary-color:#1269b5;\n$state:true;\n\n.info-warp {\n  @if $state {\n    color: $primary-color;\n  }\n}\n```\n\n* @for, through包括最后一个值; to不包括\n\n```CSS\n$colums:4;\n\n@for $i from 1 through $colums {\n  .col-#{$i} {\n    width: 100% / $colums*$i;\n  }\n}\n```\n\n* @each 遍历数组\n\n```CSS\n$icons: error success info;\n\n@each $i in $icons {\n  .col-#{$i} {\n    background: url('image/#{$i}.png');\n  }\n}\n```\n\n* @while 计算字符要空格\n\n```CSS\n$i:6;\n\n@while $i>0 {\n  .item-#{$i} {\n    width: 5px * $i;\n    color: $primary-color;\n  }\n\n  $i: $i - 2;\n}\n```\n\n## 自定义函数\n\n* 格式`@function(传入的参数){@return 属性值}`如果是对象可以使用map方法获取第一个参数是构造的对象属性, 第二个参数是要调用的对象参数\n\n```CSS\n$color:(light:#fff, dark:#000);\n\n@function color($key) {\n  @return map-get($color, $key)\n}\n\n.oi {\n  color: color(dark)\n}\n```\n\n### 警告和错误\n\n* @warn和@error 打印输入 在终端输出\n","categories":["web","sass"]},{"title":"Vue2.0基础知识补充","url":"/posts/22540/","content":"\n## Vue的特性\n\n### 数据驱动视图\n\n* 当页面数据发生变化时, 页面会重新渲染\n* 单向的数据绑定\n\n### 双向数据绑定\n\n* form表单负责采集数据, ajax负责提交数据\n\n> 注: 数据驱动视图和双向数据绑定的底层原理是MVVM\n\n## MVVM\n\n* Model, View, ViewModel\n* Model 表示当前页面渲染时所依赖的数据源\n* View 表示当前页面所渲染的DOM结构\n* ViewModel  表示Vue的实例\n\n## 品牌列表案例\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <script src=\"https://cdn.jsdelivr.net/gh/Rr210/hexofixed@v0.47/js/jquery-3.5.1.min.js\"></script>\n  <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/gh/Rr210/hexofixed@frame/frame/bootstrap/3/css/bootstrap.min.css\">\n  <script src=\"https://cdn.jsdelivr.net/gh/Rr210/hexofixed@frame/frame/bootstrap/3/js/bootstrap.min.js\"></script>\n  <title>Document</title>\n</head>\n<style>\n  body {\n    padding: 0;\n    margin: 0;\n    box-sizing: border-box;\n  }\n\n  .tab {\n    margin: 100px auto;\n  }\n\n  .checkOn {\n    overflow: hidden;\n    width: 66px;\n    height: 25px;\n    line-height: 25px;\n    border-radius: 20px;\n    border: 1px solid #888;\n    font-size: 8px;\n  }\n\n  .check_warp {\n    position: relative;\n  }\n\n  input[id^=\"check\"][type=\"checkbox\"] {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    top: 0;\n    left: 0;\n    opacity: 0;\n  }\n\n  .on {\n    float: left;\n    width: 23px;\n    height: 23px;\n    line-height: 23px;\n    border-radius: 50%;\n    background-color: #ccc;\n    color: #000;\n  }\n\n  .isChecked {\n    background-color: #fff;\n  }\n\n  .isbg {\n    color: #fff;\n    background-color: rgb(0, 110, 255);\n  }\n\n  .form_data {\n    margin: 20px 0;\n  }\n\n  #btn1 {\n    outline: none;\n  }\n</style>\n\n<body>\n  <div class=\"tab container text-center\" id=\"app\">\n    <h2>汽车品牌列表</h2>\n    <form class=\"form-inline form_data\" @submit.prevent=\"add\">\n      <div class=\"form-group\">\n        <label class=\"sr-only\" for=\"exampleInputAmount\">Amount (in dollars)</label>\n        <div class=\"input-group\">\n          <div class=\"input-group-addon\">请输入品牌</div>\n          <input type=\"text\" class=\"form-control\" id=\"exampleInputAmount\" name=\"brand_name\" placeholder=\"请输入要添加的品牌\">\n        </div>\n      </div>\n      <button class=\"btn btn-primary\" id=\"btn1\" type=\"submit\">添加</button>\n      <a class=\"\" tabindex=\"0\" class=\"btn btn-lg btn-danger\" role=\"button\" id='btn2' data-toggle=\"popover\" data-trigger=\"\" data-delay=\"show:500;hide:400\" title=\"提示\" data-content=\"\"></a>\n    </form>\n    <table class=\"table table-striped table-bordered justify-content-center table-hover\">\n      <thead>\n        <tr>\n          <th class=\"text-center\" v-for=\"(item,index) in th_title\">{{item}}</th>\n        </tr>\n      </thead>\n      <tbody>\n        <tr v-for=\"(item,index) in brandList\" :key=\"item.id\">\n          <td>{{index+1}}</td>\n          <td>{{item.brand_name}}</td>\n          <td>\n            <div class=\"check_warp\">\n              <label :for=\"'check'+item.id\" :class=\"item.status?'checkOn isbg':'checkOn'\">\n                <div :class=\"item.status?'on isChecked':'on'\" :style=\"item.status?'float:right':'float:left'\"></div>\n                {{item.status?'已启用':'已禁用'}}\n              </label>\n              <input @change=\"getFloat\" :data-index='index' type=\"checkbox\" :checked=\"item.status\" name=\"status\" :id=\"'check' + item.id\">\n            </div>\n          </td>\n          <td>{{item.time | formatDate}}</td>\n          <td><button @click=\"remove(index)\">移除</button></td>\n        </tr>\n      </tbody>\n    </table>\n  </div>\n</body>\n<script src=\"../../js/vue.js\"></script>\n<script>\n  const app = new Vue({\n    el: '#app',\n    data: {\n      th_title: ['#', '品牌名称', '状态', '创建时间', '操作'],\n      brandList: [{\n          id: 0,\n          brand_name: '宝马',\n          status: true,\n          time: new Date()\n        },\n        {\n          id: 1,\n          brand_name: '奔驰',\n          status: false,\n          time: new Date()\n        },\n        {\n          id: 2,\n          brand_name: '奥迪',\n          status: true,\n          time: new Date()\n        },\n        {\n          id: 3,\n          brand_name: '路虎',\n          status: true,\n          time: new Date()\n        }\n      ]\n    },\n    methods: {\n      getFloat(e) {\n        let {\n          checked\n        } = e.target\n        let {\n          index\n        } = e.target.dataset\n        this.brandList[index].status = checked\n      },\n      remove(index) {\n        this.brandList.splice(index, 1)\n      },\n      add(e) {\n        let timer;\n        let brand_name = $('#exampleInputAmount').val().trim()\n        if (brand_name.length == 0) {\n          this.getmodal('您输入的内容为空,请重新输入!!')\n        } else {\n          this.brandList.push({\n            id: this.brandList.length,\n            brand_name,\n            status: false,\n            time: new Date()\n          })\n          this.getmodal('品牌已成功添加到列表中')\n        }\n      },\n      getmodal(content) {\n        $('.popover-content').text('') // 先清空\n        $('#btn2').data('content', content).popover('show')\n        timer = setTimeout(function() {\n          $('#btn2').popover('destroy')\n        }, 2500)\n      }\n    },\n    filters: {\n      formatDate: function(now) {\n        var year = now.getFullYear(); //取得4位数的年份\n        var month = now.getMonth() + 1; //取得日期中的月份，其中0表示1月，11表示12月\n        var date = now.getDate(); //返回日期月份中的天数（1到31）\n        var hour = now.getHours(); //返回日期中的小时数（0到23）\n        var minute = now.getMinutes(); //返回日期中的分钟数（0到59）\n        var second = now.getSeconds(); //返回日期中的秒数（0到59）\n        return year + \"-\" + month + \"-\" + date + \" \" + hour + \":\" + minute + \":\" + second;\n      }\n    }\n  })\n</script>\n\n</html>\n```\n\n![演示效果](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/api/3123123.gif)\n\n## 过滤器\n\n* 常用于文本的格式化, 插值表达式和v-bind属性绑定\n* 格式: 要转换的值 | 方法\n* 知识回顾: 获取字符串中第一个值得方法使用 `charAt(索引号)`\n* 全局过滤器 在最外面使用Vue.filter() 定义一个全局过滤器\n* 如果全局过滤器和私有过滤器得名称一致, 遵循就近原则\n\n## 侦听器watch\n\n* 监听数据得变化, 侦听器本质上一个函数, 要监视那个数据得变化, 就要把数据作为方法名即可. 而且方法中也可以加上参数; 新值在前, 旧值在后\n* 侦听器的格式\n* `方法格式的侦听器` 无法在进入页面的时候, 自动触发\n* `对象格式侦听器`  在对象中加入immediate属性 将它的值改为true , handler是固定的写法\n\n```JS\nconst app = new Vue({\n  el: '#app',\n  data: {\n    username: \"\"\n  },\n  watch: {\n    // 方法格式侦听器\n    // username: function (newval, oldval) {\n    //   if (newval.trim().length == 0) return\n    //   $.get('https://www.escook.cn/api/finduser/' + newval, function (e) {\n    //     console.log(e);\n    //   })\n    // }\n    // 对象格式\n    username: {\n      handler(newval, oldval) {\n        console.log(newval, oldval);\n      },\n      immediate: true\n    }\n  }\n})\n```\n\n### 深度侦听deep\n\n* 在对象格式的侦听器里面加入deep参数\n\n```JS\nconst app = new Vue({\n  el: '#app',\n  data: {\n    info: {\n      username: 'admin'\n    }\n  },\n  watch: {\n    // info: {\n    //   handler(newval) {\n    //     console.log(newval);\n    //   },\n    //   deep: true\n    //   // 开启深度侦听只要对象中任何一个属性变化了 都会触发对象的侦听器\n    // }\n    // 如果要侦听的是对象的子属性的变化,必须包裹一层单引号\n    'info.username': {\n      handler(newval) {\n        console.log(newval);\n      }\n    }\n  }\n})\n```\n\n## axios\n\n* 专注于网络请求的库, 在请求到数据之后, 在真正的数据之外套了一层壳\n\n```js\nconfig, data, headers, request, status, statusText\n```\n\n* 如果调用某个方法的返回值是Promise实例则前面可以添加await\n\n```HTML\n <div id=\"app\">\n   <button id=\"infoGet\">Get</button>\n   <button id=\"infoPost\">Post</button>\n </div>\n <!-- <script src=\"../../js/vue.js\"></script> -->\n <script src=\"../../js/axios.min.js\"></script>\n <script>\n   // axios get事件\n   document.querySelector('#infoGet').addEventListener('click', async function() {\n     const {\n       data: res\n     } = await axios({\n       method: \"get\",\n       url: 'http://www.liulongbin.top:3006/api/getbooks/'\n     })\n     console.log(res);\n   })\n   // axios post事件\n   document.querySelector('#infoPost').addEventListener('click', async function() {\n     const {\n       data\n     } = await axios({\n       method: \"post\",\n       url: 'http://www.liulongbin.top:3006/api/post/',\n       data: {\n         name: 'zs',\n         age: 20\n       }\n     })\n     console.log(data.data);\n   })\n </script>\n```\n\n* 将axios请求后的返回值进行解构重命名\n* 简写axios.get()和axios.post()类似于ajax中的$.get()方法\n\n```HTML\n  <div id=\"app\">\n    <button id=\"infoGet\">Get</button>\n    <button id=\"infoPost\">Post</button>\n  </div>\n  <!-- <script src=\"../../js/vue.js\"></script> -->\n  <script src=\"../../js/axios.min.js\"></script>\n  <script>\n    // axios get事件\n    document.querySelector('#infoGet').addEventListener('click', async function() {\n      const {\n        data: res\n      } = await axios.get('http://www.liulongbin.top:3006/api/getbooks/', {\n        params: {\n          id: 1\n        }\n      })\n      console.log(res);\n    })\n    // axios post事件\n    document.querySelector('#infoPost').addEventListener('click', async function() {\n      const {\n        data: res\n      } = await axios.post('http://www.liulongbin.top:3006/api/post/', {\n        name: 'zs',\n        age: 20\n      })\n      console.log(res);\n    })\n```\n\n## vue-cli\n\n* 标准工具\n* 安装配置参考[cli.vuejs.org](https://cli.vuejs.org/zh/guide/installation.html)\n* 运行`vue create first-project`\n* 有两种方法指定渲染区域 `el`或者使用`$mount('#app')`\n\n## 解决样式的冲突\n\n* 使用属性选择器, 每一个组件中都有一个唯一的属性\n* 在样式中加入scoped属性\n* 如果想修改子组件中的样式在scoped的情况下 使用`/deep/`\n\n## 父子组件传值\n\n* 不建议修改父传过来的值`props`\n* 子向父传值需要使用自定义事件`$emit`\n* 数据共享 数据发送方使用`$emit`, 数据接受方使用`$on` 构建一个实例对象\n\n## 生命周期\n\n![生命周期](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/api/lifecycle.png)\n\n## 基础知识思维导图\n\n![基础知识思维导图](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/api/siweixmind.png)\n\n## $refs引用\n\n* 获取DOM元素或者组件的引用\n* 也可以拿到组件调用组件中的方法\n\n## $nextTick()方法\n\n* 当页面重新渲染完成后执行\n\n## 动态渲染组件\n\n* 它提供了一个内置的组件`component`\n* 使用动态绑定is属性, 展示自定义组件\n\n```html\n<keep-alive>\n  <component :is=\"conTog\"></component>\n</keep-alive>\n```\n\n## keep-alive 方法\n\n* 让组件保持激活状态 将要保存的组件放到keep-alive标签中, 把包裹的组件进行缓冲, 不会销毁组件\n* 在被缓存和被激活时有着不同的生命周期, 被缓存时deactivated, 被激活时activated, 当组件第一次被创建时执行created生命周期也会执行activated\n* include属性包括需要缓冲的组件, 使用逗号分隔\n* exclude属性排除不会缓冲的组件, 这两个属性不能同时使用\n* 如果组件有自己的注册名称, 在使用exclude, include属性时需要使用组件的注册名称`name`\n\n## 插槽slot\n\n* 占位符, 每个插槽都有一个默认的名称, 具名插槽 `name=default`\n* 指定某个内容渲染到某个指定的插槽中, 使用`v-slot`方法, 只能在`模板标签`或者组件上使用, 不能直接在元素上使用, 不会被渲染到页面上只起到包裹的作用\n* `v-slot` 语法糖为 `#`\n* 如果想给插槽定义默认内容, 直接在slot标签中\n* 也可以在插槽上接受slot属性对象, 作用域插槽\n* 作用域插槽的解构赋值\n\n## 自定义指令(全局和私有)\n\n* 私有自定义指令的节点 `directives`\n* 当指令被`第一次`被绑定到元素上的时候, 会立即触发bind函数\n* 参数为绑定的DOM元素 使用binding.value获取自定义的值\n* bind函数 第一次执行指令时\n* update函数  在DOM更新时会触发\n* bind和update方法相同时可以简写\n\n```HTML\n<h1 v-color=\"color\">App 根组件</h1>\n<span v-color=\"'blue'\">你好世界</span>\n<script>\n  // directives: {\n  //     color: {\n  //       bind(el, binding) {\n  //         console.log(\"打印一次自定义的指令\");\n  //         console.log(el, binding);\n  //         el.style.color = binding.value;\n  //       },\n  //       update(el, binding {}\n  //       },\n  //     }\n  color: function(el, binding) {}\n</script>\n```\n\n## 路由\n\n* 对应关系, spa单页面\n* 哈希地址和组件的关系\n\n```JS\n  created() {\n    onhashchange = (res) => this.hash = location.hash.slice(2, 3).toUpperCase() + location.hash.slice(3)\n  }\n```\n\n### vue-router\n\n![vue-router](https://gitee.com/rbozo/picgo_image/raw/master/image/0/93060f361b3be1355457efde2c453b2.png)\n\n* 在进行模块化导入的时候, 如果给定的是文件夹, 则默认去调用index.js文件\n\n### 声明路由链接和占位符\n\n* 导入Vue-router后直接在页面中加入标签`router-view`\n* 在routes中创建哈希地址和组件的对应对象\n* 使用router-link替换原来的链接\n* 使用路由重定向`{path:\"/\", redirect:\"/home\"}`\n\n![哈希和组件的对应关系](https://gitee.com/rbozo/picgo_image/raw/master/image/0/e18c097c132e140186eeb44c8756a76.png)\n\n### 嵌套路由\n\n* 声明children属性 声明子路由规则, 子路由环境不需要加斜线\n\n```JS\nconst router = new VueRouter({\n  // 定义哈希地址和组件的对应关系\n  routes: [{\n      path: \"/\",\n      redirect: '/home'\n    },\n    {\n      path: \"/home\",\n      component: Home\n    },\n    {\n      path: \"/movie\",\n      component: Movie\n    },\n    {\n      path: \"/about\",\n      component: About,\n      redirect: \"/about/tab1\",\n      children: [{\n          path: \"tab1\",\n          component: Tab1\n        },\n        {\n          path: \"tab2\",\n          component: Tab2\n        }\n      ]\n    }\n  ]\n})\n```\n\n### 默认子路由\n\n* 某个子路由规则path值为空字符串\n\n### 动态路由\n\n* 把hash地址中的可变部分定义为参数项, 使用`:id`\n* 使用 `$route.params` 路由参数对象\n\n![$route.params](https://gitee.com/rbozo/picgo_image/raw/master/image/0/5847824fd639b5715da4e36a2de1850.png)\n\n* 可以为路由规则开启`props`传参, 获取动态参数的值\n* 在哈希地址中/后面的参数项, 叫做路径参数, 在路由参数对象中需要使用`this.$route.params`方法获取路径参数, 查询参数使用`query`获取\n* 在`this.$route`中path只是路径部分, `fullpath`是完整的地址\n\n## 声明式导航 编程式导航\n\n* 点击链接的方法叫声明式导航, 调用浏览器API叫编程式导航\n\n### vue-router方法\n\n* `this.$router.push('哈希地址')` 跳转到指定的hash地址, 并增加一条历史记录\n* `this.$router.replace('hash地址')` 跳转到指定的地址, 并替换当前的历史地址\n* `this.$router.go(n)` 实现导航历史的前进后退; `$router.back()`, `$router.forward()`分别表示后退到上一个页面, 前进到下一个页面\n\n### 导航守卫\n\n* 控制路由的访问权限\n* 创建全局前置守卫\n* 发生了路由的跳转运行后会主动的调用beforeEach指定的回调函数\n* next有三种调用方法, 直接调用next() next('/admin') next(false)\n\n![全局前置守卫](https://gitee.com/rbozo/picgo_image/raw/master/image/0/20210819202118.png)\n","categories":["web","vue"]},{"title":"webpack-前端工程化","url":"/posts/255/","content":"\n## 实际前端开发\n\n1. 模块化(js)\n2. 组件化(ui)\n3. 规范化\n4. 自动化(构建,部署,自动化测试)\n\n## 初识webpack\n\n* 功能: 代码压缩混淆, 处理浏览器JavaScript的兼容性, 性能优化\n* 定义: 解决前端工程化的具体解决方案\n\n## 初始化配置\n\n* `npm install init -y` 初始化`package.json`\n* `-S` --save, 将下载的包名和版本号 装到`dependencies`下(开发和部署)\n* `-D` --save-dev, 将包记录到`devDependencies`(只在开发过程中)\n* 安装webpack `npm i webpack@5.42.1 webpack-cli@4.7.2 -D`\n* 在根目录下配置`webpack.config.js` 配置当前的环境mode 有两种选择 development和production\n* 运行webpack 在package.json 下的scripts中配置webpack命令\n* 要想实现webpack压缩功能将webpack.config.js模式修改为`production`\n\n### entry指定打包入口\n\n* 表示要处理的那个文件\n* 使用path模块`path.join(__dirname, '')`\n\n### output指定打包出口\n\n* 数据类型对象 `path` 指定存放的目录 `filename` 生成的文件名\n\n## 安装插件\n\n* 安装`webpack-dev-server@3.11.2 -D` 实现实时自动打包\n* 将打包的文件生成到内存中, 不是物理磁盘中\n* 使用时将srcipt中的地址改为根目录`/`使用地址`http://localhost:8080`访问\n\n### 安装html-webpack-plugin\n\n* `npm i html-webpack-plugin@5.3.2 -D`\n* 把指定的页面加入复制到根目录, 内存中\n\n```JS\nconst path = require('path')\n// 导入html-webpack-plugin \nconst HtmlPlugin = require('html-webpack-plugin')\n// 创建插件的实例对象\nconst html = new HtmlPlugin({\n  // 指定复制的页面\n  template: './src/index.html',\n  // 指定复制出来的文件名和存档路径\n  filename: './index.html'\n})\nmodule.exports = {\n  mode: 'development', //productions,\n  entry: path.join(__dirname, './src/index.js'),\n  output: {\n    path: path.join(__dirname, 'dist'),\n    filename: 'main.js'\n  },\n  plugins: [html]\n}\n```\n\n### devSever 节点\n\n* 自动打开生成的网站, 展示网页效果\n\n```JS\n  devServer: {\n    open: true,\n    port: 9090, //自定义端口号\n    host: '127.0.0.1' // 指定打开地址\n  }\n```\n\n## loader 加载器\n\n* 处理非`.js`文件\n* 打包处理css文件 `npm i style-loader@3.0.0 css-loader@5.2.6 -D`\n* 当webpack发现某个文件处理不了的时候, 活查找webpack.confing.js这个配置文件中的module.rules数组中, 是否配置了对象的loader加载器\n* 打包处理less文件 `npm i less-loader@10.0.1 less@4.1.1 -D`\n* 打包图片的路径 `npm i url-loader@4.1.1 file-loader@6.2.0 -D`  可传递参数 limit 加上参数`<=limit`大小的图片 才会被转换成base64, 单位字节\n\n```JS\n  module: {\n    rules: [{\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader']\n      },\n      {\n        test: /\\.less$/,\n        use: ['style-loader', 'css-loader', 'less-loader']\n      },\n      {\n        test: /\\.(png|jpg|gif|jpeg)$/,\n        use: 'url-loader'\n      }\n    ]\n  }\n```\n\n* 使用`babel-loader`对js进行打包处理, 处理webpack无法处理的js高级语法 `npm i babel-loader@8.2.2 @babel/core@7.14.6 @babel/plugin-proposal-decorators@7.14.5 -D` 在根目录下创建一个babel.config.js文件 将插件配置写入 `[[\"@babel/plugin-proposal-decorators\", { \"legacy\": true }], [\"@babel/plugin-proposal-class-properties\"]]`\n\n```JS\nmodule.exports = {\n  plugins: [\n    [\"@babel/plugin-proposal-decorators\", {\n      \"legacy\": true\n    }]\n  ]\n}\n```\n\n## 配置build命令\n\n* 创建一个scripts 脚本 `webpack --mode production`\n* 将文件统一放到某个文件下 js配置path 图片在url中以地址方式传递outputPath参数\n* 使用`clean-webpack-plugin`插件将原来的dist文件先清理在生成\n\n## Source Map\n\n* 存储着原来的位置信息\n* 定位源代码的位置, 在配置文件中加入`devtool:'evel-source-map'` 开发环境下\n* 在发布项目时, 能定位行号, 但是不暴露源代码 `nosources-source-map` 生产环境下\n* 可以定位和显示源代码 使用`source-map`\n* @表示src源代码目录\n\n```JS\n  resolve: {\n    alias: {\n      \"@\": path.join(__dirname, './src/')\n    }\n  }\n```\n\n### webpack.config.js最终配置\n\n```JS\nconst path = require('path')\n// 导入html-webpack-plugin \nconst HtmlPlugin = require('html-webpack-plugin')\n// 创建插件的实例对象\nconst html = new HtmlPlugin({\n  // 指定复制的页面\n  template: './src/index.html',\n  // 指定复制出来的文件名和存档路径\n  filename: './index.html'\n})\nconst {\n  CleanWebpackPlugin\n} = require('clean-webpack-plugin');\nmodule.exports = {\n  devtool: 'nosources-source-map', // eval-source-map\n  mode: 'development', //productions,\n  entry: path.join(__dirname, './src/index.js'),\n  output: {\n    path: path.join(__dirname, 'dist'),\n    filename: 'js/main.js'\n  },\n  plugins: [html, new CleanWebpackPlugin()],\n  devServer: {\n    open: true,\n    port: 9090, //自定义端口号\n    host: '127.0.0.1' // 指定打开地址\n  },\n  module: {\n    rules: [{\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader']\n      },\n      {\n        test: /\\.less$/,\n        use: ['style-loader', 'css-loader', 'less-loader']\n      },\n      {\n        test: /\\.(png|jpg|gif|jpeg)$/,\n        use: 'url-loader?limit=447&outputPath=images'\n      },\n      // 处理高级的js语法\n      {\n        test: /\\.js$/,\n        use: 'babel-loader',\n        exclude: '/node_modules/'\n      }\n    ]\n  },\n  resolve: {\n    alias: {\n      \"@\": path.join(__dirname, './src/')\n    }\n  }\n}\n```\n","categories":["web","webpack"]},{"title":"初识Vue框架--基础知识","url":"/posts/35598/","content":"\n## 认识Vue\n\n1. 渐进式框架\n2. `Core+Vue-router+Vuex` 全家桶\n3. 特点：\n\n* 解耦视图和数据\n* 可复用的组件\n* 前端路由技术\n* 状态管理\n* 虚拟DOM\n\n## 初识Vue\n\n```js\nlet app = new Vue({\n  el: '#app', // 挂载要管理的元素\n  data: { // 定义数据\n    message: '你好，世界'\n  }\n})\n```\n\n## 简单计数器\n\n```html\n<div id=\"app\">\n  <h2>当前计数：{{counter}}</h2>\n  <button @click=\"counter++\">+</button>\n  <button @click=\"counter--\">-</button>\n</div>\n<script src=\"./js/vue.js\"></script>\n<script>\n  let app = new Vue({\n    el: '#app',\n    data: {\n      counter: 0\n    }\n  })\n</script>\n```\n\n```html\n<div id=\"app\">\n  <h2>当前计数：{{counter}}</h2>\n  <!-- <button @click=\"counter++\">+</button>\n    <button @click=\"counter--\">-</button> -->\n  <button v-on:click=\"addNum\">+</button>\n  <button v-on:click=\"subNum\">-</button>\n</div>\n<script src=\"./js/vue.js\"></script>\n<script>\n  let app = new Vue({\n    el: '#app',\n    // mushache语法\n    data: {\n      counter: 0\n    },\n    methods: {\n      addNum: function() {\n        this.counter++;\n      },\n      subNum: function() {\n        this.counter--;\n      }\n    }\n  })\n</script>\n```\n\n## 事件指令\n\n### v-once\n\n1. 只会在第一次的时候展示，只渲染一次\n2. 没有表达式\n\n### v-html和v-text\n\n1. 相当于`innerHTML`\n2. 相当于`innerText` 都会将标签中的内容覆盖\n\n### v-pre\n\n* 原文输出 不进行解析\n\n### v-bind\n\n1. 动态绑定class 使用`v-bind:class`或者`:class`\n2. class 里面可以写数组，对象，方法`methods`\n\n## 计算属性的setter和getter\n\n1. 计算属性一般是没有set方法,只读属性\n2. 使用计算属性中的set方法必须设置参数\n\n## v-on\n\n1. 可以使用`@` 代替`v-on:`\n2. 参数 不需要额外的参数小括号可以省略\n3. `$event`对象获取浏览器参数\n\n### 修饰词\n\n1. 修饰符`.stop`阻止事件冒泡\n2. 阻止表单的默认提交事件`.prevent`\n3. 监听键盘的事件`@keyup` 监听键盘回车事件`.enter`\n4. `.once`只能执行一次\n5. `.navice` 监听组件的事件\n\n## v-if\n\n* 多个元素 通过条件判断展示或者隐藏某个元素. 或者多个元素\n* 进行两个视图之间的切换\n\n### 条件渲染的问题\n\n1. 在渲染DOM时，会复用原来的DOM元素\n2. 使用`key`标识 会创建新的DOM元素\n\n## v-show\n\n* 元素隐藏 保留元素\n* 切换频率高时使用`v-show`\n\n## key的作用\n\n* 为了更高效的更新渲染虚拟DOM\n* `diff`算法\n\n## 响应式问题\n\n* 可以做到响应式:`push`在数组中追加元素; `pop()`删除数组中的最后一个元素, `shift()`删除数组中的第一个元素 `unshift()` 在数组中最前面追加元素; `splice()`删除元素/插入元素/替换元素(关键在第二个参数); `sort()`排序; `reverse()`进行反转; `Vue.set(修改的对象, 索引值, 要修改的元素)`\n* 通过索引值修改数组中的元素 无法进行页面渲染\n* `filters` filters不会修改数据, 只是改变用户看到的输出(效果)\n\n## 购物车案例\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>图书购物车</title>\n</head>\n<style>\n  body {\n    padding: 0;\n    margin: 0;\n    box-sizing: border-box;\n  }\n\n  .table_warp {\n    padding: 20px;\n  }\n\n  table {\n    border: 1px solid #ccc;\n    border-right: 0;\n    border-bottom: 0;\n    border-spacing: 0;\n  }\n\n  thead {\n    background-color: rgb(246, 246, 246);\n  }\n\n  td,\n  th {\n    padding: 10px;\n    border-bottom: 1px solid #ccc;\n    border-right: 1px solid #ccc;\n  }\n\n  button {\n    margin: 0 5px;\n  }\n</style>\n\n<body>\n  <div class=\"table_warp\" id=\"app\">\n    <h2>图书购物车</h2>\n    <div v-if=\"bookList.length\">\n      <table>\n        <thead>\n          <th>\n          <td v-for=\"(item,index) in th_title\">{{item}}</td>\n          </th>\n        </thead>\n        <tbody>\n          <tr v-for=\"(item,index) in bookList\">\n            <td>{{index+1}}</td>\n            <td>{{item.name}}</td>\n            <td>{{item.datePublish}}</td>\n            <td>{{item.price*item.puNum| getPrice}}</td>\n            <td><button @click=\"item.puNum>1?item.puNum--:false\">-</button>{{item.puNum}}<button @click=\"item.puNum++\">+</button></td>\n            <td><button @click=\"removeBook(index)\">移除</button></td>\n          </tr>\n        </tbody>\n      </table>\n      <div>总价格：{{totalPrice | getPrice}}</div>\n    </div>\n    <h3 v-else>购物车为空</h3>\n  </div>\n\n</body>\n<script src=\"./js/vue.js\"></script>\n<script>\n  const app = new Vue({\n    el: '#app',\n    data: {\n      th_title: ['书籍名称', '出版日期', '价格', '购买数量', '操作'],\n      bookList: [{\n          id: 0,\n          name: '《算法导论》',\n          datePublish: '2006-9',\n          price: 85.00,\n          puNum: 2\n        },\n        {\n          id: 1,\n          name: 'UNIX编程艺术',\n          datePublish: '2008-9',\n          price: 35.00,\n          puNum: 1\n        },\n        {\n          id: 2,\n          name: '《编程珠玑》',\n          datePublish: '2006-9',\n          price: 85.00,\n          puNum: 1\n        },\n        {\n          id: 3,\n          name: '《算法导论》',\n          datePublish: '2010-9',\n          price: 100.00,\n          puNum: 1\n        },\n        {\n          id: 4,\n          name: '《算法导论》',\n          datePublish: '2026-9',\n          price: 76.00,\n          puNum: 1\n        }\n      ]\n    },\n    computed: {\n      // 计算总价格\n      totalPrice() {\n        return this.bookList.reduce((v, i) => v + i.price * i.puNum, 0)\n      }\n    },\n    methods: {\n      // 移除书籍\n      removeBook(index) {\n        this.bookList.splice(index, 1)\n      }\n      // getPrice(price) {\n      //   return '￥' + price.toFixed(2)\n      // }\n    },\n    // 过滤器的使用\n    filters: {\n      getPrice(price) {\n        return '￥' + price.toFixed(2)\n      }\n    }\n  })\n</script>\n\n</html>\n```\n\n![案例图](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/api/6371acaac7ef14eca283499d99a8ace.png)\n\n## v-model\n\n* `input`双向绑定\n* `radio`使用时双向绑定 如果绑定的时相同的数据, `name`可以省略\n* `selected` 多个选择加入属性`multiple`\n\n```HTML\n<!-- <input type=\"text\" v-model='message'>{{message}}  使用v-model实现双向绑定 -->\n<input type=\"text\" :value=\"message\" @input=\"message = $event.target.value\">{{message}}\n<!--使用input事件-->\n```\n\n### 修饰符\n\n* `.lazy` 失去焦点或者用户点击回车时指向\n* 默认情况传入的数据类型为`string` 使用修饰词`.number` 将数据类型转换成number\n* `.trim` 将空格去除\n\n## 组件化开发\n\n* 拆分成一个一个的, 可复用的组件\n步骤\n* 创建组件构造器, 调用`Vue.extend()`方法\n* 注册组件 `Vue.component()`方法, 全局组件\n* 使用组件\n\n## components属性\n\n* 构建局部属性, 在Vue实例中\n\n## 父组件和子组件\n\n* 组件和组件之间存在层级关系\n\n### 父子组件的通信\n\n1. `props`属性 向子组件传递数据\n2. 自定义事件`$emit` 子传父\n\n#### props传值类型\n\n* 可以使用对象方法传递, 或者数组\n* 在使用对象方法时, 可以给传递的参数设定数据类型String, Array, Object, Null, Undefined, Number, Symbol\n* 也可以给传递的参数设定默认值`default`, 设定改参数是否必须接受传值`required`, 也可以自定义验证函数`validator`\n* 如果设定的数据类型为对象或者数组时 设置默认值时必须从一个工厂函数获取`default:function(){}`es5, `default(){}`es6\n\n### 子传父\n\n* 使用emit发送事件, 自定义事件\n\n## 注册语法糖\n\n* `Vue.component(组件标签名, {template})` 注册全局组件的语法糖\n* 局部注册组件在`components`中 `{(组件标签名, {template})}`\n\n### 分离template方法\n\n1. 通过script类型`text/x-template` 通过id来获取模板\n2. 或者直接通过`template`标签\n\n## 组件内data动态化实现\n\n* data类型不是对象类型, 而是函数类型, 在函数的返回值中定义数据data\n* data函数是为了使组件之间相互独立, 返回的数据 地址不相同\n","categories":["web","vue"]},{"title":"正则表达式（js）","url":"/posts/49925/","content":"\n## 正则字符串提取数字\n\n1. 使用\\d将数字匹配出来 /g全局匹配\n\n```js\nlet hd = 'daw21321dasda23123123';\n// 不使用正则表达式写一个方法\n// console.log(Number.isNaN(parseInt('1')));\n// ...将字符串转换成数组形式 Array.from()方法也可以 使用isNaN判断是否为非数字\n// let news = [...hd].filter(v=>!Number.isNaN(parseInt(v)));\n// 使用join方法连接\n// 使用正则表达式\nlet news = hd.match(/\\d/g).join(\"\")\nconsole.log(news);\n```\n\n\n## 正则字变量\n\n1. 使用eval()方法\n2. 使用test()方法返回的是布尔值\n\n\n\n```js\nlet hd = 'daw21321dasda23123123';\nlet a = '1';\nlet news = eval(`/${a}/`).test(hd)  // true\nconsole.log(news);\n```\n\n\n## 使用对象创建\n\n1. 替换字符串中匹配到的字符\n\n```html\n<div class=\"content\">mr90.top</div>\n<script>\nlet div = document.querySelector('.content')\nlet a = prompt('输入字符');\nlet regs = new RegExp(a,\"g\");\ndiv.innerHTML = div.innerHTML.replace(regs,search=>{\n    return `<span style=\"color:red\">${search}</span>`\n})\n</script>\n```\n\n## 选择符 |\n\n1. 匹配左右两侧的条件\n2. 原子组()  原子表[]\n\n```js\nlet tel = '023-2312322'\nconsole.log(/(023|020)\\-\\d{7,8}/.test(tel)); // true\n// 重复的条件使用原子组的方法{7，8}表示 7-8位的数字 \\- 表示转义\nlet reg = /(12|34)/;\nlet hd = '31w231';\nconsole.log(hd.match(reg)); // null\n```\n\n## 转义\n\n1. 在字面量里面 使用`\\d \\.` 将字符可实现转义\n2. 在构造函数中`\\d \\.` 表示的是该字符 所以 必须再加一个转义符 `\\\\d \\\\.`\n\n```js\nlet price = '12@21';\n// . 除换行外的任何字符\nconsole.log(/\\d+.\\d/.test(price)); //true\nlet reg = new RegExp('\\\\d+\\\\.\\\\d+')\n// \\\\ 双转义\nconsole.log(reg.test(price)); //false\n\n// 网址\nlet url = 'https://u.mr90.top'\nlet reg = new RegExp(/https?:\\/\\/\\w+\\.\\w+\\.\\w+/)\nconsole.log(reg.test(url)); //true\nconsole.log(/https?:\\/\\/\\w+\\.\\w+/.test(url)); //true\n```\n\n## 字符边界符\n\n1. 边界符表示开始和结尾必须满足条件 `/^[a-z]$/`\n2. `{3,6}` 加入边界字符 才能控制其数量范围\n\n```html\n<input type=\"text\" value=\"\" name=\"user\">\n<script>\n    document.querySelector(\"[name='user']\")\n    .addEventListener('keyup',function(){\n        let flag = this.value.match(/^[a-z]{3,6}$/)\n        console.log(flag);\n    })\n</script>\n```\n\n## 数值与空白元字符\n\n1. `\\d` 匹配数字 `\\D` 匹配非数字\n2. 在原子表中首页`^`表示非的意思`/[^]/`\n3. `\\s` 表示匹配空白和换行 `\\S` 非空白\n\n```js\nlet hd = '张三:021-9999299,李四:022-2122122'\n// 匹配所有的数字号码\nconsole.log(hd.match(/\\d{3}\\-\\d{7,8}/g)); //[\"021-9999299\", \"022-2122122\"]\n// 匹配姓名 + 表示匹配相邻的符合条件的\nconsole.log(hd.match(/[^:\\d,-\\s]+/g)); // [\"张三\", \"李四\"]\n```\n\n## w和W元字符\n\n1. `\\w` 匹配字母和数字 下划线\n2. `\\W`与之相反\n\n## 点字符的使用\n\n1. 匹配所有字符默认模式下，它匹配除了换行符以外的任意字符。\n\n```js\nlet hd = `wad\\nawd\\n`\nconsole.log(hd.match(/.+/g)); // [wad,awd]\n```\n\n## 匹配所有字符\n\n1. 在原子组中`[\\s\\S]` 或者`[\\d\\D]`\n2. 匹配标签使用 `/<span>[\\s\\S]+</span>/`\n\n## i和g 模式修正\n\n1. `g`全局匹配 `i`不区分大小写\n\n```js\nlet hd = `\n#1 js,200元 #\n#2 php,300元 #\n#9 mr90.top # 你好\n#3 node.js,180元 #\n`\nlet lessons = hd.match(/^\\s*#\\d+\\s+.+\\s+#$/gm).map(v => {\n    v = v.replace(/\\s*#\\d+\\s*/, '').replace(/\\s+#/, '')\n    let [name, price] = v.split(',')\n    return { name, price }\n})\nconsole.log(lessons);\n/*\n0: {name: \"js\", price: \"200元\"}\n1: {name: \"php\", price: \"300元\"}\n2: {name: \"node.js\", price: \"180元\"}\nlength: 3*/\n```\n\n## 汉字与字符属性\n\n1. `\\p`表示匹配字符\n2. `\\P` 相反\n\n## lastIndex\n\n1. lastIndex 属性用于规定下次匹配的起始位置\n2. `exec()` 方法用于检索字符串中的正则表达式的匹配。\n\n```js\nlet hd = 'dawdaw31';\nlet reg = /\\w/g;\nconsole.log(reg.exec(hd));\nconsole.log(reg.lastIndex); // lastIndex 属性用于规定下次匹配的起始位置\n// 将匹配到的值赋值给res 有值打印数据 否则返回null 不满足循环条件 循环\nwhile(res=reg.exec(hd)){\n    console.log(res);\n}\n```\n\n## y模式\n\n1. 后一次匹配都是从上一次匹配成功的下一个位置开始\n\n```js\nlet hd =`你好世界大王大大:11111111,1111231,213123212,\n达瓦达,网站:u.mr90.top`\nlet reg = /(\\d+),?/y\nreg.lastIndex = 9\nlet qq = []\n// console.log(reg.exec(hd)); \nwhile(res=reg.exec(hd)) qq.push(res[1])\nconsole.log(qq);\n```\n\n## 原子表\n\n1. `[]` 匹配中括号内的所有条件\n2. 原子组和原子表搭配使用\n\n```js\nlet times = '2020-02/21'\nconsole.log(times.match(/^\\d{4}[-\\/]\\d{2}[-\\/]\\d{2}$/)); // 2020/02-21\nconsole.log(times.match(/^\\d{4}([-\\/])\\d{2}\\1\\d{2}$/)); // null\nconsole.log(times.match(/^\\d{4}([-\\/])\\d{2}\\1\\d{2}$/)); // 2020/02/21\n```\n\n## 区间匹配\n\n1. 数字区间`[0-9]+` 加号表示贪婪模式\n2. 字母区间`[a-z]`\n\n## 排除匹配\n\n1. `[^]` 表示排除匹配\n2. `\\p`表示匹配满足`{}`内的字符\n\n```js\n// let hd = 'u.mr90.top'\n// console.log(hd.match(/[^u]/gi)); //[\".\", \"m\", \"r\", \"9\", \"0\", \".\", \"t\", \"o\", \"p\"]\nlet hd = `张三:231-23123123,李四#:123-312313;`\nconsole.log(hd.match(/[^:\\w-,#;]+/g)); // 贪婪模式下的排除匹配\nconsole.log(hd.match(/\\p{sc=Han}+/gu)); // [\"张三\", \"李四\"]\n```\n\n## 原子表字符不解析\n\n1. `[.+]` `[()]` 仅表示原来字符的意思\n\n## 原子表匹配\n\n1. `s`忽略换行符 `*`表示0个或者多个\n2. `[\\d\\D] [\\s\\S]` 匹配所有字符\n\n```html\n<body>\n    <h1>ddawd\n        dawd\n    </h1>\n    <h2>dwad\n\n    </h2>\n    <span>dasdwa\n        adaw\n    </span>\n</body>\n<script>\n    let body = document.body;\n    // let reg = /<(\\w+)>[^]+<\\/\\1>/gi // 注意贪婪模式\n    let reg = /<(h[1-6])>[^]*<\\/\\1>/gi // 注意贪婪模式 *表示0个或者多个\n    body.innerHTML = body.innerHTML.replace(reg,'')\n</script>\n```\n\n## 原子组\n\n1. `()` 表示一个整体\n2. 可进行别名的编号\n3. 使用原子组实现标签的替换\n4. 在原子组回调函数中,各个参数表示的是 第一个是满足条件的所有内容 其他参数 依次为定义的满足原子组条件的内容\n\n```html\n<body>\n    <h1>ddawd\n        dawd\n    </h1>\n    <h5></h5>\n    <h2>dwad\n\n    </h2>\n    <span>dasdwa\n        adaw\n    </span>\n</body>\n<script>\n    // 原子组替换\n    let body = document.body\n    // body.innerHTML = body.innerHTML.replace(/<(h[1-6]+)>([^]*)<\\/\\1>/g,`<p>$2</p>`) // 直接表示\n    body.innerHTML= body.innerHTML.replace(/<(h[1-6]+)>([^]*)<\\/\\1>/g,(f0,f1,f2)=>{\n        // console.log(f0);  // 输入满足条件的所有\n        // console.log(f1); // 输出第一个原子组匹配的内容\n        // console.log(f2);// 输出第二个原子组匹配的内容\n        return `<p>${f2}</p>`\n    }) // 函数表示\n</script>\n```\n\n## 不记录分组\n\n1. 使用不记录分组,就是使用原子组后 无法再去使用函数参数去调用\n\n```js\n   let url = `https://u.mr90.top\n    http://github.com\n    httpS://mr90.top`\n    // 使用不记录分组,就是使用原子组后 无法再去使用函数参数去调用\n   let reg = /https?:\\/\\/((?:\\w+\\.)?\\w+\\.(?:com|top))/gi\n   console.log(reg.test(url)); //true // 有满足条件的内容\n   console.log(url.match(reg)); // [\"https://u.mr90.top\", \"http://github.com\", \"httpS://mr90.top\"]\n//    console.log(reg.exec(url)); // 返回满足条件的第一个内容\n//    console.log(reg.lastIndex); // 记录下次开始时的索引位置\n   let urlA = [];\n   while(res=reg.exec(url)) urlA.push(res[1])\n   console.log(urlA);\n```\n\n## 重复匹配\n\n1. `+`  一个或者多个 `{1,}` 类似与加号\n2. `*` 0个或者多个 `{0,}` 类似与*号\n3. `?` 0个或者1个\n\n## 批量使用正则完成密码的验证\n\n```js\n// 对表单输入的值进行验证\ndocument.querySelector('[name=pwd')\n    .addEventListener('keyup', (e) => {\n        // console.log();\n        let value = e.target.value\n        let reg = [\n            /^[a-z0-9]{5,7}$/i,\n            /[A-Z]/, /[\\d]/\n        ]\n        let state = reg.every(v=>v.test(value))\n        console.log(state?'正确':'错误');\n    })\n```\n\n## 禁止贪婪\n\n1. `{2,}?` 限制贪婪\n2. `*?` 禁止贪婪\n\n```html\n<body>\n    <main>\n        <span>u.mr90.top1</span>\n        <span>u.mr90.top2</span>\n        <span>u.mr90.top3</span>\n    </main>\n</body>\n<script>\n    let main = document.querySelector('main')\n    let reg = /<span>([^]+?)<\\/span>/g // ?加上问号 并且写到原子组中为了将贪婪的范围缩小到每一行上\n    main.innerHTML = main.innerHTML.replace(reg,(p0,p1)=>{\n        console.log(p0);\n        return `<h2 style=\"color:red\">${p1}</h2>`\n    })\n</script>\n```\n\n## matchAll 全局匹配\n\n```html\n<body>\n    <main>\n        <span>u.mr90.top1</span>\n        <span>u.mr90.top2</span>\n        <span>u.mr90.top3</span>\n    </main>\n</body>\n<script>\n    // 不使用matchAll方法\n    let main = document.querySelector('main')\n    let reg = /<span>([^]+?)<\\/span>/g // ?加上问号 并且写到原子组中为了将贪婪的范围缩小到每一行上\n    let content = [];\n    // main.innerHTML = main.innerHTML.replace(reg,(p0,p1)=>{\n    //     content.push(p1)\n    //     return `<h2 style=\"color:red\">${p1}</h2>`\n    // })\n    // console.table(content)\n\n    // 使用matchAll方法\n    let hd = main.innerHTML.matchAll(reg)\n    // console.log(main.innerHTML.matchAll()); // 遍历迭代\n    for (const i of hd) {\n        content.push(i[1])\n        // console.log(i);\n    }\n    console.table(content);\n</script>\n```\n\n## exec 全局匹配\n\n1. 匹配时 `g`不能缺少\n2. `search` 返回匹配的索引值\n\n```js\n// exec方法 匹配全局\nlet main = document.querySelector('main')\nlet reg = /<span>([^]+?)<\\/span>/g // ?加上问号 并且写到原子组中为了将贪婪的范围缩小到每一行上\nfunction fn(string, reg) {\n    let content = [];\n    while (res = reg.exec(string)) {\n        content.push(res)\n    } return content\n}\nconsole.log(fn(main.innerHTML, reg));\n// exec方法 匹配全局\nlet main = document.querySelector('main')\nlet reg = /<span>([^]+?)<\\/span>/g // ?加上问号 并且写到原子组中为了将贪婪的范围缩小到每一行上\nlet content = [];\nfunction fn(string, reg) {\n    while (res = reg.exec(string)) content.push(res)\n}\nfn(main.innerHTML, reg)\nconsole.log(content);\n```\n\n## $符\n\n1. <code>$`</code> 匹配开头的第一个字符 \n2. `$'` 匹配结尾字符\n3. `$&` 匹配自身\n\n```js\n    // let tel = '2020/12/23'\n    // console.log(tel.replace(/\\//g,'-')); // 2020-12-23\n    // let tel = '(021)9999999 (023)4444444'\n    // console.log(tel.replace(/[(]+(\\d{3})[)](\\d{7})/g,'$1-$2')); //021-9999999 023-4444444\n    let tel = '%Harry='\n    console.log(tel.replace(/\\w+/g,'$`')); // $` 匹配开头的第一个字符 %%=\n    console.log(tel.replace(/\\w+/g,\"$'\")); // $' 匹配结尾字符 %==\n    console.log(tel.replace(/\\w+/g,\"$&\")); // $& 匹配自身\n    console.log(tel.replace(/\\w+/g,\"$`$`$&$'$'\")); // $& 匹配自身\n```\n\n## 原子组的别名\n\n1. 格式 `?<别名>` \n2. 调用 `<别名>`\n\n```html\n<body>\n    <main>\n        <a href=\"http://u.mr90.top\">博客</a>\n        <a href='https://baidu.com'>百度</a>\n        <a href=\"https://github.com\">Github</a>\n    </main>\n</body>\n<script>\n    let main = document.querySelector('main')\n    let reg = /<a.*?href=(['\"])(?<link>.*?)\\1>(?<title>.*?)<\\/a>/gi\n    // 进行迭代遍历\n    for (const i of main.innerHTML.matchAll(reg)) {\n        // console.log(i);\n        console.table(i.groups)\n    }\n</script>\n```\n\n## 断言匹配 ?=\n\n1. `(?=)` 表示在之前条件的后面满足该断言匹配的内容\n2. `(?<=)` 表示前面是条件的匹配内容\n3. `(?!)` 表示后面不是某个条件的内容\n4. `(?<!)` 表示前面不是某个条件的内容\n\n```html\n<body>\n    <main>\n        <a href=\"http://u.mr90.top\">博客</a>\n        <a href='https://baidu.com'>百度</a>\n        <a href=\"https://github.com\">Github</a>\n    </main>\n</body>\n<script>\n    let main = document.querySelector('main')\n    let reg = /(?<=href=(['\"]))(.*?)(?=\\1>)/gi\n    main.innerHTML = main.innerHTML.replace(reg,'https://mr90.top')\n</script>\n```\n\n### 手机号码断言隐藏\n\n```js\nlet users = `\n李四：12323212232\n张三：12322131122\n`\nlet reg = /(?<=\\d{7})\\d{4}/gi\nconsole.log(users.replace(reg,'*'.repeat(4)));\n```","categories":["web","Javascript"]},{"title":"ES6-基础知识","url":"/posts/12627/","content":"\n## let 和 const命令 ✔\n\n> 在ES6中, 我们通常使用 `let` 表示**变量**, `const` 表示**常量**, 并且 `let` 和 `const` 都是**块级作用域**, 且在**当前作用域有效**不能重复声明.\n\n### let 命令\n\n1. `let` 命令的用法和 `var` 相似, 但是 `let` 只在所在代码块内有效.  \n* 基础用法:\n\n```js\n{\n  let a = 1;\n  let b = 2;\n}\n```\n\n2. 并且 `let` 有以下特点:  \n* 不存在变量提升:\n在ES6之前, 我们 `var` 声明一个**变量**一个**函数**, 都会伴随着变量提升的问题, 导致实际开发过程经常出现一些逻辑上的疑惑, 按照一般思维习惯, 变量都是需要先声明后使用.\n\n```js\n// var \nconsole.log(v1); // undefined\nvar v1 = 2;\n// 由于变量提升 代码实际如下\nvar v1;\nconsole.log(v1)\nv1 = 2;\n// let \nconsole.log(v2); // ReferenceError\nlet v2 = 2;\n```\n\n* 不允许重复声明:\n`let` 和 `const` 在**相同作用域下**, 都**不能重复声明同一变量**, 并且**不能在函数内重新声明参数**.\n\n```js\n// 1. 不能重复声明同一变量\n// 报错\nfunction f1() {\n  let a = 1;\n  var a = 2;\n}\n// 报错\nfunction f2() {\n  let a = 1;\n  let a = 2;\n}\n\n// 2. 不能在函数内重新声明参数\n// 报错\nfunction f3(a1) {\n  let a1;\n}\n// 不报错\nfunction f4(a2) {\n  {\n    let a2\n  }\n}\n```\n\n### const 命令\n\n`const` 声明一个**只读**的**常量**.  \n* 基础用法:  \n\n```js\nconst PI = 3.1415926;\nconsole.log(PI); // 3.1415926\n```\n\n`注意点` :    \n* `const` 声明后, 无法修改值; \n\n```js\nconst PI = 3.1415926;\nPI = 3;\n// TypeError: Assignment to constant variable.\n```\n\n* `const` 声明时, 必须赋值; \n\n```js\nconst a;\n// SyntaxError: Missing initializer in const declaration.\n```\n\n* `const` 声明的常量, `let` 不能重复声明; \n\n```js\nconst PI = 3.1415926;\nlet PI = 0;\n// Uncaught SyntaxError: Identifier 'PI' has already been declared\n```\n\n## 变量的解构赋值 ✔\n\n* 解构赋值概念: 在ES6中, 直接从数组和对象中取值, 按照对应位置, 赋值给变量的操作.  \n\n### 数组  \n\n* 基础用法:\n\n```js\n// ES6 之前\nlet a = 1;\nlet b = 2;\n\n// ES6 之后\nlet [a, b] = [1, 2];\n```\n\n* 本质上, 只要等号两边模式一致, 左边变量即可获取右边对应位置的值, 更多用法:  \n\n```js\nlet [a, [\n  [b], c\n]] = [1, [\n  [2], 3\n]];\nconsole.log(a, b, c); // 1, 2, 3\n\nlet [, , c] = [1, 2, 3];\nconsole.log(c); // 3\n\nlet [a, , c] = [1, 2, 3];\nconsole.log(a, c); // 1, 3\n\nlet [a, ...b] = [1, 2, 3];\nconsole.log(a, b); // 1, [2,3]\n\nlet [a, b, ..c.] = [1];\nconsole.log(a, b, c); // 1, undefined, []\n```\n\n`注意点` :    \n* 如果解构不成功, 变量的值就等于`undefined`.    \n\n```js\nlet [a] = []; // a => undefined\nlet [a1, b1] = [1]; // a1 => 1 , b1 => undefined\n```\n\n* 当右边模式多于左边, 也可以解构成功.  \n\n```js\nlet [a, b] = [1, 2, 3];\nconsole.log(a, b); // 1, 2\n```\n\n* 两边模式不同, 报错.  \n\n```js\nlet [a] = 1;\nlet [a] = false;\nlet [a] = NaN;\nlet [a] = undefined;\nlet [a] = null;\nlet [a] = {};\n```\n\n* 指定解构的默认值:  \n* 基础用法:  \n\n```js\nlet [a = 1] = []; // a => 1\nlet [a, b = 2] = [a]; // a => 1 , b => 2\n```\n\n* 特殊情况:  \n\n```js\nlet [a = 1] = [undefined]; // a => 1\nlet [a = 1] = [null]; // a => null\n```\n\n* 右边模式对应的值, 必须严格等于`undefined`, 默认值才能生效, 而`null`不严格等于`undefined`.  \n\n### 对象的解构赋值\n\n> 与数组解构不同的是, 对象解构**不需要严格按照顺序取值**, 而只要按照**变量名**去取对应**属性名**的值, 若取不到对应**属性名**的值, 则为 `undefined`\n\n* 基础用法:\n\n```js\nlet {\n  a,\n  b\n} = {\n  a: 1,\n  b: 2\n}; // a => 1 , b => 2\nlet {\n  a,\n  b\n} = {\n  a: 2,\n  b: 1\n}; // a => 2 , b => 1\nlet {\n  a\n} = {\n  a: 3,\n  b: 2,\n  c: 1\n}; // a => 3\nlet {\n  a\n} = {\n  b: 2,\n  c: 1\n}; // a => undefined\n```\n\n`注意点` :\n* 若**变量名**和**属性名**不一致, 则需要修改名称.\n\n```js\nlet {\n  a: b\n} = {\n  a: 1,\n  c: 2\n};\n// error: a is not defined\n// b => 1\n```\n\n对象的解构赋值的内部机制, 是先找到同名属性, 然后再赋给对应的变量. 真正被赋值的是后者, 而不是前者.  \n上面代码中, `a` 是匹配的模式, `b` 才是变量. 真正被赋值的是变量 `b` , 而不是模式 `a` .  \n\n* 对象解构也支持**嵌套解构**.\n\n```js\nlet obj = {\n  a: [1, {\n    b: 2\n  }]\n};\nlet {\n  a,\n  a: [c, {\n    b\n  }]\n} = obj;\n// a=>[1, {b: 2}], b => 2, c => 1\n```\n\n**指定解构的默认值**: \n\n```js\nlet {\n  a = 1\n} = {}; // a => 1\nlet {\n  a,\n  b = 1\n} = {\n  a: 2\n}; // a => 2, b => 1\n\nlet {\n  a: b = 3\n} = {}; // b => 3\nlet {\n  a: b = 3\n} = {\n  a: 4\n}; // b = >4\n// a是模式，b是变量 牢记\n\nlet {\n  a = 1\n} = {\n  a: undefined\n}; // a => 1\nlet {\n  a = 1\n} = {\n  a: null\n}; // a => null\n// 因为null与undefined不严格相等，所以赋值有效\n// 导致默认值1不会生效。\n```\n\n### 字符串的解构赋值\n\n字符串的解构赋值中, 字符串被转换成了一个**类似数组的对象**. \n* 基础用法: \n\n```js\nconst [a, b, c, d, e] = 'hello';\na // \"h\"\nb // \"e\"\nc // \"l\"\nd // \"l\"\ne // \"o\"\n\nlet {\n  length: len\n} = 'hello'; // len => 5\n```\n\n### 数值和布尔值的解构赋值\n\n> 解构赋值的规则是, **只要等号右边的值不是对象或数组, 就先将其转为对象**. 由于 `undefined` 和 `null` **无法转为对象**, 所以对它们进行解构赋值, 都会报错.\n\n```js\n// 数值和布尔值的包装对象都有toString属性\nlet {\n  toString: s\n} = 123;\ns === Number.prototype.toString // true\nlet {\n  toString: s\n} = true;\ns === Boolean.prototype.toString // true\n\nlet {\n  prop: x\n} = undefined; // TypeError\nlet {\n  prop: y\n} = null; // TypeError\n// undefined和null无法转换为对象\n```\n\n### 函数参数的解构赋值\n\n* 基础用法:\n\n```js\nfunction fun([a, b]) {\n  return a + b;\n}\nfun([1, 2]); // 3\n```\n\n* 默认值函解构情况\n\n```js\nfunction fun({\n  a = 0,\n  b = 0\n} = {}) {\n  return [a, b];\n}\nfun({\n  a: 1,\n  b: 2\n}); // [1, 2]\nfun({\n  a: 1\n}); // [1, 0]\nfun({}); // [0, 0]\nfun(); // [0, 0]\n\nfunction fun({\n  a,\n  b\n} = {\n  a: 0,\n  b: 0\n}) {\n  return [a, b];\n}\nfun({\n  a: 1,\n  b: 2\n}); // [1, 2]\nfun({\n  a: 1\n}); // [1, undefined]\nfun({}); // [undefined, undefined]\nfun(); // [0, 0]\n```\n\n### 应用\n\n* 交换变量的值: \n\n```js\nlet a = 1,\n  b = 2;\n[a, b] = [b, a]; // a =>2 , b => 1 \n```\n\n* 函数返回多个值: \n\n```js\n// 返回一个数组\nfunction f() {\n  return [1, 2, 3];\n}\nlet [a, b, c] = f(); // a=>1, b=>2, c=>3\n\n// 返回一个对象\nfunction f() {\n  return {\n    a: 1,\n    b: 2\n  };\n}\nlet {\n  a,\n  b\n} = f(); // a=>1, b=>2\n```\n\n* 快速对应参数: \n快速的将一组参数与变量名对应. \n\n```js\nfunction f([a, b, c]) {\n  ...\n}\nf([1, 2, 3]);\n\nfunction f({\n  a,\n  b,\n  c\n}) {\n  ...\n}\nf({\n  b: 2,\n  c: 3,\n  a: 1\n});\n```\n\n* 提取JSON数据: \n\n```js\nlet json = {\n  name: 'leo',\n  age: 18\n}\nlet {\n  name,\n  age\n} = json;\nconsole.log(name, age); // leo, 18\n```\n\n* 遍历Map结构: \n\n```js\nconst m = new Map();\nm.set('a', 1);\nm.set('b', 2);\nfor (let [k, v] of m) {\n  console.log(k + ' : ' + v);\n}\n// 获取键名\nfor (let [k] of m) {\n  ...\n}\n// 获取键值\nfor (let [, k] of m) {\n  ...\n}\n```\n\n* 输入模块的指定方法: \n用于**按需加载**模块中需要用到的方法. \n\n```js\nconst {\n  log,\n  sin,\n  cos\n} = require('math');\n```\n\n## 字符串的拓展 ✔\n\n### includes(), startsWith(), endsWith()\n1. 在我们判断字符串是否包含另一个字符串时，ES6之前，我们只有`typeof`方法，ES6之后我们又多了三种方法：   \n* includes()**: 返回**布尔值**, 表示**是否找到参数字符串**. \n* startsWith()**: 返回**布尔值**, 表示参数字符串是否在原字符串的**头部**. \n* endsWith()**: 返回**布尔值**, 表示参数字符串是否在原字符串的**尾部**. \n\n```js\nlet a = 'hello leo';\na.startsWith('leo'); // false\na.endsWith('o'); // true\na.includes('lo'); // true\n```\n\n2. 并且这三个方法都支持第二个参数，表示起始搜索的位置。  \n\n```js\nlet a = 'hello leo';\na.startsWith('leo', 1); // false\na.endsWith('o', 5); // true\na.includes('lo', 6); // false\n```\n\n3. `endsWith` 是针对前 `n` 个字符, 而其他两个是针对从第`n`个位置直到结束.  \n\n### repeat()\n\n1. `repeat` 方法返回一个新字符串，表示将原字符串重复 `n` 次。    \n* 基础用法:\n\n```js\n'ab'.repeat(3); // 'ababab'\n'ab'.repeat(0); // ''\n```\n\n* 特殊用法:\n* 参数为`小数`, 则取整向下取整\n\n```js\n'ab'.repeat(2.3); // 'abab'\n```\n\n* 参数为`负数`或`Infinity`, 则报错  \n\n```js\n'ab'.repeat(-1); // RangeError\n'ab'.repeat(Infinity); // RangeError\n```\n\n* 参数为`0到-1的小数`或`NaN`, 则取0  \n\n```js\n'ab'.repeat(-0.5); // ''\n'ab'.repeat(NaN); // ''\n```\n\n* 参数为`字符串`, 则转成`数字`  \n\n```js\n'ab'.repeat('ab'); // ''\n'ab'.repeat('3'); // 'ababab'\n```\n\n### padStart(), padEnd()  补全字符串大小(从头尾补充)\n\n* 用于将字符串**头部**或**尾部**补全长度, `padStart()`为**头部补全**, `padEnd()`为**尾部补全**.    \n* 这两个方法接收**2个**参数, 第一个指定**字符串最小长度**, 第二个**用于补全的字符串**.  \n* 基础用法 :  \n\n```js\n'x'.padStart(5, 'ab'); // 'ababx'\n'x'.padEnd(5, 'ab'); // 'xabab'\n```\n\n* 特殊用法:  \n* 原字符串长度, 大于或等于指定最小长度, 则返回原字符串.  \n\n```js\n'xyzabc'.padStart(5, 'ab'); // 'xyzabc'\n```\n\n* 用来补全的字符串长度和原字符串长度之和, 超过指定最小长度, 则截去超出部分的补全字符串.  \n\n```js\n'ab'.padStart(5, '012345'); // \"012ab\"\n```\n\n* 省略第二个参数, 则用`空格`补全.  \n\n```js\n'x'.padStart(4); // '    x'\n'x'.padEnd(4); // 'x    '\n```\n\n### 模版字符串\n\n* 用于拼接字符串, ES6之前:  \n\n```js\nlet a = 'abc' +\n  'def' +\n  'ghi';\n```\n\nES6之后:  \n\n```js\nlet a = `\n    abc\n    def\n    ghi\n`\n```\n\n* 拼接变量:\n1. 在**反引号(\\`)**中使用`${}`包裹变量或方法。  \n\n```js\n// ES6之前\nlet a = 'abc' + v1 + 'def';\n\n// ES6之后\nlet a = `abc${v1}def`\n```\n\n## 正则的拓展 ✔\n\n### 介绍\n1. 在ES5中有两种情况。   \n* 参数是**字符串**, 则第二个参数为正则表达式的修饰符.  \n\n```js\nlet a = new RegExp('abc', 'i');\n// 等价于\nlet a = /abx/i;\n```\n\n* 参数是**正则表达式**, 返回一个原表达式的拷贝, 且不能有第二个参数, 否则报错.   \n\n```js\nlet a = new RegExp(/abc/i);\n//等价于\nlet a = /abx/i;\n\nlet a = new RegExp(/abc/, 'i');\n//  Uncaught TypeError\n```\n\n2. ES6中使用：  \n* 第一个参数是正则对象, 第二个是指定修饰符, 如果第一个参数已经有修饰符, 则会被第二个参数覆盖.   \n\n```js\nnew RegExp(/abc/ig, 'i');\n```\n\n### 字符串的正则方法\n\n* 常用的四种方法:`match()`、`replace()`、`search()`和`split()`.   \n\n### u修饰符\n\n1. 添加`u`修饰符，是为了处理大于`uFFFF`的Unicode字符，即正确处理四个字节的`UTF-16`编码。   \n\n```js\n/^\\uD83D/u.test('\\uD83D\\uDC2A'); // false\n/^\\uD83D/.test('\\uD83D\\uDC2A'); // true\n```\n\n* 由于ES5之前不支持四个字节UTF-16编码, 会识别为两个字符, 导致第二行输出`true`, 加入`u`修饰符后ES6就会识别为一个字符, 所以输出`false`.   \n `注意`\n\n2. 加上`u`修饰符后，会改变下面正则表达式的行为：   \n* (1)点字符\n* 点字符(`.`)在正则中表示除了**换行符**以外的任意单个字符. 对于码点大于`0xFFFF`的Unicode字符, 点字符不能识别, 必须加上`u`修饰符.   \n\n```js\nvar a = \"𠮷\";\n/^.$/.test(a); // false\n/^.$/u.test(a); // true\n```\n\n* (2)Unicode字符表示法\n* 使用ES6新增的大括号表示Unicode字符时, 必须在表达式添加`u`修饰符, 才能识别大括号.   \n\n```js\n/\\u{61}/.test('a'); // false\n/\\u{61}/u.test('a'); // true\n/\\u{20BB7}/u.test('𠮷'); // true\n```\n\n* (3)量词\n* 使用`u`修饰符后, 所有量词都会正确识别码点大于`0xFFFF`的 Unicode 字符.\n\n```js\n/a{2}/.test('aa'); // true\n/a{2}/u.test('aa'); // true\n/𠮷{2}/.test('𠮷𠮷'); // false\n/𠮷{2}/u.test('𠮷𠮷'); // true\n```\n\n* (4)i修饰符\n不加 `u` 修饰符, 就无法识别非规范的 `K` 字符.  \n\n```js\n/[a-z]/i.test('\\u212A') // false\n  /\n  [a - z] / iu.test('\\u212A') // true\n```\n\n* 检查是否设置`u`修饰符:\n使用 `unicode` 属性.   \n\n```js\nconst a = /hello/;\nconst b = /hello/u;\n\na.unicode // false\nb.unicode // true\n```\n\n### y修饰符\n\n* `y`修饰符与`g`修饰符类似, 也是全局匹配, 后一次匹配都是从上一次匹配成功的下一个位置开始. 区别在于, `g`修饰符**只要**剩余位置中存在匹配即可, 而`y`修饰符是必须从**剩余第一个**开始.   \n\n```js\nvar s = 'aaa_aa_a';\nvar r1 = /a+/g;\nvar r2 = /a+/y;\n\nr1.exec(s) // [\"aaa\"]\nr2.exec(s) // [\"aaa\"]\n\nr1.exec(s) // [\"aa\"]  剩余 '_aa_a'\nr2.exec(s) // null\n```\n\n* `lastIndex`属性:\n指定匹配的开始位置:   \n\n```js\nconst a = /a/y;\na.lastIndex = 2; // 从2号位置开始匹配\na.exec('wahaha'); // null\na.lastIndex = 3; // 从3号位置开始匹配\nlet c = a.exec('wahaha');\nc.index; // 3\na.lastIndex; // 4\n```\n\n* 返回多个匹配:  \n1. 一个`y`修饰符对`match`方法只能返回第一个匹配，与`g`修饰符搭配能返回所有匹配。   \n\n```js\n'a1a2a3'.match(/a\\d/y); // [\"a1\"]\n'a1a2a3'.match(/a\\d/gy); // [\"a1\", \"a2\", \"a3\"]\n```\n\n* 检查是否使用`y`修饰符:   \n1. 使用`sticky`属性检查。   \n\n```js\nconst a = /hello\\d/y;\na.sticky; // true\n```\n\n### flags属性\n\n* `flags`属性返回所有正则表达式的修饰符.   \n\n```js\n/abc/ig.flags; // 'gi'\n```\n\n## 数值的拓展 ✔\n\n### Number.isFinite(), Number.isNaN()\n1. `Number.isFinite()` 用于检查一个数值是否是有限的, 即不是`Infinity`, 若参数不是`Number`类型, 则一律返回`false` .    \n\n```js\nNumber.isFinite(10); // true\nNumber.isFinite(0.5); // true\nNumber.isFinite(NaN); // false\nNumber.isFinite(Infinity); // false\nNumber.isFinite(-Infinity); // false\nNumber.isFinite('leo'); // false\nNumber.isFinite('15'); // false\nNumber.isFinite(true); // false\nNumber.isFinite(Math.random()); // true\n```\n\n2. `Number.isNaN()`用于检查是否是`NaN`，若参数不是`NaN`，则一律返回`false`。  \n\n```js\nNumber.isNaN(NaN); // true\nNumber.isNaN(10); // false\nNumber.isNaN('10'); // false\nNumber.isNaN(true); // false\nNumber.isNaN(5 / NaN); // true\nNumber.isNaN('true' / 0); // true\nNumber.isNaN('true' / 'true'); // true\n```\n\n* 区别:  \n1. 与传统全局的`isFinite()`和`isNaN()`方法的区别，传统的这两个方法，是先将参数转换成**数值**，再判断。\n2. 而ES6新增的这两个方法则只对**数值**有效，  \n3. `Number.isFinite()`对于**非数值**一律返回`false`,`Number.isNaN()`只有对于`NaN`才返回`true`，其他一律返回`false`。  \n\n```js\nisFinite(25); // true\nisFinite(\"25\"); // true\nNumber.isFinite(25); // true\nNumber.isFinite(\"25\"); // false\n\nisNaN(NaN); // true\nisNaN(\"NaN\"); // true\nNumber.isNaN(NaN); // true\nNumber.isNaN(\"NaN\"); // false\n```\n\n### Number.parseInt(), Number.parseFloat()\n\n1. 这两个方法与全局方法`parseInt()`和`parseFloat()`一致，目的是逐步**减少全局性的方法**，让**语言更模块化**。    \n\n```js\nparseInt('12.34'); // 12\nparseFloat('123.45#'); // 123.45\n\nNumber.parseInt('12.34'); // 12\nNumber.parseFloat('123.45#'); // 123.45\n\nNumber.parseInt === parseInt; // true\nNumber.parseFloat === parseFloat; // true\n```\n\n### Number.isInteger() \n\n* 用来判断一个数值是否是整数, 若参数不是数值, 则返回`false`.    \n\n```js\nNumber.isInteger(10); // true\nNumber.isInteger(10.0); // true\nNumber.isInteger(10.1); // false\n```\n\n### Math对象的拓展\n\n* ES6新增`17`个数学相关的**静态方法**, 只能在**Math对象**上调用.  \n\n#### Math.trunc():  \n\n* 用来去除小数的小数部分, **返回整数部分**.  \n* 若参数为**非数值**, 则**先转为数值**.  \n* 若参数为**空值**或**无法截取整数的值**, 则返回**NaN**.  \n\n```js\n// 正常使用\nMath.trunc(1.1); // 1\nMath.trunc(1.9); // 1\nMath.trunc(-1.1); // -1\nMath.trunc(-1.9); // -1\nMath.trunc(-0.1234); // -0\n\n// 参数为非数值\nMath.trunc('11.22'); // 11\nMath.trunc(true); // 1\nMath.trunc(false); // 0\nMath.trunc(null); // 0\n\n// 参数为空和无法取整\nMath.trunc(NaN); // NaN\nMath.trunc('leo'); // NaN\nMath.trunc(); // NaN\nMath.trunc(undefined); // NaN\n```\n\n* ES5实现:   \n\n```js\nMath.trunc = Math.trunc || function(x) {\n  return x < 0 ? Math.ceil(x) : Math.floor(x);\n}\n```\n\n#### Math.sign():  \n\n* 判断一个数是**正数**、**负数**还**是零**, 对于非数值, 会先转成**数值**.    \n* 返回值:   \n1. 参数为正数， 返回 +1\n2. 参数为负数， 返回 -1\n3. 参数为0， 返回 0\n4. 参数为-0， 返回 -0\n5. 参数为其他值， 返回 NaN\n\n```js\nMath.sign(-1); // -1\nMath.sign(1); // +1\nMath.sign(0); // 0\nMath.sign(-0); // -0\nMath.sign(NaN); // NaN\n\nMath.sign(''); // 0\nMath.sign(true); // +1\nMath.sign(false); // 0\nMath.sign(null); // 0\nMath.sign('9'); // +1\nMath.sign('leo'); // NaN\nMath.sign(); // NaN\nMath.sign(undefined); // NaN\n```\n\n* ES5实现  \n\n```js\nMath.sign = Math.sign || function(x) {\n  x = +x;\n  if (x === 0 || isNaN(x)) {\n    return x;\n  }\n  return x > 0 ? 1 : -1;\n}\n```\n\n#### Math.cbrt():  \n\n* 用来计算一个数的立方根, 若参数为非数值则先转成数值.   \n\n```js\nMath.cbrt(-1); // -1\nMath.cbrt(0); // 0\nMath.cbrt(1); // 1\nMath.cbrt(2); // 1.2599210498\n\nMath.cbrt('1'); // 1\nMath.cbrt('leo'); // NaN\n```\n\n* ES5实现  \n\n```js\nMath.cbrt = Math.cbrt || function(x) {\n  var a = Math.pow(Math.abs(x), 1 / 3);\n  return x < 0 ? -y : y;\n}\n```\n\n#### Math.clz32():  \n\n* 用于返回一个数的 32 位无符号整数形式有多少个前导 0.    \n\n```js\nMath.clz32(0) // 32\nMath.clz32(1) // 31\nMath.clz32(1000) // 22\nMath.clz32(0b01000000000000000000000000000000) // 1\nMath.clz32(0b00100000000000000000000000000000) // 2\n```\n\n#### Math.imul():  \n\n* 用于返回两个数以 32 位带符号整数形式相乘的结果, 返回的也是一个 32 位的带符号整数.    \n\n```js\nMath.imul(2, 4) // 8\nMath.imul(-1, 8) // -8\nMath.imul(-2, -2) // 4\n```\n\n#### Math.fround():  \n\n* 用来返回一个数的**2位单精度浮点数**形式.  \n\n```js\nMath.fround(0) // 0\nMath.fround(1) // 1\nMath.fround(2 ** 24 - 1) // 16777215\n```\n\n#### Math.hypot():   \n\n* 用来返回所有参数的平方和的**平方根**.  \n\n```js\nMath.hypot(3, 4); // 5\nMath.hypot(3, 4, 5); // 7.0710678118654755\nMath.hypot(); // 0\nMath.hypot(NaN); // NaN\nMath.hypot(3, 4, 'foo'); // NaN\nMath.hypot(3, 4, '5'); // 7.0710678118654755\nMath.hypot(-3); // 3\n```\n\n#### Math.expm1():  \n\n* 用来返回` e^x - 1`, 即`Math.exp(x) - 1`.  \n\n```js\nMath.expm1(-1) // -0.6321205588285577\nMath.expm1(0) // 0\nMath.expm1(1) // 1.718281828459045\n```\n\n* ES5实现  \n\n```js\nMath.expm1 = Math.expm1 || function(x) {\n  return Math.exp(x) - 1;\n};\n```\n\n#### Math.log1p():  \n\n* 用来返回`1 + x`的自然对数, 即`Math.log(1 + x)`. 如果x小于`-1`, 返回`NaN`.  \n\n```js\nMath.log1p(1) // 0.6931471805599453\nMath.log1p(0) // 0\nMath.log1p(-1) // -Infinity\nMath.log1p(-2) // NaN\n```\n\n* ES5实现  \n\n```js\nMath.log1p = Math.log1p || function(x) {\n  return Math.log(1 + x);\n};\n```\n\n#### Math.log10():  \n\n* 用来返回以 `10 `为底的`x的对数`. 如果x小于 0, 则返回 `NaN`.  \n\n```js\nMath.log10(2) // 0.3010299956639812\nMath.log10(1) // 0\nMath.log10(0) // -Infinity\nMath.log10(-2) // NaN\nMath.log10(100000) // 5\n```\n\n* ES5实现  \n\n```js\nMath.log10 = Math.log10 || function(x) {\n  return Math.log(x) / Math.LN10;\n};\n```\n\n#### Math.log2():  \n\n* 用来返回以 `2` 为底的`x的对数`. 如果`x`小于` 0`, 则返回 `NaN`.   \n\n```js\nMath.log2(3) // 1.584962500721156\nMath.log2(2) // 1\nMath.log2(1) // 0\nMath.log2(0) // -Infinity\nMath.log2(-2) // NaN\nMath.log2(1024) // 10\nMath.log2(1 << 29) // 29\n```\n\n* ES5实现  \n\n```js\nMath.log2 = Math.log2 || function(x) {\n  return Math.log(x) / Math.LN2;\n};\n```\n\n#### 双曲函数方法:  \n\n    - `Math.sinh(x)` 返回x的**双曲正弦**（hyperbolic sine）  \n    - `Math.cosh(x)` 返回x的**双曲余弦**（hyperbolic cosine）  \n    - `Math.tanh(x)` 返回x的**双曲正切**（hyperbolic tangent）  \n    - `Math.asinh(x)` 返回x的**反双曲正弦**（inverse hyperbolic sine）  \n    - `Math.acosh(x)` 返回x的**反双曲余弦**（inverse hyperbolic cosine）  \n    - `Math.atanh(x)` 返回x的**反双曲正切**（inverse hyperbolic tangent）  \n\n### 指数运算符\n\n* 新增的指数运算符(`**`):  \n\n```js\n2 ** 2; // 4\n2 ** 3; // 8 \n\n2 ** 3 ** 2; // 相当于 2 ** (3 ** 2); 返回 512\n```\n\n* 指数运算符(`**`)与`Math.pow`的实现不相同, 对于特别大的运算结果, 两者会有细微的差异.\n\n```js\nMath.pow(99, 99)\n// 3.697296376497263e+197\n\n99 ** 99\n// 3.697296376497268e+197\n```\n\n## 函数的拓展 ✔\n\n### 参数默认值\n\n```js\n// ES6 之前\nfunction f(a, b) {\n  b = b || 'leo';\n  console.log(a, b);\n}\n\n// ES6 之后\nfunction f(a, b = 'leo') {\n  console.log(a, b);\n}\n\nf('hi'); // hi leo\nf('hi', 'jack'); // hi jack\nf('hi', ''); // hi leo\n```\n\n`注意` :  \n* 参数变量是默认声明的, 不能用`let`和`const`再次声明:    \n\n```js\nfunction f(a = 1) {\n  let a = 2; // error\n}\n```\n\n* 使用参数默认值时, 参数名不能相同:  \n\n```js\nfunction f(a, a, b) {\n  ...\n}; // 不报错\nfunction f(a, a, b = 1) {\n  ...\n}; // 报错\n```\n\n* 与解构赋值默认值结合使用:  \n\n```js\nfunction f({\n  a,\n  b = 1\n}) {\n  console.log(a, b)\n};\nf({}); // undefined 1\nf({\n  a: 2\n}); // 2 1\nf({\n  a: 2,\n  b: 3\n}); // 2 3\nf(); // 报错\n\nfunction f({\n  a,\n  b = 1\n} = {}) {\n  console.log(a, b)\n}\nf(); // undefined 1\n```\n\n* 尾参数定义默认值:   \n通常在尾参数定义默认值, 便于观察参数, 并且非尾参数无法省略. \n\n```js\nfunction f(a = 1, b) {\n  return [a, b];\n}\nf(); // [1, undefined]\nf(2); // [2, undefined]\nf(, 2); // 报错\n\nf(undefined, 2); // [1, 2]\n\nfunction f(a, b = 1, c) {\n  return [a, b, c];\n}\nf(); // [undefined, 1, undefined]\nf(1); // [1,1,undefined]\nf(1, , 2); // 报错\nf(1, undefined, 2); // [1,1,2]\n```\n\n在给参数传递默认值时, 传入 `undefined` 会触发默认值, 传入 `null` 不会触发.\n\n```js\nfunction f(a = 1, b = 2) {\n  console.log(a, b);\n}\nf(undefined, null); // 1 null\n```\n\n* 函数的length属性:  \n`length` 属性将返回, 没有指定默认值的参数数量, 并且rest参数不计入 `length` 属性.    \n\n```js\nfunction f1(a) {\n  ...\n};\n\nfunction f2(a = 1) {\n  ...\n};\n\nfunction f3(a, b = 2) {\n  ...\n};\n\nfunction f4(...a) {\n  ...\n};\n\nfunction f5(a, b, ...c) {\n  ...\n};\n\nf1.length; // 1\nf2.length; // 0\nf3.length; // 1\nf4.length; // 0\nf5.length; // 2\n```\n\n### rest 参数\n\n* `rest`参数形式为(`... 变量名`), 其值为一个数组, 用于获取函数多余参数.  \n\n```js\nfunction f(a, ...b) {\n  console.log(a, b);\n}\nf(1, 2, 3, 4); // 1 [2, 3, 4]\n```\n\n`注意` :  \n* `rest`参数只能放在最后一个, 否则报错:  \n\n```js\nfunction f(a, ...b, c) {\n  ...\n}; // 报错 \n```\n\n* 函数的`length`属性不包含`rest`参数.\n\n```js\nfunction f1(a) {\n  ...\n};\n\nfunction f2(a, ...b) {\n  ...\n};\nf1(1); // 1\nf2(1, 2); // 1\n```\n\n### name 属性\n\n用于返回该函数的函数名.  \n\n```js\nfunction f() {\n  ...\n};\nf.name; // f\n\nconst f = function g() {\n  ...\n};\nf.name; // g\n```\n\n### 箭头函数\n\n* 使用\"箭头\"(`=>`)定义函数.  \n* 基础使用:   \n\n```js\n// 有1个参数\nlet f = v => v;\n// 等同于\nlet f = function(v) {\n  return v\n};\n\n// 有多个参数\nlet f = (v, i) => {\n  return v + i\n};\n// 等同于\nlet f = function(v, i) {\n  return v + i\n};\n\n// 没参数\nlet f = () => 1;\n// 等同于\nlet f = function() {\n  return 1\n};\n```\n\n* 箭头函数与变量结构结合使用:  \n\n```js\n// 普通函数写法\nfunction f(p) {\n  return p.a + ':' + p.b;\n}\n\n// 箭头函数写法\nlet f = ({\n  a,\n  b\n}) => a + ':' + b;\n```\n\n* 简化回调函数:  \n\n```js\n// 普通函数写法\n[1, 2, 3].map(function(x) {\n  return x * x;\n})\n\n// 箭头函数写法\n[1, 2, 3].map(x => x * x);\n```\n\n* 箭头函数与rest参数结合:  \n\n```js\nlet f = (...n) => n;\nf(1, 2, 3); // [1, 2, 3]\n```\n\n`注意点` :   \n* 1. 箭头函数内的`this`**总是**指向**定义时所在的对象**, 而不是调用时.  \n* 2. 箭头函数不能当做**构造函数**, 即不能用`new`命令, 否则报错.  \n* 3. 箭头函数不存在`arguments`对象, 即不能使用, 可以使用`rest`参数代替.  \n* 4. 箭头函数不能使用`yield`命令, 即不能用作**Generator**函数.   \n\n* 不适用场景:  \n* 1. 在定义函数方法, 且该方法内部包含`this`.  \n\n```js\nconst obj = {\n  a: 9,\n  b: () => {\n    this.a--;\n  }\n}\n```\n\n上述 `b` 如果是**普通函数**, 函数内部的 `this` 指向 `obj` , 但是如果是箭头函数, 则 `this` 会指向**全局**, 不是预期结果.  \n\n* 2. 需要动态`this`时.\n\n```js\nlet b = document.getElementById('myID');\nb.addEventListener('click', () => {\n  this.classList.toggle('on');\n})\n```\n\n上述按钮点击会报错, 因为 `b` 监听的箭头函数中, `this` 是全局对象, 若改成**普通函数**, `this` 就会指向被点击的按钮对象.  \n\n### 双冒号运算符\n\n* 双冒号暂时是一个提案, 用于解决一些不适用的场合, 取代`call`、`apply`、`bind`调用.    \n* 双冒号运算符(`::`)的左边是一个**对象**, 右边是一个**函数**. 该运算符会自动将左边的对象, 作为上下文环境(即`this`对象), 绑定到右边函数上.  \n\n```js\nf::b;\n// 等同于\nb.bind(f);\n\nf::b(...arguments);\n// 等同于\nb.apply(f, arguments);\n```\n\n* 若双冒号左边为空, 右边是一个对象的方法, 则等于将该方法绑定到该对象上.  \n\n```js\nlet f = a::a.b;\n// 等同于\nlet f = ::a.b;\n```\n\n## 数组的拓展 ✔\n\n### 拓展运算符\n* 拓展运算符使用(`...`), 类似`rest`参数的逆运算, 将数组转为用(`, `)分隔的参数序列.   \n\n```js\nconsole.log(...[1, 2, 3]); // 1 2 3 \nconsole.log(1, ...[2, 3], 4); // 1 2 3 4\n```\n\n* 拓展运算符主要使用在函数调用.  \n\n```js\nfunction f(a, b) {\n  console.log(a, b);\n}\nf(...[1, 2]); // 1 2\n\nfunction g(a, b, c, d, e) {\n  console.log(a, b, c, d, e);\n}\ng(0, ...[1, 2], 3, ...[4]); // 0 1 2 3 4\n```\n\n* 若拓展运算符后面是个空数组, 则不产生效果.  \n\n```js\n[...[], 1]; // [1]\n```\n\n* 替代apply方法 \n\n```js\n// ES6之前\nfunction f(a, b, c) {\n  ...\n};\nvar a = [1, 2, 3];\nf.apply(null, a);\n\n// ES6之后\nfunction f(a, b, c) {\n  ...\n};\nlet a = [1, 2, 3];\nf(...a);\n\n// ES6之前\nMath.max.apply(null, [3, 2, 6]);\n\n// ES6之后\nMath.max(...[3, 2, 6]);\n```\n\n* 拓展运算符的运用\n* (1)复制数组:  \n* `通常`我们直接`复制`数组时, 只是`浅拷贝`, 如果要实现深拷贝, 可以使用拓展运算符.  \n\n```js\n// 通常情况 浅拷贝  浅拷贝 如果后面的赋值发生变化 前面的也会发生变化 浅拷贝只是拷贝了一个地址\nlet a1 = [1, 2];\nlet a2 = a1;\na2[0] = 3;\nconsole.log(a1, a2); // [3,2] [3,2]\n\n// 拓展运算符 深拷贝\nlet a1 = [1, 2];\nlet a2 = [...a1];\n// let [...a2] = a1; // 作用相同\na2[0] = 3;\nconsole.log(a1, a2); // [1,2] [3,2]\n```\n\n* (2)合并数组:  \n* 注意, 这里`合并`数组, 只是`浅拷贝`.  \n\n```js\nlet a1 = [1, 2];\nlet a2 = [3];\nlet a3 = [4, 5];\n\n// ES5 \nlet a4 = a1.concat(a2, a3);\n\n// ES6\nlet a5 = [...a1, ...a2, ...a3];\n\na4[0] === a1[0]; // true\na5[0] === a1[0]; // true\n```\n\n* (3)与解构赋值结合:  \n* 与解构赋值结合生成数组, 但是使用拓展运算符需要放到参数最后一个, 否则报错.   \n\n```js\nlet [a, ...b] = [1, 2, 3, 4];\n// a => 1  b => [2,3,4]\n\nlet [a, ...b] = [];\n// a => undefined b => []\n\nlet [a, ...b] = [\"abc\"];\n// a => \"abc\"  b => []\n```\n\n### Array.from()\n\n* 将 **类(伪)数组对象** 和 **可遍历的对象**, 转换成真正的数组.  \n\n```js\n// 类数组对象\nlet a = {\n  '0': 'a',\n  '1': 'b',\n  length: 2\n}\nlet arr = Array.from(a);\n\n// 可遍历的对象\nlet a = Array.from([1, 2, 3]);\nlet b = Array.from({\n  length: 3\n});\nlet c = Array.from([1, 2, 3]).map(x => x * x);\nlet d = Array.from([1, 2, 3].map(x => x * x));\n```\n\n### Array.of()\n\n* 将一组数值, 转换成**数组**, 弥补`Array`方法参数不同导致的差异.   \n\n```js\nArray.of(1, 2, 3); // [1,2,3]\nArray.of(1).length; // 1\n\nArray(); // []\nArray(2); // [,] 1个参数时，为指定数组长度\nArray(1, 2, 3); // [1,2,3] 多于2个参数，组成新数组\n```\n\n### find()和findIndex()\n\n* `find()`方法用于找出第一个符合条件的数组成员, 参数为一个回调函数, 所有成员依次执行该回调函数, 返回第一个返回值为`true`的成员, 如果没有一个符合则返回`undefined`.  \n\n```js\n[1, 2, 3, 4, 5].find(a => a < 3); // 1\n```\n\n* 回调函数接收三个参数, 当前值、当前位置和原数组.  \n\n```js\n[1, 2, 3, 4, 5].find((value, index, arr) => {\n  // ...\n});\n```\n\n* `findIndex()`方法与`find()`类似, 返回第一个符合条件的数组成员的**位置**, 如果都不符合则返回`-1`.  \n\n```js\n[1, 2, 3, 4].findIndex((v, i, a) => {\n  return v > 2;\n}); // 2\n```\n\n### fill()\n\n* 用于用指定值**填充**一个数组, 通常用来**初始化空数组**, 并抹去数组中已有的元素.   \n\n```js\nnew Array(3).fill('a'); // ['a','a','a']\n[1, 2, 3].fill('a'); // ['a','a','a']\n```\n\n* 并且`fill()`的第二个和第三个参数指定填充的**起始位置**和**结束位置**.   \n\n```js\n[1, 2, 3].fill('a', 1, 2); //  [1, \"a\", 3]\n```\n\n### entries(), keys(), values()\n\n* 主要用于遍历数组, `entries()`对键值对遍历, `keys()`对键名遍历, `values()`对键值遍历.   \n\n```js\nfor (let i of ['a', 'b'].keys()) {\n  console.log(i)\n}\n// 0\n// 1\n\nfor (let e of ['a', 'b'].values()) {\n  console.log(e)\n}\n// 'a'\n// 'b'\n\nfor (let e of ['a', 'b'].entries()) {\n  console.log(e)\n}\n// 0 'a'\n// 1 'b'\n```\n\n### includes()\n\n* 用于表示数组是否包含给定的值, 与字符串的`includes`方法类似.   \n\n```js\n[1, 2, 3].includes(2); // true\n[1, 2, 3].includes(4); // false\n[1, 2, NaN].includes(NaN); // true\n```\n\n* 第二个参数为**起始位置**, 默认为`0`, 如果负数, 则表示倒数的位置, 如果大于数组长度, 则重置为`0`开始.  \n\n```js\n[1, 2, 3].includes(3, 3); // false\n[1, 2, 3].includes(3, 4); // false\n[1, 2, 3].includes(3, -1); // true\n[1, 2, 3].includes(3, -4); // true\n```\n\n### flat(), flatMap()\n\n* `flat()`用于将数组一维化, 返回一个新数组, 不影响原数组.   \n* 默认一次只一维化一层数组, 若需多层, 则传入一个整数参数指定层数.   \n* 若要一维化所有层的数组, 则传入`Infinity`作为参数.  \n\n```js\n[1, 2, [2, 3]].flat(); // [1,2,2,3]\n[1, 2, [3, [4, [5, 6]]]].flat(3); // [1,2,3,4,5,6]\n[1, 2, [3, [4, [5, 6]]]].flat('Infinity'); // [1,2,3,4,5,6]\n```\n\n* `flatMap()`是将原数组每个对象先执行一个函数, 在对返回值组成的数组执行`flat()`方法, 返回一个新数组, 不改变原数组.  \n* `flatMap()`只能展开一层.  \n\n```js\n[2, 3, 4].flatMap((x) => [x, x * 2]);\n// [2, 4, 3, 6, 4, 8] \n```\n\n## 对象的拓展 ✔\n\n### 属性的简洁表示\n\n```js\nlet a = 'a1';\nlet b = {\n  a\n}; // b => { a : 'a1' }\n// 等同于\nlet b = {\n  a: a\n};\n\nfunction f(a, b) {\n  return {\n    a,\n    b\n  };\n}\n// 等同于\nfunction f(a, b) {\n  return {\n    a: a,\n    b: b\n  };\n}\n\nlet a = {\n  fun() {\n    return 'leo';\n  }\n}\n// 等同于\nlet a = {\n  fun: function() {\n    return 'leo';\n  }\n}\n```\n\n### 属性名表达式\n\n`JavaScript` 提供2种方法**定义对象的属性**.  \n\n```js\n// 方法1 标识符作为属性名\na.f = true;\n\n// 方法2 字符串作为属性名\na['f' + 'un'] = true;\n```\n\n延伸出来的还有:   \n\n```js\nlet a = 'hi leo';\nlet b = {\n  [a]: true,\n  ['a' + 'bc']: 123,\n  ['my' + 'fun']() {\n    return 'hi';\n  }\n};\n// b.a => undefined ; b.abc => 123 ; b.myfun() => 'hi'\n// b[a] => true ; b['abc'] => 123 ; b['myfun'] => ƒ ['my' + 'fun'] (){ return 'hi'; }\n```\n\n`注意` :  \n属性名表达式不能与简洁表示法同时使用, 否则报错.   \n\n```js\n// 报错\nlet a1 = 'aa';\nlet a2 = 'bb';\nlet b1 = {\n  [a1]\n};\n\n// 正确\nlet a1 = 'aa';\nlet b1 = {\n  [a1]: 'bb'\n};\n```\n\n### Object.is()\n\n`Object.is()` 用于比较两个值是否严格相等, 在ES5时候只要使用**相等运算符**( `==` )和**严格相等运算符**( `===` )就可以做比较, 但是它们都有缺点, 前者会**自动转换数据类型**, 后者的 `NaN` 不等于自身, 以及 `+0` 等于 `-0` .   \n\n```js\nObject.is('a', 'a'); // true\nObject.is({}, {}); // false\n\n// ES5\n+\n0 === -0; // true\nNaN === NaN; // false\n\n// ES6\nObject.is(+0, -0); // false\nObject.is(NaN, NaN); // true\n```\n\n### Object.assign()\n\n`Object.assign()` 方法用于对象的合并, 将原对象的所有可枚举属性复制到目标对象.  \n* 基础用法:  \n第一个参数是**目标对象**, 后面参数都是**源对象**.  \n\n```js\nlet a = {\n  a: 1\n};\nlet b = {\n  b: 2\n};\nObject.assign(a, b); // a=> {a:1,b:2}\n```\n\n`注意` :  \n* 若目标对象与源对象有同名属性, 则后面属性会覆盖前面属性.  \n\n```js\nlet a = {\n  a: 1,\n  b: 2\n};\nlet b = {\n  b: 3,\n  c: 4\n};\nObject.assign(a, b); // a => {a:1, b:3, c:4}\n```\n\n* 若只有**一个**参数, 则返回该参数. \n\n```js\nlet a = {\n  a: 1\n};\nObject.assign(a) === a; // true\n```\n\n* 若参数**不是对象**, 则先转成对象后返回.\n\n```js\ntypeof Object.assign(2); // 'object'\n```\n\n* 由于`undefined`或`NaN`无法转成对象, 所以做为参数会报错.   \n\n```js\nObject.assign(undefined); // 报错\nObject.assign(NaN); // 报错\n```\n\n* `Object.assign()`实现的是浅拷贝.   \n\n`Object.assign()` 拷贝得到的是这个对象的引用. 这个对象的任何变化, 都会反映到目标对象上面.\n\n```js\nlet a = {\n  a: {\n    b: 1\n  }\n};\nlet b = Object.assign({}, a);\na.a.b = 2;\nconsole.log(b.a.b); // 2\n```\n\n* 将数组当做对象处理, 键名为数组下标, 键值为数组下标对应的值.\n\n```js\nObject.assign([1, 2, 3], [4, 5]); // [4, 5, 3]\n```\n\n## Symbol\n\n### 介绍\nES6引入 `Symbol` 作为一种新的**原始数据类型**, 表示**独一无二**的值, 主要是为了**防止属性名冲突**.   \nES6之后, JavaScript一共有 7 种数据类型: `Symbol` 、 `undefined` 、 `null` 、 `Boolean` 、 `String` 、 `Number` 、 `Object` .  \n简单示例:   \n\n```js\nlet a = Symbol();\ntypeof a; // \"symbol\"\n```\n\n `注意`\n\n* `Symbol`函数不能用`new`, 会报错. 由于`Symbol`是一个原始类型, 不是对象, 所以不能添加属性, 它是类似于字符串的数据类型.   \n* `Symbol`都是不相等的, 即使参数相同.   \n\n```js\n// 没有参数\nlet a1 = Symbol();\nlet a2 = Symbol();\na1 === a2; // false \n\n// 有参数\nlet a1 = Symbol('abc');\nlet a2 = Symbol('abc');\na1 === a2; // false \n```\n\n* `Symbol`不能与其他类型的值计算, 会报错.   \n\n```js\nlet a = Symbol('hello');\na + \" world!\"; // 报错\n`${a} world!`; // 报错\n```\n\nSymbol可以显式转换为字符串:  \n\n```js\nlet a1 = Symbol('hello');\n\nString(a1); // \"Symbol(hello)\"\na1.toString(); // \"Symbol(hello)\"\n```\n\nSymbol可以转换为布尔值, 但不能转为数值:   \n\n```js\nlet a1 = Symbol();\nBoolean(a1);\n!a1; // false\n\nNumber(a1); // TypeError\na1 + 1; // TypeError\n```\n\n### Symbol作为属性名\n\n好处: 防止同名属性, 还有防止键被改写或覆盖.  \n\n```js\nlet a1 = Symbol();\n\n// 写法1\nlet b = {};\nb[a1] = 'hello';\n\n// 写法2\nlet b = {\n  [a1]: 'hello'\n}\n\n// 写法3\nlet b = {};\nObject.defineProperty(b, a1, {\n  value: 'hello'\n});\n\n// 3种写法 结果相同\nb[a1]; // 'hello'\n```\n\n**需要注意:** Symbol作为对象属性名时, 不能用点运算符, 并且必须放在方括号内.   \n\n```js\nlet a = Symbol();\nlet b = {};\n\n// 不能用点运算\nb.a = 'hello';\nb[a]; // undefined\nb['a']; // 'hello'\n\n// 必须放在方括号内\nlet c = {\n  [a]: function(text) {\n    console.log(text);\n  }\n}\nc[a]('leo'); // 'leo'\n\n// 上面等价于 更简洁\nlet c = {\n  [a](text) {\n    console.log(text);\n  }\n}\n```\n\n**常常还用于创建一组常量, 保证所有值不相等:**   \n\n```js\nlet a = {};\na.a1 = {\n  AAA: Symbol('aaa'),\n  BBB: Symbol('bbb'),\n  CCC: Symbol('ccc')\n}\n```\n\n### 应用: 消除魔术字符串\n\n魔术字符串: 指代码中多次出现, 强耦合的字符串或数值, 应该避免, 而使用含义清晰的变量代替.\n\n```js\nfunction f(a) {\n  if (a == 'leo') {\n    console.log('hello');\n  }\n}\nf('leo'); // 'hello' 为魔术字符串\n```\n\n常使用变量, 消除魔术字符串:   \n\n```js\nlet obj = {\n  name: 'leo'\n};\n\nfunction f(a) {\n  if (a == obj.name) {\n    console.log('hello');\n  }\n}\nf(obj.name); // 'hello'\n```\n\n使用Symbol消除强耦合, 使得不需关系具体的值:   \n\n```js\nlet obj = {\n  name: Symbol()\n};\n\nfunction f(a) {\n  if (a == obj.name) {\n    console.log('hello');\n  }\n}\nf(obj.name);\n```\n\n### 属性名遍历\n\nSymbol作为属性名遍历, 不出现在 `for...in` 、 `for...of` 循环, 也不被 `Object.keys()` 、 `Object.getOwnPropertyNames()` 、 `JSON.stringify()` 返回.\n\n```js\nlet a = Symbol('aa'),\n  b = Symbol('bb');\nlet obj = {\n  [a]: '11',\n  [b]: '22'\n}\nfor (let k of Object.values(obj)) {\n  console.log(k)\n}\n// 无输出\n\nlet obj = {};\nlet aa = Symbol('leo');\nObject.defineProperty(obj, aa, {\n  value: 'hi'\n});\n\nfor (let k in obj) {\n  console.log(k); // 无输出\n}\n\nObject.getOwnPropertyNames(obj); // []\nObject.getOwnPropertySymbols(obj); // [Symbol(leo)]\n```\n\n`Object.getOwnPropertySymbols` 方法返回一个数组, 包含当前对象所有用做属性名的Symbol值.   \n\n```js\nlet a = {};\nlet a1 = Symbol('a');\nlet a2 = Symbol('b');\na[a1] = 'hi';\na[a2] = 'oi';\n\nlet obj = Object.getOwnPropertySymbols(a);\nobj; //  [Symbol(a), Symbol(b)]\n```\n\n另外可以使用 `Reflect.ownKeys` 方法可以返回所有类型的键名, 包括常规键名和 Symbol 键名.   \n\n```js\nlet a = {\n  [Symbol('leo')]: 1,\n  aa: 2,\n  bb: 3,\n}\nReflect.ownKeys(a); // ['aa', 'bb',Symbol('leo')]\n```\n\n由于Symbol值作为名称的属性不被常规方法遍历获取, 因此常用于定义对象的一些非私有, 且内部使用的方法.  \n\n### Symbol.for()、Symbol.keyFor()\n\n* Symbol.for()   \n**用于重复使用一个Symbol值**, 接收一个**字符串**作为参数, 若存在用此参数作为名称的Symbol值, 返回这个Symbol, 否则新建并返回以这个参数为名称的Symbol值.  \n\n```js\nlet a = Symbol.for('aaa');\nlet b = Symbol.for('aaa');\n\na === b; // true\n```\n\n`Symbol()` 和 `Symbol.for()` 区别:  \n\n```js\nSymbol.for('aa') === Symbol.for('aa'); // true\nSymbol('aa') === Symbol('aa'); // false\n```\n\n* Symbol.keyFor()   \n**用于返回一个已使用的Symbol类型的key**:  \n\n```js\nlet a = Symbol.for('aa');\nSymbol.keyFor(a); //  'aa'\n\nlet b = Symbol('aa');\nSymbol.keyFor(b); //  undefined\n```\n\n### 内置的Symbol值\n\nES6提供11个内置的Symbol值, 指向语言内部使用的方法:   \n* 1. Symbol.hasInstance**   \n当其他对象使用 `instanceof` 运算符, 判断是否为该对象的实例时, 会调用这个方法. 比如, `foo instanceof Foo` 在语言内部, 实际调用的是 `Foo[Symbol.hasInstance](foo)` .   \n\n```js\nclass P {\n  [Symbol.hasInstance](a) {\n    return a instanceof Array;\n  }\n}\n[1, 2, 3] instanceof new P(); // true\n```\n\nP是一个类, new P()会返回一个实例, 该实例的 `Symbol.hasInstance` 方法, 会在进行 `instanceof` 运算时自动调用, 判断左侧的运算子是否为 `Array` 的实例.   \n\n* 2. Symbol.isConcatSpreadable**   \n值为布尔值, 表示该对象用于 `Array.prototype.concat()` 时, 是否可以展开.    \n\n```js\nlet a = ['aa', 'bb'];\n['cc', 'dd'].concat(a, 'ee');\n// ['cc', 'dd', 'aa', 'bb', 'ee']\na[Symbol.isConcatSpreadable]; // undefined\n\nlet b = ['aa', 'bb'];\nb[Symbol.isConcatSpreadable] = false;\n['cc', 'dd'].concat(b, 'ee');\n// ['cc', 'dd',[ 'aa', 'bb'], 'ee']\n```\n\n* 3. Symbol.species**   \n\n指向一个构造函数, 在创建衍生对象时会使用, 使用时需要用 `get` 取值器.     \n\n```js\nclass P extends Array {\n  static get[Symbol.species]() {\n    return this;\n  }\n}\n```\n\n解决下面问题:   \n\n```js\n// 问题：  b应该是 Array 的实例，实际上是 P 的实例\nclass P extends Array {}\n\nlet a = new P(1, 2, 3);\nlet b = a.map(x => x);\n\nb instanceof Array; // true\nb instanceof P; // true\n\n// 解决：  通过使用 Symbol.species\nclass P extends Array {\n  static get[Symbol.species]() {\n    return Array;\n  }\n}\nlet a = new P();\nlet b = a.map(x => x);\nb instanceof P; // false\nb instanceof Array; // true\n```\n\n* 4. Symbol.match**   \n\n当执行 `str.match(myObject)` , 传入的属性存在时会调用, 并返回该方法的返回值.   \n\n```js\nclass P {\n  [Symbol.match](string) {\n    return 'hello world'.indexOf(string);\n  }\n}\n'h'.match(new P()); // 0\n```\n\n* 5. Symbol.replace**\n\n当该对象被 `String.prototype.replace` 方法调用时, 会返回该方法的返回值.   \n\n```js\nlet a = {};\na[Symbol.replace] = (...s) => console.log(s);\n'Hello'.replace(a, 'World') // [\"Hello\", \"World\"]\n```\n\n* 6. Symbol.search**   \n\n当该对象被 `String.prototype.search` 方法调用时, 会返回该方法的返回值.   \n\n```js\nclass P {\n  constructor(val) {\n      this.val = val;\n    }\n    [Symbol.search](s) {\n      return s.indexOf(this.val);\n    }\n}\n'hileo'.search(new P('leo')); // 2\n```\n\n* 7. Symbol.split**   \n当该对象被 `String.prototype.split` 方法调用时, 会返回该方法的返回值.   \n\n```js\n// 重新定义了字符串对象的split方法的行为\nclass P {\n  constructor(val) {\n      this.val = val;\n    }\n    [Symbol.split](s) {\n      let i = s.indexOf(this.val);\n      if (i == -1) return s;\n      return [\n        s.substr(0, i),\n        s.substr(i + this.val.length)\n      ]\n    }\n}\n\n'helloworld'.split(new P('hello')); // [\"hello\", \"\"]\n'helloworld'.split(new P('world')); // [\"\", \"world\"] \n'helloworld'.split(new P('leo')); // \"helloworld\"\n```\n\n* 8. Symbol.iterator**   \n对象进行 `for...of` 循环时, 会调用 `Symbol.iterator` 方法, 返回该对象的默认遍历器.   \n\n```js\nclass P {\n  *[Symbol.interator]() {\n    let i = 0;\n    while (this[i] !== undefined) {\n      yield this[i];\n      ++i;\n    }\n  }\n}\nlet a = new P();\na[0] = 1;\na[1] = 2;\n\nfor (let k of a) {\n  console.log(k);\n}\n```\n\n* 9. Symbol.toPrimitive**   \n\n该对象被转为原始类型的值时, 会调用这个方法, 返回该对象对应的原始类型值. 调用时, 需要接收一个字符串参数, 表示当前运算模式, 运算模式有:  \n    - Number : 此时需要转换成数值   \n    - String : 此时需要转换成字符串  \n    - Default :  此时可以转换成数值或字符串\n\n```js\nlet obj = {\n  [Symbol.toPrimitive](hint) {\n    switch (hint) {\n      case 'number':\n        return 123;\n      case 'string':\n        return 'str';\n      case 'default':\n        return 'default';\n      default:\n        throw new Error();\n    }\n  }\n};\n\n2 * obj // 246\n3 + obj // '3default'\nobj == 'default' // true\nString(obj) // 'str'\n```\n\n* 10. Symbol.toStringTag**   \n\n在该对象上面调用 `Object.prototype.toString` 方法时, 如果这个属性存在, 它的返回值会出现在 `toString` 方法返回的字符串之中, 表示对象的类型. 也就是说, 这个属性可以用来定制 `[object Object` ]或 `[object Array]` 中 `object` 后面的那个字符串.   \n\n```js\n// 例一\n({\n  [Symbol.toStringTag]: 'Foo'\n}.toString())\n// \"[object Foo]\"\n\n// 例二\nclass Collection {\n  get[Symbol.toStringTag]() {\n    return 'xxx';\n  }\n}\nlet x = new Collection();\nObject.prototype.toString.call(x) // \"[object xxx]\"\n```\n\nES6 新增内置对象的Symbol.toStringTag属性值如下.\n\n* JSON[Symbol.toStringTag]:'JSON'\n* Math[Symbol.toStringTag]:'Math'\n* Module 对象M[Symbol.toStringTag]:'Module'\n* ArrayBuffer.prototype[Symbol.toStringTag]:'ArrayBuffer'\n* DataView.prototype[Symbol.toStringTag]:'DataView'\n* Map.prototype[Symbol.toStringTag]:'Map'\n* Promise.prototype[Symbol.toStringTag]:'Promise'\n* Set.prototype[Symbol.toStringTag]:'Set'\n* %TypedArray%.prototype[Symbol.toStringTag]:'Uint8Array'等\n* WeakMap.prototype[Symbol.toStringTag]:'WeakMap'\n* WeakSet.prototype[Symbol.toStringTag]:'WeakSet'\n* %MapIteratorPrototype%[Symbol.toStringTag]:'Map Iterator'\n* %SetIteratorPrototype%[Symbol.toStringTag]:'Set Iterator'\n* %StringIteratorPrototype%[Symbol.toStringTag]:'String Iterator'\n* Symbol.prototype[Symbol.toStringTag]:'Symbol'\n* Generator.prototype[Symbol.toStringTag]:'Generator'\n* GeneratorFunction.prototype[Symbol.toStringTag]:'GeneratorFunction'\n\n* 11. Symbol.unscopables**   \n该对象指定了使用with关键字时, 哪些属性会被with环境排除.\n\n```js\n// 没有 unscopables 时\nclass MyClass {\n  foo() {\n    return 1;\n  }\n}\n\nvar foo = function() {\n  return 2;\n};\n\nwith(MyClass.prototype) {\n  foo(); // 1\n}\n\n// 有 unscopables 时\nclass MyClass {\n  foo() {\n    return 1;\n  }\n  get[Symbol.unscopables]() {\n    return {\n      foo: true\n    };\n  }\n}\n\nvar foo = function() {\n  return 2;\n};\n\nwith(MyClass.prototype) {\n  foo(); // 2\n}\n```\n\n上面代码通过指定 `Symbol.unscopables` 属性, 使得 `with` 语法块不会在当前作用域寻找 `foo` 属性, 即 `foo` 将指向外层作用域的变量.   \n\n[⬆ 返回目录](#二目录)\n\n## Set和Map数据结构  \n\n### 10.1 Set\n**介绍**:   \n`Set` 数据结构类似数组, 但所有成员的值**唯一**.  \n`Set` 本身为一个构造函数, 用来生成 `Set` 数据结构, 使用 `add` 方法来添加新成员.      \n\n```js\nlet a = new Set();\n[1, 2, 2, 1, 3, 4, 5, 4, 5].forEach(x => a.add(x));\nfor (let k of a) {\n  console.log(k)\n};\n// 1 2 3 4 5\n```\n\n**基础使用**:  \n\n```js\nlet a = new Set([1, 2, 3, 3, 4]);\n[...a]; // [1,2,3,4]\na.size; // 4\n\n// 数组去重\n[...new Set([1, 2, 3, 4, 4, 4])]; // [1,2,3,4]\n```\n\n`注意` :   \n* 向`Set`中添加值的时候, 不会类型转换, 即`5`和`'5'`是不同的.   \n\n```js\n[...new Set([5, '5'])]; // [5, \"5\"]\n```\n\n**属性和方法**:   \n* 属性:  \n    - `Set.prototype.constructor`：构造函数，默认就是`Set`函数。   \n    - `Set.prototype.size`：返回`Set`实例的成员总数。  \n\n* 操作方法:  \n    - `add(value)`：添加某个值，返回 Set 结构本身。  \n    - `delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。  \n    - `has(value)`：返回一个布尔值，表示该值是否为Set的成员。  \n    - `clear()`：清除所有成员，没有返回值。  \n\n```js\nlet a = new Set();\na.add(1).add(2); // a => Set(2) {1, 2}\na.has(2); // true\na.has(3); // false\na.delete(2); // true  a => Set(1) {1}\na.clear(); // a => Set(0) {}\n```\n\n**数组去重**:   \n\n```js\nlet a = new Set([1, 2, 3, 3, 3, 3]);\n```\n\n### 10.2 Set的应用\n\n**数组去重**:  \n\n```js\n// 方法1\n[...new Set([1, 2, 3, 4, 4, 4])]; // [1,2,3,4]\n// 方法2\nArray.from(new Set([1, 2, 3, 4, 4, 4])); // [1,2,3,4]\n```\n\n**遍历和过滤**:  \n\n```js\nlet a = new Set([1, 2, 3, 4]);\n\n// map 遍历操作\nlet b = new Set([...a].map(x => x * 2)); // b => Set(4) {2,4,6,8}\n\n// filter 过滤操作\nlet c = new Set([...a].filter(x => (x % 2) == 0)); // b => Set(2) {2,4}\n```\n\n**获取并集、交集和差集**:   \n\n```js\nlet a = new Set([1, 2, 3]);\nlet b = new Set([4, 3, 2]);\n\n// 并集\nlet c1 = new Set([...a, ...b]); // Set {1,2,3,4}\n\n// 交集\nlet c2 = new Set([...a].filter(x => b.has(x))); // set {2,3}\n\n// 差集\nlet c3 = new Set([...a].filter(x => !b.has(x))); // set {1}\n```\n\n* 遍历方法:  \n    - `keys()`：返回**键名**的遍历器。  \n    - `values()`：返回**键值**的遍历器。  \n    - `entries()`：返回**键值对**的遍历器。  \n    - `forEach()`：使用回调函数遍历**每个成员**。  \n\n`Set` 遍历顺序是**插入顺序**, 当保存多个回调函数, 只需按照顺序调用. 但由于 `Set` 结构**没有键名只有键值**, 所以 `keys()` 和 `values()` 是返回结果相同.  \n\n```js\nlet a = new Set(['a', 'b', 'c']);\nfor (let i of a.keys()) {\n  console.log(i)\n}; // 'a' 'b' 'c'\nfor (let i of a.values()) {\n  console.log(i)\n}; // 'a' 'b' 'c'\nfor (let i of a.entries()) {\n  console.log(i)\n};\n// ['a','a'] ['b','b'] ['c','c']\n```\n\n并且 还可以使用 `for...of` 直接遍历 `Set` .  \n\n```js\nlet a = new Set(['a', 'b', 'c']);\nfor (let k of a) {\n  console.log(k)\n}; // 'a' 'b' 'c'\n```\n\n`forEach` 与数组相同, 对每个成员执行操作, 且无返回值.  \n\n```js\nlet a = new Set(['a', 'b', 'c']);\na.forEach((v, k) => console.log(k + ' : ' + v));\n```\n\n### 10.3 WeakSet\n\n与 Set 类似, 都是表示不重复的值的集合, 但是区别如下:\n1. WeakSet 成员只能为对象，不能为其他类型的值：\n\n```js\nconst leo = new WeakSet();\nleo.add(1); // TypeError: Invalid value used in weak set\nleo.add(Symbol()); // TypeError: Invalid value used in weak set\n```\n\n2. WeakSet 成员对象为弱引用\n\n垃圾回收机制不考虑 WeakSet 对该对象对引用, 即如果其他对象不再引用该对象, 那么就会被垃圾回收机制自动回收.\n\n3. WeakSet 对象没有 `size` 属性, 是不可枚举的, 无法获取集合的大小.\n\nWeakSet 是一个构造函数, 可以使用 `new` 命令, 创建 WeakSet 数据结构.\n\n```js\nconst leo = new WeakSet();\n```\n\nWeakSet 可以接受一个**数组**或**类数组对象**作为参数. 该数组的所有成员, 都会自动成为 WeakSet 实例对象的成员.\n\n实际上, 任何具有 Iterable 接口的对象, 都可以作为 WeakSet 的参数.\n\n```js\nconst arr = [\n  [1, 2],\n  [3, 4]\n];\nconst leo = new WeakSet(arr);\n// WeakSet {[1, 2], [3, 4]}\n```\n\n上面代码中, `arr` 是一个**数组**, 它有两个成员, 也都是数组. `arr` 作为 WeakSet 构造函数的参数, `arr` 的成员会自动成为 WeakSet 的成员.\n\n注意, 是 `arr` 数组的成员成为 WeakSet 的成员, 而不是 `arr` 数组本身. 这意味着, **数组的成员只能是对象**.\n\n```js\nconst arr = [3, 4];\nconst leo = new WeakSet(arr);\n// Uncaught TypeError: Invalid value used in weak set(…)\n```\n\n上面代码中, 数组 `arr` 的成员不是对象, 加入 WeakSet 就会**报错**.\n\nWeakSet 结构有以下三个方法.\n\n* `WeakSet.prototype.add(value)`: 向 WeakSet 实例添加一个新成员.\n* `WeakSet.prototype.delete(value)`: 清除 WeakSet 实例的指定成员.\n* `WeakSet.prototype.has(value)`: 返回一个布尔值, 表示某个值是否在 WeakSet 实例之中.\n\n下面是一个例子.\n\n```js\nconst ws = new WeakSet();\nconst obj = {};\nconst foo = {};\n\nws.add(window);\nws.add(obj);\n\nws.has(window); // true\nws.has(foo); // false\n\nws.delete(window);\nws.has(window); // false\n```\n\n`注意` : WeakSet 没有 `size` 属性, 没有办法遍历它的成员.\n\n```js\nws.size // undefined\nws.forEach // undefined\n\nws.forEach(function(item) {\n  console.log('WeakSet has ' + item)\n})\n// TypeError: undefined is not a function\n```\n\n上面代码试图获取 `size` 和 `forEach` 属性, 结果都不能成功.\n\nWeakSet 不能遍历, 是因为成员都是弱引用, 随时可能消失, 遍历机制无法保证成员的存在, 很可能刚刚遍历结束, 成员就取不到了. WeakSet 的一个用处, 是储存 DOM 节点, 而不用担心这些节点从文档移除时, 会引发内存泄漏.\n\n下面是 WeakSet 的另一个例子.\n\n```js\nconst foos = new WeakSet()\nclass Foo {\n  constructor() {\n    foos.add(this)\n  }\n  method() {\n    if (!foos.has(this)) {\n      throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用！');\n    }\n  }\n}\n```\n\n上面代码保证了 `Foo` 的实例方法, 只能在 `Foo` 的实例上调用. 这里使用 WeakSet 的好处是, `foos` 对实例的引用, 不会被计入内存回收机制, 所以删除实例的时候, 不用考虑 `foos` , 也不会出现内存泄漏.\n\n### 10.4 Map\n\n由于传统的 `JavaScript` 对象只能用字符串当做键, 给开发带来很大限制, ES6增加 `Map` 数据结构, 使得**各种类型的值**(包括对象)都可以作为键.   \n`Map` 结构提供了\"**值—值**\"的对应, 是一种更完善的 Hash 结构实现.\n\n**基础使用**:  \n\n```js\nlet a = new Map();\nlet b = {\n  name: 'leo'\n};\na.set(b, 'my name'); // 添加值\na.get(b); // 获取值\na.size; // 获取总数\na.has(b); // 查询是否存在\na.delete(b); // 删除一个值\na.clear(); // 清空所有成员 无返回\n```\n\n`注意` :  \n* 传入数组作为参数, **指定键值对的数组**.   \n\n```js\nlet a = new Map([\n  ['name', 'leo'],\n  ['age', 18]\n])\n```\n\n* 如果对同一个键**多次赋值**, 后面的值将**覆盖前面的值**.   \n\n```js\nlet a = new Map();\na.set(1, 'aaa').set(1, 'bbb');\na.get(1); // 'bbb'\n```\n\n* 如果读取一个未知的键, 则返回`undefined`.  \n\n```js\nnew Map().get('abcdef'); // undefined\n```\n\n* 同样的值**的两个实例, 在 Map 结构中被视为两个键.   \n\n```js\nlet a = new Map();\nlet a1 = ['aaa'];\nlet a2 = ['aaa'];\na.set(a1, 111).set(a2, 222);\na.get(a1); // 111\na.get(a2); // 222\n```\n\n**遍历方法**:\nMap 的遍历顺序就是插入顺序.  \n* `keys()`: 返回键名的遍历器.\n* `values()`: 返回键值的遍历器.\n* `entries()`: 返回所有成员的遍历器.\n* `forEach()`: 遍历 Map 的所有成员.\n\n```js\nlet a = new Map([\n  ['name', 'leo'],\n  ['age', 18]\n])\n\nfor (let i of a.keys()){...};\nfor (let i of a.values()){...};\nfor (let i of a.entries()){...};\na.forEach((v,k,m)=>{\n    console.log(`key:${k},value:${v},map:${m}`)\n})\n```\n\n**将Map结构转成数组结构**:  \n\n```js\nlet a = new Map([\n  ['name', 'leo'],\n  ['age', 18]\n])\n\nlet a1 = [...a.keys()];   // a1 => [\"name\", \"age\"]\nlet a2 = [...a.values()]; // a2 =>  [\"leo\", 18]\nlet a3 = [...a.entries()];// a3 => [['name','leo'], ['age',18]]\n```\n\n### 10.5 Map与其他数据结构互相转换\n\n* Map 转 数组  \n\n```js\nlet a = new Map().set(true, 1).set({\n  f: 2\n}, ['abc']);\n[...a]; // [[true:1], [ {f:2},['abc'] ]]\n```\n\n* 数组 转 Map  \n\n```js\nlet a = [\n  ['name', 'leo'],\n  [1, 'hi']\n]\nlet b = new Map(a);\n```\n\n* Map 转 对象\n\n如果所有 Map 的键都是字符串, 它可以无损地转为对象.   \n如果有非字符串的键名, 那么这个键名会被转成字符串, 再作为对象的键名.   \n\n```js\nfunction fun(s) {\n  let obj = Object.create(null);\n  for (let [k, v] of s) {\n    obj[k] = v;\n  }\n  return obj;\n}\n\nconst a = new Map().set('yes', true).set('no', false);\nfun(a)\n// { yes: true, no: false }\n```\n\n* 对象 转 Map   \n\n```js\nfunction fun(obj) {\n  let a = new Map();\n  for (let k of Object.keys(obj)) {\n    a.set(k, obj[k]);\n  }\n  return a;\n}\n\nfun({\n  yes: true,\n  no: false\n})\n// Map {\"yes\" => true, \"no\" => false}\n```\n\n* Map 转 JSON   \n\n**(1)Map键名都是字符串, 转为对象JSON:**   \n\n```js\nfunction fun(s) {\n  let obj = Object.create(null);\n  for (let [k, v] of s) {\n    obj[k] = v;\n  }\n  return JSON.stringify(obj)\n}\nlet a = new Map().set('yes', true).set('no', false);\nfun(a);\n// '{\"yes\":true,\"no\":false}'\n```\n\n**(2)Map键名有非字符串, 转为数组JSON:**    \n\n```js\nfunction fun(map) {\n  return JSON.stringify([...map]);\n}\n\nlet a = new Map().set(true, 7).set({\n  foo: 3\n}, ['abc']);\nfun(a)\n// '[[true,7],[{\"foo\":3},[\"abc\"]]]'\n```\n\n* JSON 转 Map  \n\n**(1)所有键名都是字符串:**   \n\n```js\nfunction fun(s) {\n  let strMap = new Map();\n  for (let k of Object.keys(s)) {\n    strMap.set(k, s[k]);\n  }\n  return strMap;\n  return JSON.parse(strMap);\n}\nfun('{\"yes\": true, \"no\": false}')\n// Map {'yes' => true, 'no' => false}\n```\n\n**(2)整个 JSON 就是一个数组, 且每个数组成员本身, 又是一个有两个成员的数组**:   \n\n```js\nfunction fun2(s) {\n  return new Map(JSON.parse(s));\n}\nfun2('[[true,7],[{\"foo\":3},[\"abc\"]]]')\n// Map {true => 7, Object {foo: 3} => ['abc']}\n```\n\n### 10.6 WeakMap\n\nWeakMap 结构与 Map 结构类似, 也是用于**生成键值对的集合**.\n\n```js\n// WeakMap 可以使用 set 方法添加成员\nconst wm1 = new WeakMap();\nconst key = {\n  foo: 1\n};\nwm1.set(key, 2);\nwm1.get(key) // 2\n\n// WeakMap 也可以接受一个数组，\n// 作为构造函数的参数\nconst k1 = [1, 2, 3];\nconst k2 = [4, 5, 6];\nconst wm2 = new WeakMap([\n  [k1, 'foo'],\n  [k2, 'bar']\n]);\nwm2.get(k2) // \"bar\"\n```\n\nWeakMap 与 Map 的区别有 4 点:\n\n1. WeakMap 只接受对象作为键名（null除外），不接受其他类型的值作为键名。\n\n```js\nconst map = new WeakMap();\nmap.set(1, 2)\n// TypeError: 1 is not an object!\nmap.set(Symbol(), 2)\n// TypeError: Invalid value used as weak map key\nmap.set(null, 2)\n// TypeError: Invalid value used as weak map key\n```\n\n2. WeakMap 的键名所指向的对象，不计入垃圾回收机制。\n\nWeakMap 的设计目的在于, 有时我们想在某个对象上面存放一些数据, 但是这会形成对于这个对象的引用. 请看下面的例子.\n\n```js\nconst e1 = document.getElementById('foo');\nconst e2 = document.getElementById('bar');\nconst arr = [\n  [e1, 'foo 元素'],\n  [e2, 'bar 元素'],\n];\n```\n\n上面代码中, e1和e2是两个对象, 我们通过arr数组对这两个对象添加一些文字说明. 这就形成了arr对e1和e2的引用.\n\n一旦不再需要这两个对象, 我们就必须手动删除这个引用, 否则垃圾回收机制就不会释放e1和e2占用的内存.\n\n```js\n// 不需要 e1 和 e2 的时候\n// 必须手动删除引用\narr[0] = null;\narr[1] = null;\n```\n\n上面这样的写法显然很不方便. 一旦忘了写, 就会造成内存泄露.\n\nWeakMap 就是为了解决这个问题而诞生的, 它的键名所引用的对象都是弱引用, 即垃圾回收机制不将该引用考虑在内. 因此, 只要所引用的对象的其他引用都被清除, 垃圾回收机制就会释放该对象所占用的内存. 也就是说, 一旦不再需要, WeakMap 里面的键名对象和所对应的键值对会自动消失, 不用手动删除引用.\n\n基本上, 如果你要往对象上添加数据, 又不想干扰垃圾回收机制, 就可以使用 WeakMap. 一个典型应用场景是, 在网页的 DOM 元素上添加数据, 就可以使用WeakMap结构. 当该 DOM 元素被清除, 其所对应的WeakMap记录就会自动被移除.\n\n```js\nconst wm = new WeakMap();\n\nconst element = document.getElementById('example');\n\nwm.set(element, 'some information');\nwm.get(element) // \"some information\"\n```\n\n上面代码中, 先新建一个 Weakmap 实例. 然后, 将一个 DOM 节点作为键名存入该实例, 并将一些附加信息作为键值, 一起存放在 WeakMap 里面. 这时, WeakMap 里面对element的引用就是弱引用, 不会被计入垃圾回收机制.\n\n也就是说, 上面的 DOM 节点对象的引用计数是1, 而不是2. 这时, 一旦消除对该节点的引用, 它占用的内存就会被垃圾回收机制释放. Weakmap 保存的这个键值对, 也会自动消失.\n\n总之, WeakMap的专用场合就是, 它的键所对应的对象, 可能会在将来消失. WeakMap结构有助于防止内存泄漏.\n\n注意, WeakMap 弱引用的只是键名, 而不是键值. 键值依然是正常引用.\n\n```js\nconst wm = new WeakMap();\nlet key = {};\nlet obj = {\n  foo: 1\n};\n\nwm.set(key, obj);\nobj = null;\nwm.get(key)\n// Object {foo: 1}\n```\n\n上面代码中, 键值obj是正常引用. 所以, 即使在 WeakMap 外部消除了obj的引用, WeakMap 内部的引用依然存在.\n\n3. WeakMap 没有遍历操作对 API。\n\nWeakMap 是没有遍历操作(即没有 `keys()` 、 `values()` 和e `ntries()` 方法), 也没有 `size` 属性.\n因为没有办法列出所有键名, 某个键名是否存在完全不可预测, 跟垃圾回收机制是否运行相关. 这一刻可以取到键名, 下一刻垃圾回收机制突然运行了, 这个键名就没了, 为了防止出现不确定性, 就统一规定不能取到键名.\n\n```js\nconst wm = new WeakMap();\n\nwm.size // undefined\nwm.forEach // undefined\n```\n\n4. WeakMap 无法清空。\n\n即不支持 `clear` 方法.\n因此, WeakMap 只有四个方法可用: `get()` 、 `set()` 、 `has()` 、 `delete()` .\n\n```js\nconst wm = new WeakMap();\n\nwm.clear // undefined\n```\n\n**WeakMap 应用**:\n\n**场景1: 当我们想要为DOM添加数据时, 可使用 `WeakMap` .**\n\n好处在于, 当DOM元素移除时, 对应 WeakMap 记录也会自动移除:\n\n```html\n<div id=\"WeakMap\"></div>\n```\n\n```javascript\nconst wm = new WeakMap();\nconst weakMap = document.getElementById('WeakMap');\nwm.set(weakMap, 'some information');\nwm.get(weakMap) //\"some information\"\n```\n\n**场景2: 当我们想要为DOM元素添加事件监听时, 可使用 `WeakMap` .**\n\n```html\n<button id=\"button1\">按钮1</button>\n<button id=\"button2\">按钮2</button>\n```\n\n```javascript\nconst button1 = document.getElementById('button1');\nconst button2 = document.getElementById('button2');\nconst handler1 = () => {\n  console.log(\"button1 被点击\")\n};\nconst handler2 = () => {\n  console.log(\"button2 被点击\")\n};\n\n// 代码1\nbutton1.addEventListener('click', handler1, false);\nbutton2.addEventListener('click', handler2, false);\n\n// 代码2\nconst listener = new WeakMap();\n\nlistener.set(button1, handler1);\nlistener.set(button2, handler2);\n\nbutton1.addEventListener('click', listener.get(button1), false);\nbutton2.addEventListener('click', listener.get(button2), false);\n```\n\n代码2比起代码1的好处是: 由于监听函数是放在 WeakMap 里面, \n\n则一旦 DOM 对象button1 / button2消失, 与它绑定的监听函数handler1和handler2 也会自动消失.\n\n[⬆ 返回目录](#二目录)\n\n## Proxy\n\n`proxy` 用于修改某些操作的**默认行为**, 可以理解为一种拦截外界对目标对象访问的一种机制, 从而对外界的访问进行过滤和修改, 即代理某些操作, 也称\"**代理器**\".   \n\n### 基础使用  \n\n`proxy` 实例化需要传入两个参数, `target` 参数表示所要拦截的目标对象, `handler` 参数也是一个对象, 用来定制拦截行为.   \n\n语法如下:\n\n```js\nlet proxy = new Proxy(target, handler);\n```\n\n简单示例:\n\n```js\nlet a = new Proxy({}, {\n  get: function(target, handler) {\n    return 'leo';\n  }\n})\na.name; // leo\na.age; // leo\na.abcd; // leo\n```\n\n上述 `a` 实例中, 在第二个参数中定义了 `get` 方法, 来拦截外界访问, 并且 `get` 方法接收两个参数, 分别是**目标对象**和**所要访问的属性**, 所以不管外部访问对象中任何属性都会执行 `get` 方法返回 `leo` .   \n`注意` :   \n* 只能使用`Proxy`实例的对象才能使用这些操作.  \n* 如果`handler`没有设置拦截, 则直接返回原对象.  \n\n```js\nlet target = {};\nlet handler = {};\nlet p = new Proxy(target, handler);\np.a = 'leo';\ntarget.a; // 'leo'\n```\n\n**同个拦截器函数, 设置多个拦截操作**:  \n\n```js\nlet p = new Proxy(function(a, b) {\n  return a + b;\n}, {\n  get: function() {\n    return 'get方法';\n  },\n  apply: function() {\n    return 'apply方法';\n  }\n})\n```\n\n这里还有一个简单的案例:   \n\n```js\nlet handler = {\n  get: function(target, name) {\n    return name in target ? target[name] : 16;\n  }\n}\n\nlet p = new Proxy({}, handler);\np.a = 1;\nconsole.log(p.a, p.b);\n// 1   16\n```\n\n这里因为 `p.a = 1` 定义了 `p` 中的 `a` 属性, 值为 `1` , 而没有定义 `b` 属性, 所以 `p.a` 会得到 `1` , 而 `p.b` 会得到 `undefined` 从而使用 `name in target ? target[name] : 16; ` 返回的默认值 `16` ; \n\n** `Proxy` 支持的13种拦截操作**:   \n<!-- 13种拦截操作的详细介绍:[打开阮一峰老师的链接](http://es6.ruanyifeng.com/#docs/proxy).    -->\n* `get(target, propKey, receiver)`:\n拦截对象属性的读取, 比如proxy.foo和proxy['foo'].\n\n* `set(target, propKey, value, receiver)`:\n拦截对象属性的设置, 比如proxy.foo = v或proxy['foo'] = v, 返回一个布尔值.\n\n* `has(target, propKey)`:\n拦截propKey in proxy的操作, 返回一个布尔值.\n\n* `deleteProperty(target, propKey)`:\n拦截delete proxy[propKey]的操作, 返回一个布尔值.\n\n* `ownKeys(target)`:\n拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环, 返回一个数组. 该方法返回目标对象所有自身的属性的属性名, 而Object.keys()的返回结果仅包括目标对象自身的可遍历属性.\n\n* `getOwnPropertyDescriptor(target, propKey)`:\n拦截Object.getOwnPropertyDescriptor(proxy, propKey), 返回属性的描述对象.\n\n* `defineProperty(target, propKey, propDesc)`:\n拦截Object.defineProperty(proxy, propKey, propDesc)、Object.defineProperties(proxy, propDescs), 返回一个布尔值.\n\n* `preventExtensions(target)`:\n拦截Object.preventExtensions(proxy), 返回一个布尔值.\n\n* `getPrototypeOf(target)`:\n拦截Object.getPrototypeOf(proxy), 返回一个对象.\n\n* `isExtensible(target)`:\n拦截Object.isExtensible(proxy), 返回一个布尔值.\n\n* `setPrototypeOf(target, proto)`:\n拦截Object.setPrototypeOf(proxy, proto), 返回一个布尔值. 如果目标对象是函数, 那么还有两种额外操作可以拦截.\n\n* `apply(target, object, args)`:\n拦截 Proxy 实例作为函数调用的操作, 比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...).\n\n* `construct(target, args)`:\n拦截 Proxy 实例作为构造函数调用的操作, 比如new proxy(...args).\n\n### 取消Proxy实例\n\n使用 `Proxy.revocale` 方法取消 `Proxy` 实例.   \n\n```js\nlet a = {};\nlet b = {};\nlet {\n  proxy,\n  revoke\n} = Proxy.revocale(a, b);\n\nproxy.name = 'leo'; // 'leo'\nrevoke();\nproxy.name; // TypeError: Revoked\n```\n\n### 实现 Web服务的客户端\n\n```js\nconst service = createWebService('http://le.com/data');\nservice.employees().than(json => {\n  const employees = JSON.parse(json);\n})\n\nfunction createWebService(url) {\n  return new Proxy({}, {\n    get(target, propKey, receiver {\n      return () => httpGet(url + '/' + propKey);\n    })\n  })\n}\n```\n\n## Promise对象\n\n### 概念\n主要用途:**解决异步编程带来的回调地狱问题**.   \n把 `Promise` 简单理解一个容器, 存放着某个未来才会结束的事件(通常是一个异步操作)的结果. 通过 `Promise` 对象来获取异步操作消息, 处理各种异步操作.   \n\n** `Promise` 对象2特点**:  \n* 对象的状态不受外界影响**.\n\n> `Promise` 对象代表一个异步操作, 有三种状态:**pending(进行中)**、**fulfilled(已成功)**和**rejected(已失败)**. 只有异步操作的结果, 可以决定当前是哪一种状态, 任何其他操作都无法改变这个状态. 这也是 `Promise` 这个名字的由来, 它的英语意思就是\"承诺\", 表示其他手段无法改变.\n\n* 一旦状态改变, 就不会再变, 任何时候都可以得到这个结果**.  \n\n> Promise对象的状态改变, 只有两种可能: 从**pending**变为**fulfilled**和从**pending**变为**rejected**. 只要这两种情况发生, 状态就凝固了, 不会再变了, 会一直保持这个结果, 这时就称为 **resolved**(已定型). 如果改变已经发生了, 你再对**Promise**对象添加回调函数, 也会立即得到这个结果. 这与事件(Event)完全不同, 事件的特点是, 如果你错过了它, 再去监听, 是得不到结果的.      \n\n注意, 为了行文方便, 本章后面的 `resolve` d统一只指 `fulfilled` 状态, 不包含 `rejected` 状态.\n\n** `Promise` 缺点**   \n* 无法取消**Promise, 一旦新建它就会立即执行, 无法中途取消.  \n* 如果不设置回调函数, Promise内部抛出的错误, 不会反应到外部.\n* 当处于pending状态时, 无法得知目前进展到哪一个阶段(刚刚开始还是即将完成).\n\n### 基本使用\n\n`Promise` 为一个构造函数, 需要用 `new` 来实例化.   \n\n```js\nlet p = new Promise(function(resolve, reject) {\n  if ( /*异步操作成功*/ ) {\n    resolve(value);\n  } else {\n    reject(error);\n  }\n})\n```\n\n`Promise` 接收一个函数作为参数, 该函数两个参数 `resolve` 和 `reject` , 由 JS 引擎提供.   \n* `resolve`作用是将`Promise`的状态从pending变成resolved, 在异步操作成功时调用, 返回异步操作的结果, 作为参数传递出去.    \n* `reject`作用是将`Promise`的状态从pending变成rejected, 在异步操作失败时报错, 作为参数传递出去.   \n\n`Promise` 实例生成以后, 可以用 `then` 方法分别指定 `resolved` 状态和 `rejected` 状态的回调函数.   \n\n```js\np.then(function(val) {\n  // success...\n}, function(err) {\n  // error...\n})\n```\n\n**几个例子来理解** : \n* 当一段时间过后, `Promise`状态便成为`resolved`触发`then`方法绑定的回调函数.  \n\n```js\nfunction timeout(s) {\n  return new Promise((resolve, reject) {\n    setTimeout(result, ms, 'done');\n  })\n}\ntimeout(100).then(val => {\n  console.log(val);\n})\n```\n\n* `Promise`新建后立刻执行. \n```js \nlet p = new Promise(function(resolve, reject){\n\n```js\nconsole.log(1);\nresolve();\n```\n\n})\np.then(()=>{\n\n```js\nconsole.log(2);\n```\n\n})\nconsole.log(3); \n// 1\n// 3\n// 2\n\n```\n\n**异步加载图片**：  \n```js\nfunction f(url){\n    return new Promise(function(resolve, reject){\n        const img = new Image ();\n        img.onload = function(){\n            resolve(img);\n        }\n        img.onerror = function(){\n            reject(new Error(\n                'Could not load image at ' + url\n            ));\n        }\n        img.src = url;\n    })\n}\n```\n\n** `resolve` 函数和 `reject` 函数的参数为 `resolve` 函数或 `reject` 函数**:  \n`p1` 的状态决定了 `p2` 的状态, 所以 `p2` 要等待 `p1` 的结果再执行回调函数.  \n\n```js\nconst p1 = new Promise(function(resolve, reject) {\n  setTimeout(() => reject(new Error('fail')), 3000)\n})\n\nconst p2 = new Promise(function(resolve, reject) {\n  setTimeout(() => resolve(p1), 1000)\n})\n\np2\n  .then(result => console.log(result))\n  .catch(error => console.log(error))\n// Error: fail\n```\n\n**调用 `resolve` 或 `reject` 不会结束 `Promise` 参数函数的执行, 除了 `return` **:     \n\n```js\nnew Promise((resolve, reject) {\n  resolve(1);\n  console.log(2);\n}).then(r => {\n  console.log(3);\n})\n// 2\n// 1\n\nnew Promise((resolve, reject) {\n  return resolve(1);\n  console.log(2);\n})\n// 1\n```\n\n### Promise.prototype.then()\n\n作用是为 `Promise` 添加状态改变时的回调函数, `then` 方法的第一个参数是 `resolved` 状态的回调函数, 第二个参数(可选)是 `rejected` 状态的回调函数.   \n`then` 方法返回一个新 `Promise` 实例, 与原来 `Promise` 实例不同, 因此可以使用链式写法, 上一个 `then` 的结果作为下一个 `then` 的参数.  \n\n```js\ngetJSON(\"/posts.json\").then(function(json) {\n  return json.post;\n}).then(function(post) {\n  // ...\n});\n```\n\n### Promise.prototype.catch()\n\n`Promise.prototype.catch` 方法是 `.then(null, rejection)` 的别名, 用于指定发生错误时的回调函数.   \n\n```js\ngetJSON('/posts.json').then(function(posts) {\n  // ...\n}).catch(function(error) {\n  // 处理 getJSON 和 前一个回调函数运行时发生的错误\n  console.log('发生错误！', error);\n});\n```\n\n如果 `Promise` 状态已经变成 `resolved` , 再抛出错误是无效的.   \n\n```js\nconst p = new Promise(function(resolve, reject) {\n  resolve('ok');\n  throw new Error('test');\n});\np\n  .then(function(value) {\n    console.log(value)\n  })\n  .catch(function(error) {\n    console.log(error)\n  });\n// ok\n```\n\n当 `promise` 抛出一个错误, 就被 `catch` 方法指定的回调函数捕获, 下面三种写法相同.   \n\n```js\n// 写法一\nconst p = new Promise(function(resolve, reject) {\n  throw new Error('test');\n});\np.catch(function(error) {\n  console.log(error);\n});\n// Error: test\n\n// 写法二\nconst p = new Promise(function(resolve, reject) {\n  try {\n    throw new Error('test');\n  } catch (e) {\n    reject(e);\n  }\n});\np.catch(function(error) {\n  console.log(error);\n});\n\n// 写法三\nconst p = new Promise(function(resolve, reject) {\n  reject(new Error('test'));\n});\np.catch(function(error) {\n  console.log(error);\n});\n```\n\n一般来说, 不要在 `then` 方法里面定义 ` Reject` 状态的回调函数(即 `then` 的第二个参数), 总是使用 `catch` 方法.    \n\n```js\n// bad\npromise\n  .then(function(data) {\n    // success\n  }, function(err) {\n    // error\n  });\n\n// good\npromise\n  .then(function(data) { //cb\n    // success\n  })\n  .catch(function(err) {\n    // error\n  });\n```\n\n### Promise.prototype.finally()\n\n`finally` 方法用于指定不管 `Promise` 对象最后状态如何, 都会执行的操作. 该方法是 ES2018 引入标准的.   \n\n```js\npromise\n  .then(result => {\n    ···})\n  .catch(error => {\n    ···})\n  .finally(() => {\n    ···});\n```\n\n`finally` 不接收任何参数, 与状态无关, 本质上是 `then` 方法的特例.   \n\n```js\npromise\n  .finally(() => {\n    // 语句\n  });\n\n// 等同于\npromise\n  .then(\n    result => {\n      // 语句\n      return result;\n    },\n    error => {\n      // 语句\n      throw error;\n    }\n  );\n```\n\n上面代码中, 如果不使用 `finally` 方法, 同样的语句需要为成功和失败两种情况各写一次. 有了 `finally` 方法, 则只需要写一次.   \n`finally` 方法总是会返回原来的值.   \n\n```js\n// resolve 的值是 undefined\nPromise.resolve(2).then(() => {}, () => {})\n\n// resolve 的值是 2\nPromise.resolve(2).finally(() => {})\n\n// reject 的值是 undefined\nPromise.reject(3).then(() => {}, () => {})\n\n// reject 的值是 3\nPromise.reject(3).finally(() => {})\n```\n\n### Promise.all() \n\n用于将多个 `Promise` 实例, 包装成一个新的 `Promise` 实例, 参数可以不是数组, 但必须是Iterator接口, 且返回的每个成员都是 `Promise` 实例.  \n\n```js\nconst p = Promise.all([p1, p2, p3]);\n```\n\n`p` 的状态由 `p1` 、 `p2` 、 `p3` 决定, 分成**两种**情况.  \n1. 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。  \n2. 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。   \n\n```js\n// 生成一个Promise对象的数组\nconst promises = [2, 3, 5, 7, 11, 13].map(function(id) {\n  return getJSON('/post/' + id + \".json\");\n});\n\nPromise.all(promises).then(function(posts) {\n  // ...\n}).catch(function(reason) {\n  // ...\n});\n```\n\n上面代码中, `promises` 是包含 6 个 Promise 实例的数组, 只有这 6 个实例的状态都变成 `fulfilled` , 或者其中有一个变为 `rejected` , 才会调用 `Promise.all` 方法后面的回调函数.    \n\n`注意` : 如果 `Promise` 的参数中定义了 `catch` 方法, 则 `rejected` 后不会触发 `Promise.all()` 的 `catch` 方法, 因为参数中的 `catch` 方法执行完后也会变成 `resolved` , 当 `Promise.all()` 方法参数的实例都是 `resolved` 时就会调用 `Promise.all()` 的 `then` 方法.   \n\n```js\nconst p1 = new Promise((resolve, reject) => {\n    resolve('hello');\n  })\n  .then(result => result)\n  .catch(e => e);\n\nconst p2 = new Promise((resolve, reject) => {\n    throw new Error('报错了');\n  })\n  .then(result => result)\n  .catch(e => e);\n\nPromise.all([p1, p2])\n  .then(result => console.log(result))\n  .catch(e => console.log(e));\n// [\"hello\", Error: 报错了]\n```\n\n**如果参数里面都没有catch方法, 就会调用Promise.all()的catch方法.**   \n\n```js\nconst p1 = new Promise((resolve, reject) => {\n    resolve('hello');\n  })\n  .then(result => result);\n\nconst p2 = new Promise((resolve, reject) => {\n    throw new Error('报错了');\n  })\n  .then(result => result);\n\nPromise.all([p1, p2])\n  .then(result => console.log(result))\n  .catch(e => console.log(e));\n// Error: 报错了\n```\n\n### Promise.race()\n\n与 `Promise.all` 方法类似, 也是将多个 `Promise` 实例包装成一个新的 `Promise` 实例.   \n\n```js\nconst p = Promise.race([p1, p2, p3]);\n```\n\n与 `Promise.all` 方法区别在于, `Promise.race` 方法是 `p1` , `p2` , `p3` 中只要一个参数先改变状态, 就会把这个参数的返回值传给 `p` 的回调函数.  \n\n### Promise.resolve()\n\n将现有对象转换成 `Promise` 对象.   \n\n```js\nconst p = Promise.resolve($.ajax('/whatever.json'));\n```\n\n### Promise.reject()\n\n返回一个 `rejected` 状态的 `Promise` 实例.  \n\n```js\nconst p = Promise.reject('出错了');\n// 等同于\nconst p = new Promise((resolve, reject) => reject('出错了'))\n\np.then(null, function(s) {\n  console.log(s)\n});\n// 出错了\n```\n\n注意, `Promise.reject()` 方法的参数, 会原封不动地作为 `reject` 的理由, 变成后续方法的参数. 这一点与 `Promise.resolve` 方法不一致.   \n\n```js\nconst thenable = {\n  then(resolve, reject) {\n    reject('出错了');\n  }\n};\n\nPromise.reject(thenable)\n  .catch(e => {\n    console.log(e === thenable)\n  })\n// true\n```\n\n[⬆ 返回目录](#二目录)\n\n## Iterator和 for...of循环\n\n### Iterator遍历器概念\n\n> **Iterator**是一种接口, 为各种不同的数据结构提供统一的访问机制. 任何数据结构只要部署 **Iterator** 接口, 就可以完成遍历操作(即依次处理该数据结构的所有成员).  \n\n**Iterator三个作用**:\n* 为各种数据结构, 提供一个**统一**的、**简便**的访问接口; \n* 使得数据结构的成员能够按某种次序排列; \n* Iterator** 接口主要供ES6新增的`for...of`消费; \n\n### Iterator遍历过程\n\n1. 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。   \n2. 第一次调用指针对象的`next`方法，可以将指针指向数据结构的第一个成员。\n3. 第二次调用指针对象的`next`方法，指针就指向数据结构的第二个成员。\n4. 不断调用指针对象的`next`方法，直到它指向数据结构的结束位置。\n\n每一次调用 `next` 方法, 都会返回数据结构的当前成员的信息. 具体来说, 就是返回一个包含 `value` 和 `done` 两个属性的对象.\n\n* `value`属性是当前成员的值; \n* `done`属性是一个布尔值, 表示遍历是否结束; \n\n模拟 `next` 方法返回值:   \n\n```js\nlet f = function(arr) {\n  var nextIndex = 0;\n  return {\n    next: function() {\n      return nextIndex < arr.length ? {\n        value: arr[nextIndex++],\n        done: false\n      } : {\n        value: undefined,\n        done: true\n      }\n    }\n  }\n}\n\nlet a = f(['a', 'b']);\na.next(); // { value: \"a\", done: false }\na.next(); // { value: \"b\", done: false }\na.next(); // { value: undefined, done: true }\n```\n\n### 默认Iterator接口\n\n若数据**可遍历**, 即一种数据部署了Iterator接口.   \nES6中默认的Iterator接口部署在数据结构的 `Symbol.iterator` 属性, 即如果一个数据结构具有 `Symbol.iterator` 属性, 就可以认为是**可遍历**.   \n`Symbol.iterator` 属性本身是函数, 是当前数据结构默认的遍历器生成函数. 执行这个函数, 就会返回一个遍历器. 至于属性名 `Symbol.iterator` , 它是一个表达式, 返回 `Symbol` 对象的 `iterator` 属性, 这是一个预定义好的、类型为 Symbol 的特殊值, 所以要放在方括号内(参见《Symbol》一章).   \n\n**原生具有Iterator接口的数据结构有**:   \n* Array\n* Map\n* Set\n* String\n* TypedArray\n* 函数的 arguments 对象\n* NodeList 对象\n\n### Iterator使用场景\n\n* (1)解构赋值**  \n\n对数组和 `Set` 结构进行解构赋值时, 会默认调用 `Symbol.iterator` 方法.   \n\n```js\nlet a = new Set().add('a').add('b').add('c');\nlet [x, y] = a; // x = 'a'  y = 'b'\nlet [a1, ...a2] = a; // a1 = 'a' a2 = ['b','c']\n```\n\n* (2)扩展运算符**  \n\n扩展运算符( `...` )也会调用默认的 Iterator 接口.   \n\n```js\nlet a = 'hello';\n[...a]; //  ['h','e','l','l','o']\n\nlet a = ['b', 'c'];\n['a', ...a, 'd']; // ['a', 'b', 'c', 'd']\n```\n\n* (3)yield***  \n`yield*` 后面跟的是一个可遍历的结构, 它会调用该结构的遍历器接口.  \n\n```js\nlet a = function*() {\n  yield 1;\n  yield*[2, 3, 4];\n  yield 5;\n}\n\nlet b = a();\nb.next() // { value: 1, done: false }\nb.next() // { value: 2, done: false }\nb.next() // { value: 3, done: false }\nb.next() // { value: 4, done: false }\nb.next() // { value: 5, done: false }\nb.next() // { value: undefined, done: true }\n```\n\n* (4)其他场合**  \n\n由于数组的遍历会调用遍历器接口, 所以任何接受数组作为参数的场合, 其实都调用了遍历器接口. 下面是一些例子.  \n\n* for...of\n* Array.from()\n* Map(), Set(), WeakMap(), WeakSet()(比如`new Map([['a', 1], ['b', 2]])`)\n* Promise.all()\n* Promise.race()\n\n### for...of循环\n\n只要数据结构部署了 `Symbol.iterator` 属性, 即具有 iterator 接口, 可以用 `for...of` 循环遍历它的成员. 也就是说, `for...of` 循环内部调用的是数据结构的 `Symbol.iterato` 方法.  \n**使用场景**:   \n`for...of` 可以使用在**数组**, ** `Set` 和 `Map` 结构**, **类数组对象**, **Genetator对象**和**字符串**.   \n\n* 数组**   \n`for...of` 循环可以代替数组实例的 `forEach` 方法.   \n\n```js\nlet a = ['a', 'b', 'c'];\nfor (let k of a) {\n  console.log(k)\n}; // a b c\n\na.forEach((ele, index) => {\n  console.log(ele); // a b c\n  console.log(index); // 0 1 2 \n})\n```\n\n与 `for...in` 对比, `for...in` 只能获取对象键名, 不能直接获取键值, 而 `for...of` 允许直接获取键值.   \n\n```js\nlet a = ['a', 'b', 'c'];\nfor (let k of a) {\n  console.log(k)\n}; // a b c\nfor (let k in a) {\n  console.log(k)\n}; // 0 1 2\n```\n\n* Set和Map**   \n\n可以使用数组作为变量, 如 `for (let [k, v] of b){...}` .   \n\n```js\nlet a = new Set(['a', 'b', 'c']);\nfor (let k of a) {\n  console.log(k)\n}; // a b c\n\nlet b = new Map();\nb.set('name', 'leo');\nb.set('age', 18);\nb.set('aaa', 'bbb');\nfor (let [k, v] of b) {\n  console.log(k + \":\" + v)\n};\n// name:leo\n// age:18\n// aaa:bbb\n```\n\n* 类数组对象**   \n\n```js\n// 字符串\nlet a = 'hello';\nfor (let k of a) {\n  console.log(k)\n}; // h e l l o\n\n// DOM NodeList对象\nlet b = document.querySelectorAll('p');\nfor (let k of b) {\n  k.classList.add('test');\n}\n\n// arguments对象\nfunction f() {\n  for (let k of arguments) {\n    console.log(k);\n  }\n}\nf('a', 'b'); // a b\n```\n\n* 对象**     \n普通对象不能直接使用 `for...of` 会报错, 要部署Iterator才能使用.  \n\n```js\nlet a = {\n  a: 'aa',\n  b: 'bb',\n  c: 'cc'\n};\nfor (let k in a) {\n  console.log(k)\n}; // a b c\nfor (let k of a) {\n  console > log(k)\n}; // TypeError\n```\n\n### 跳出for...of\n\n使用 `break` 来实现.   \n\n```js\nfor (let k of a) {\n  if (k > 100)\n    break;\n  console.log(k);\n}\n```\n\n## Generator函数和应用\n\n### 14.1 基本概念\n`Generator` 函数是一种异步编程解决方案.   \n**原理**:  \n执行 `Genenrator` 函数会返回一个遍历器对象, 依次遍历 `Generator` 函数内部的每一个状态.  \n`Generator` 函数是一个普通函数, 有以下两个特征:  \n* `function`关键字与函数名之间有个星号; \n* 函数体内使用`yield`表达式, 定义不同状态; \n\n通过调用 `next` 方法, 将指针移向下一个状态, 直到遇到下一个 `yield` 表达式(或 `return` 语句)为止. 简单理解, `Generator` 函数分段执行, `yield` 表达式是暂停执行的标记, 而 `next` 恢复执行.   \n\n```js\nfunction* f() {\n  yield 'hi';\n  yield 'leo';\n  return 'ending';\n}\nlet a = f();\na.next(); // {value: 'hi', done : false}\na.next(); // {value: 'leo', done : false}\na.next(); // {value: 'ending', done : true}\na.next(); // {value: undefined, done : false}\n```\n\n### 14.2 yield表达式\n\n`yield` 表达式是暂停标志, 遍历器对象的 `next` 方法的运行逻辑如下:   \n1. 遇到`yield`就暂停执行，将这个`yield`后的表达式的值，作为返回对象的`value`属性值。  \n2. 下次调用`next`往下执行，直到遇到下一个`yield`。  \n3. 直到函数结束或者`return`为止，并返回`return`语句后面表达式的值，作为返回对象的`value`属性值。  \n4. 如果该函数没有`return`语句，则返回对象的`value`为`undefined` 。   \n\n `注意`\n\n* `yield`只能用在`Generator`函数里使用, 其他地方使用会报错.   \n\n```js\n// 错误1\n(function() {\n  yiled 1; // SyntaxError: Unexpected number\n})()\n\n// 错误2  forEach参数是个普通函数\nlet a = [1, [\n    [2, 3], 4\n  ],\n  [5, 6]\n];\nlet f = function*(i) {\n  i.forEach(function(m) {\n    if (typeof m !== 'number') {\n      yield* f(m);\n    } else {\n      yield m;\n    }\n  })\n}\nfor (let k of f(a)) {\n  console.log(k)\n}\n```\n\n* `yield`表达式如果用于另一个表达式之中, 必须放在**圆括号**内.   \n\n```js\nfunction* a() {\n  console.log('a' + yield); //  SyntaxErro\n  console.log('a' + yield 123); //  SyntaxErro\n  console.log('a' + (yield)); //  ok\n  console.log('a' + (yield 123)); //  ok\n}\n```\n\n* `yield`表达式用做函数参数或放在表达式右边, 可以**不加括号**.  \n\n```js\nfunction* a() {\n  f(yield 'a', yield 'b'); //  ok\n  lei i = yield; //  ok\n}\n```\n\n### 14.3 next方法\n\n`yield` 本身没有返回值, 或者是总返回 `undefined` , `next` 方法可带一个参数, 作为上一个 `yield` 表达式的返回值.  \n\n```js\nfunction* f() {\n  for (let k = 0; true; k++) {\n    let a = yield k;\n    if (a) {\n      k = -1\n    };\n  }\n}\nlet g = f();\ng.next(); // {value: 0, done: false}\ng.next(); // {value: 1, done: false}\ng.next(true); // {value: 0, done: false}\n```\n\n这一特点, 可以让 `Generator` 函数开始执行之后, 可以从外部向内部注入不同值, 从而调整函数行为.  \n\n```js\nfunction* f(x) {\n  let y = 2 * (yield(x + 1));\n  let z = yield(y / 3);\n  return (x + y + z);\n}\nlet a = f(5);\na.next(); // {value : 6 ,done : false}\na.next(); // {value : NaN ,done : false}  \na.next(); // {value : NaN ,done : true}\n// NaN因为yeild返回的是对象 和数字计算会NaN\n\nlet b = f(5);\nb.next(); // {value : 6 ,done : false}\nb.next(12); // {value : 8 ,done : false}\nb.next(13); // {value : 42 ,done : false}\n// x 5 y 24 z 13\n```\n\n### 14.4 for...of循环\n\n`for...of` 循环会自动遍历, 不用调用 `next` 方法, 需要注意的是, `for...of` 遇到 `next` 返回值的 `done` 属性为 `true` 就会终止, `return` 返回的不包括在 `for...of` 循环中.   \n\n```js\nfunction* f() {\n  yield 1;\n  yield 2;\n  yield 3;\n  yield 4;\n  return 5;\n}\nfor (let k of f()) {\n  console.log(k);\n}\n// 1 2 3 4  没有 5 \n```\n\n### 14.5 Generator.prototype.throw()\n\n`throw` 方法用来向函数外抛出错误, 并且在Generator函数体内捕获.   \n\n```js\nlet f = function*() {\n  try {\n    yield\n  } catch (e) {\n    console.log('内部捕获', e)\n  }\n}\n\nlet a = f();\na.next();\n\ntry {\n  a.throw('a');\n  a.throw('b');\n} catch (e) {\n  console.log('外部捕获', e);\n}\n// 内部捕获 a\n// 外部捕获 b\n```\n\n### 14.6 Generator.prototype.return()\n\n`return` 方法用来返回给定的值, 并结束遍历Generator函数, 如果 `return` 方法没有参数, 则返回值的 `value` 属性为 `undefined` .   \n\n```js\nfunction* f() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\nlet g = f();\ng.next(); // {value : 1, done : false}\ng.return('leo'); // {value : 'leo', done \" true}\ng.next(); // {value : undefined, done : true}\n```\n\n### 14.7 next()/throw()/return()共同点\n\n相同点就是都是用来恢复Generator函数的执行, 并且使用不同语句替换 `yield` 表达式.  \n* `next()`将`yield`表达式替换成一个值.  \n\n```js\nlet f = function*(x, y) {\n  let r = yield x + y;\n  return r;\n}\nlet g = f(1, 2);\ng.next(); // {value : 3, done : false}\ng.next(1); // {value : 1, done : true}\n// 相当于把 let r = yield x + y;\n// 替换成 let r = 1;\n```\n\n* `throw()`将`yield`表达式替换成一个`throw`语句.  \n\n```js\ng.throw(new Error('报错')); // Uncaught Error:报错\n// 相当于将 let r = yield x + y\n// 替换成 let r = throw(new Error('报错'));\n```\n\n* `next()`将`yield`表达式替换成一个`return`语句.  \n\n```js\ng.return(2); // {value: 2, done: true}\n// 相当于将 let r = yield x + y\n// 替换成 let r = return 2;\n```\n\n### 14.8 yield* 表达式\n\n用于在一个Generator中执行另一个Generator函数, 如果没有使用 `yield*` 会没有效果.     \n\n```js\nfunction* a() {\n  yield 1;\n  yield 2;\n}\n\nfunction* b() {\n  yield 3;\n  yield* a();\n  yield 4;\n}\n// 等同于\nfunction* b() {\n  yield 3;\n  yield 1;\n  yield 2;\n  yield 4;\n}\nfor (let k of b()) {\n  console.log(k)\n}\n// 3\n// 1\n// 2\n// 4\n```\n\n### 14.9 应用场景\n\n1. **控制流管理**  \n\n解决回调地狱:   \n\n```js\n// 使用前\nf1(function(v1) {\n  f2(function(v2) {\n    f3(function(v3) {\n      // ... more and more\n    })\n  })\n})\n\n// 使用Promise \nPromise.resolve(f1)\n  .then(f2)\n  .then(f3)\n  .then(function(v4) {\n    // ...\n  }, function(err) {\n    // ...\n  }).done();\n\n// 使用Generator\nfunction* f(v1) {\n  try {\n    let v2 = yield f1(v1);\n    let v3 = yield f1(v2);\n    let v4 = yield f1(v3);\n    // ...\n  } catch (err) {\n    // console.log(err)\n  }\n}\n\nfunction g(task) {\n  let obj = task.next(task.value);\n  // 如果Generator函数未结束，就继续调用\n  if (!obj.done) {\n    task.value = obj.value;\n    g(task);\n  }\n}\ng(f(initValue));\n```\n\n2. **异步编程的使用** \n\n在真实的异步任务封装的情况:   \n\n```js\nlet fetch = require('node-fetch');\n\nfunction* f() {\n  let url = 'http://www.baidu.com';\n  let res = yield fetch(url);\n  console.log(res.bio);\n}\n// 执行该函数\nlet g = f();\nlet result = g.next();\n// 由于fetch返回的是Promise对象，所以用then\nresult.value.then(function(data) {\n  return data.json();\n}).then(function(data) {\n  g.next(data);\n})\n```\n\n## Class语法和继承\n\n### 介绍\nES6中的 `class` 可以看作只是一个语法糖, 绝大部分功能都可以用ES5实现, 并且, **类和模块的内部, 默认就是严格模式, 所以不需要使用use strict指定运行模式**.   \n\n```js\n// ES5\nfunction P(x, y) {\n  this.x = x;\n  this.y = y;\n}\nP.prototype.toString = function() {\n  return '(' + this.x + ', ' + this.y + ')';\n};\nvar a = new P(1, 2);\n\n// ES6\nclass P {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\nlet a = new P(1, 2);\n```\n\n**值得注意**:\n\nES6的**类**的所有方法都是定义在 `prototype` 属性上, 调用类的实例的方法, 其实就是调用原型上的方法.      \n\n```js\nclass P {\n  constructor() {\n    ...\n  }\n  toString() {\n    ...\n  }\n  toNumber() {\n    ...\n  }\n}\n// 等同于\nP.prototyoe = {\n  constructor() {\n    ...\n  },\n  toString() {\n    ...\n  },\n  toNumber() {\n    ...\n  }\n}\n\nlet a = new P();\na.constructor === P.prototype.constructor; // true\n```\n\n类的属性名可以使用**表达式**:   \n\n```js\nlet name = 'leo';\nclass P {\n  constructor() {\n      ...\n    }\n    [name]() {\n      ...\n    }\n}\n```\n\n**Class不存在变量提升**:\n\nES6中的类不存在变量提升, 与ES5完全不同:   \n\n```js\nnew P(); // ReferenceError\nclass P {\n  ...\n};\n```\n\n**Class的name属性**:   \n\n`name` 属性总是返回紧跟在 `class` 后的类名.   \n\n```js\nclass P {}\nP.name; // 'P'\n```\n\n### constructor()方法\n\n`constructor()` 是类的默认方法, 通过 `new` 实例化时自动调用执行, 一个类必须有 `constructor()` 方法, 否则一个空的 `constructor()` 会默认添加.  \n`constructor()` 方法默认返回实例对象(即 `this` ).     \n\n```js\nclass P {\n  ...\n}\n// 等同于\nclass P {\n  constructor() {\n    ...\n  }\n}\n```\n\n### 类的实例对象\n\n与ES5一样, ES6的类必须使用 `new` 命令实例化, 否则报错.   \n\n```js\nclass P {\n  ...\n}\nlet a = P(1, 2); // 报错\nlet b = new P(1, 2); // 正确\n```\n\n与 ES5 一样, 实例的属性除非显式定义在其本身(即定义在 `this` 对象上), 否则都是定义在原型上(即定义在 `class` 上).\n\n```js\nclass P {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\nvar point = new Point(2, 3);\n\npoint.toString() // (2, 3)\n\npoint.hasOwnProperty('x') // true\npoint.hasOwnProperty('y') // true\npoint.hasOwnProperty('toString') // false \npoint.__proto__.hasOwnProperty('toString') // true\n// toString是原型对象的属性（因为定义在Point类上）\n```\n\n### Class表达式\n\n与函数一样, 类也可以使用表达式来定义, 使用表达式来作为类的名字, 而 `class` 后跟的名字, 用来指代当前类, 只能再Class内部使用.   \n\n```js\nlet a = class P {\n  get() {\n    return P.name;\n  }\n}\n\nlet b = new a();\nb.get(); // P\nP.name; // ReferenceError: P is not defined\n```\n\n如果类的内部没用到的话, 可以省略 `P` , 也就是可以写成下面的形式.   \n\n```js\nlet a = class {\n  ...\n}\n```\n\n### 私有方法和私有属性\n\n由于ES6不提供, 只能变通来实现:   \n* 1. 使用命名加以区别, 如变量名前添加`_`, 但是不保险, 外面也可以调用到.   \n\n```js\nclass P {\n  // 公有方法\n  f1(x) {\n    this._x(x);\n  }\n  // 私有方法\n  _x(x) {\n    return this.y = x;\n  }\n}\n```\n\n* 2. 将私有方法移除模块, 再在类内部调用`call`方法.   \n\n```js\nclass P {\n  f1(x) {\n    f2.call(this, x);\n  }\n}\n\nfunction f2(x) {\n  return this.y = x;\n}\n```\n\n* 3. 使用`Symbol`为私有方法命名.   \n\n```js\nconst a1 = Symbol('a1');\nconst a2 = Symbol('a2');\nexport default class P {\n  // 公有方法\n  f1(x) {\n    this[a1](x);\n  }\n  // 私有方法\n  [a1](x) {\n    return this[a2] = x;\n  }\n}\n```\n\n### this指向问题\n\n类内部方法的 `this` 默认指向类的实例, 但单独使用该方法可能报错, 因为 `this` 指向的问题.  \n\n```js\nclass P {\n  leoDo(thing = 'any') {\n    this.print(`Leo do ${thing}`)\n  }\n  print(text) {\n    console.log(text);\n  }\n}\nlet a = new P();\nlet {\n  leoDo\n} = a;\nleoDo(); // TypeError: Cannot read property 'print' of undefined\n// 问题出在 单独使用leoDo时，this指向调用的环境，\n// 但是leoDo中的this是指向P类的实例，所以报错\n```\n\n**解决方法**:  \n\n* 1. 在类里面绑定`this`   \n\n```js\nclass P {\n  constructor() {\n    this.name = this.name.bind(this);\n  }\n}\n```\n\n* 2. 使用箭头函数\n\n```js\nclass P {\n  constructor() {\n    this.name = (name = 'leo') => {\n      this.print(`my name is ${name}`)\n    }\n  }\n}\n```\n\n### Class的getter和setter\n\n使用 `get` 和 `set` 关键词对属性设置取值函数和存值函数, 拦截属性的存取行为.   \n\n```js\nclass P {\n  constructor() {\n    ...\n  }\n  get f() {\n    return 'getter';\n  }\n  set f(val) {\n    console.log('setter: ' + val);\n  }\n}\n\nlet a = new P();\na.f = 100; // setter : 100\na.f; // getter\n```\n\n### Class的generator方法\n\n只要在方法之前加个( `*` )即可.   \n\n```js\nclass P {\n  constructor(...args) {\n      this.args = args;\n    }\n    *[Symbol.iterator]() {\n      for (let arg of this.args) {\n        yield arg;\n      }\n    }\n}\nfor (let k of new P('aa', 'bb')) {\n  console.log(k);\n}\n// 'aa'\n// 'bb'\n```\n\n### Class的静态方法\n\n由于类相当于实例的原型, 所有类中定义的方法都会被实例继承, 若不想被继承, 只要加上 `static` 关键字, 只能通过类来调用, 即\"**静态方法**\".   \n\n```js\nclass P() {\n  static f1() {\n    return 'aaa'\n  };\n}\nP.f1(); // 'aa'\nlet a = new P();\na.f1(); // TypeError: a.f1 is not a function\n```\n\n如果静态方法包含 `this` 关键字, 则 `this` 指向类, 而不是实例.   \n\n```js\nclass P {\n  static f1() {\n    this.f2();\n  }\n  static f2() {\n    console.log('aaa');\n  }\n  f2() {\n    console.log('bbb');\n  }\n}\nP.f2(); // 'aaa'\n```\n\n并且静态方法可以被子类继承, 或者 `super` 对象中调用.   \n\n```js\nclass P {\n  static f1() {\n    return 'leo'\n  };\n}\nclass Q extends P {\n  ...\n};\nQ.f1(); // 'leo'\n\nclass R extends P {\n  static f2() {\n    return super.f1() + ',too';\n  }\n}\nR.f2(); // 'leo , too'\n```\n\n### Class的静态属性和实例属性\n\nES6中明确规定, Class内部只有静态方法没有静态属性, 所以只能通过下面实现.   \n\n```js\n// 正确写法\nclass P {}\nP.a1 = 1;\nP.a1; // 1\n\n// 无效写法\nclass P {\n  a1: 2, // 无效\n    static a1: 2, // 无效\n}\nP.a1; // undefined\n```\n\n**新提案来规定实例属性和静态属性的新写法**   \n* 1. 类的实例属性   \n类的实例属性可以用等式, 写入类的定义中.  \n\n```js\nclass P {\n  prop = 100; // prop为P的实例属性 可直接读取\n  constructor() {\n    console.log(this.prop); // 100\n  }\n}\n```\n\n有了新写法后, 就可以不再 `contructor` 方法里定义.  \n\n为了可读性的目的, 对于那些在 `constructor` 里面已经定义的实例属性, 新写法允许**直接列出**.   \n\n```js\n// 之前写法：\nclass RouctCounter extends React.Component {\n  constructor(prop) {\n    super(prop);\n    this.state = {\n      count: 0\n    }\n  }\n}\n\n// 新写法\nclass RouctCounter extends React.Component {\n  state;\n  constructor(prop) {\n    super(prop);\n    this.state = {\n      count: 0\n    }\n  }\n\n}\n```\n\n* 2. 类的静态属性   \n只要在实例属性前面加上 `static` 关键字就可以.   \n\n```js\nclass P {\n  static prop = 100;\n  constructor() {\n    console.log(this.prop)\n  }; // 100\n}\n```\n\n新写法方便静态属性的表达.   \n\n```js\n// old \nclass P {\n  ....\n}\nP.a = 1;\n\n// new \nclass P {\n  static a = 1;\n}\n```\n\n### Class的继承\n\n主要通过 `extends` 关键字实现, 继承父类的所有属性和方法, 通过 `super` 关键字来新建父类构造函数的 `this` 对象.   \n\n```js\nclass P {\n  ...\n}\nclass Q extends P {\n  ...\n}\n\nclass P {\n  constructor(x, y) {\n    // ...\n  }\n  f1() {\n    ...\n  }\n}\nclass Q extends P {\n  constructor(a, b, c) {\n    super(x, y); // 调用父类 constructor(x, y)\n    this.color = color;\n  }\n  f2() {\n    return this.color + ' ' + super.f1();\n    // 调用父类的f1()方法\n  }\n}\n```\n\n**子类必须在 `constructor()` 调用 `super()` 否则报错**, 并且只有 `super` 方法才能调用父类实例, 还有就是, **父类的静态方法, 子类也可以继承到**.    \n\n```js\nclass P {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  static fun() {\n    console.log('hello leo')\n  }\n}\n// 关键点1 调用super\nclass Q extends P {\n  constructor() {\n    ...\n  }\n}\nlet a = new Q(); // ReferenceError 因为Q没有调用super\n\n// 关键点2 调用super\nclass R extends P {\n  constructor(x, y.z) {\n    this.z = z; // ReferenceError 没调用super不能使用\n    super(x, y);\n    this.z = z; // 正确\n  }\n}\n\n// 关键点3 子类继承父类静态方法\nR.hello(); // 'hello leo'\n```\n\n**super关键字**:   \n既可以当函数使用, 还可以当对象使用.   \n* 1. 当函数调用, 代表父类的构造函数, 但必须执行一次.  \n\n```js\nclass P {\n  ...\n};\nclass R extends P {\n  constructor() {\n    super();\n  }\n}\n```\n\n* 2. 当对象调用, 指向原型对象, 在静态方法中指向父类.   \n\n```js\nclass P {\n  f() {\n    return 2\n  };\n}\nclass R extends P {\n  constructor() {\n    super();\n    console.log(super.f()); // 2\n  }\n}\nlet a = new R()\n```\n\n`注意` : `super` 指向父类原型对象, 所以定义在父类实例的方法和属性, 是无法通过 `super` 调用的, 但是通过调用 `super` 方法可以把内部 `this` 指向当前实例, 就可以访问到.   \n\n```js\nclass P {\n  constructor() {\n    this.a = 1;\n  }\n  print() {\n    console.log(this.a);\n  }\n}\nclass R extends P {\n  get f() {\n    return super.a;\n  }\n}\nlet b = new R();\nb.a; // undefined 因为a是父类P实例的属性\n\n// 先调用super就可以访问\nclass Q extends P {\n  constructor() {\n    super(); // 将内部this指向当前实例\n    return super.a;\n  }\n}\nlet c = new Q();\nc.a; // 1\n\n// 情况3\nclass J extends P {\n  constructor() {\n    super();\n    this.a = 3;\n  }\n  g() {\n    super.print();\n  }\n}\nlet c = new J();\nc.g(); // 3  由于执行了super()后 this指向当前实例\n```\n\n## Module语法和加载实现\n\n### 介绍\nES6之前用于JavaScript的模块加载方案, 是一些社区提供的, 主要有 `CommonJS` 和 `AMD` 两种, 前者用于**服务器**, 后者用于**浏览器**.   \nES6提供了模块的实现, 使用 `export` 命令对外暴露接口, 使用 `import` 命令输入其他模块暴露的接口.   \n\n```js\n// CommonJS模块\nlet {\n  stat,\n  exists,\n  readFire\n} = require('fs');\n\n// ES6模块\nimport {\n  stat,\n  exists,\n  readFire\n} = from 'fs';\n```\n\n### 严格模式\n\nES6模块自动采用严格模式, 无论模块头部是否有 `\"use strict\"` .  \n**严格模式有以下限制**:   \n* 变量必须**声明后再使用**\n* 函数的参数**不能有同名属性**, 否则报错\n* 不能使用`with`语句\n* 不能对只读属性赋值, 否则报错\n* 不能使用前缀 0 表示八进制数, 否则报错\n* 不能删除不可删除的属性, 否则报错\n* 不能删除变量`delete prop`, 会报错, 只能删除属性`delete * global[prop]`\n* `eval`不会在它的外层作用域引入变量\n* `eval`和`arguments`不能被重新赋值\n* `arguments`不会自动反映函数参数的变化\n* 不能使用`arguments.callee`\n* 不能使用`arguments.caller`\n* 禁止`this`指向全局对象\n* 不能使用`fn.caller`和`fn.arguments`获取函数调用的堆栈\n* 增加了保留字(比如`protected`、`static`和`interface`)\n\n特别是, ES6中顶层 `this` 指向 `undefined` , 即不应该在顶层代码使用 `this` .  \n\n### export命令\n\n使用 `export` 向模块外暴露接口, 可以是方法, 也可以是变量.   \n\n```js\n// 1. 变量\nexport let a = 'leo';\nexport let b = 100;\n\n// 还可以\nlet a = 'leo';\nlet b = 100;\nexport {\n  a,\n  b\n};\n\n// 2. 方法\nexport function f(a, b) {\n  return a * b;\n}\n\n// 还可以\nfunction f1() {\n  ...\n}\n\nfunction f2() {\n  ...\n}\nexport {\n  a1 as f1,\n  a2 as f2\n}\n```\n\n可以使用 `as` 重命名函数的对外接口.  \n**特别注意**:  \n`export` 暴露的必须是接口, 不能是值.  \n\n```js\n// 错误\nexport 1; // 报错\n\nlet a = 1;\nexport a; // 报错\n\n// 正确\nexport let a = 1; // 正确\n\nlet a = 1;\nexport {\n  a\n}; // 正确\n\nlet a = 1;\nexport {\n  a as b\n}; // 正确\n```\n\n暴露方法也是一样:   \n\n```js\n// 错误\nfunction f() {\n  ...\n};\nexport f;\n\n// 正确\nexport function f() {\n  ...\n};\n\nfunction f() {\n  ...\n};\nexport {\n  f\n};\n```\n\n### import命令\n\n加载 `export` 暴露的接口, 输出为变量.   \n\n```js\nimport {\n  a,\n  b\n} from '/a.js';\n\nfunction f() {\n  return a + b;\n}\n```\n\n`import` 后大括号指定变量名, 需要与 `export` 的模块暴露的名称一致.    \n也可以使用 `as` 为输入的变量重命名.   \n\n```js\nimport {\n  a as leo\n} from './a.js';\n```\n\n`import` 不能直接修改输入变量的值, 因为输入变量只读只是个接口, 但是如果是个对象, 可以修改它的属性.  \n\n```js\n// 错误\nimport {\n  a\n} from './f.js';\na = {}; // 报错\n\n// 正确\na.foo = 'leo'; // 不报错\n```\n\n`import` 命令具有提升效果, 会提升到整个模块头部最先执行, 且多次执行相同 `import` 只会执行一次.\n\n### 模块的整体加载\n\n当一个模块暴露多个方法和变量, 引用时可以用 `*` 整体加载.   \n\n```js\n// a.js\nexport function f() {\n  ...\n}\nexport function g() {\n  ...\n}\n\n// b.js\nimport * as obj from '/a.js';\nconsole.log(obj.f());\nconsole.log(obj.g());\n```\n\n但是, 不允许运行时改变:   \n\n```js\nimport * as obj from '/a.js';\n// 不允许\nobj.a = 'leo';\nobj.b = function() {\n  ...\n};\n```\n\n### export default 命令\n\n使用 `export default` 命令, 为模块指定默认输出, 引用的时候直接指定任意名称即可.  \n\n```js\n// a.js\nexport default function() {\n  console.log('leo')\n};\n\n// b.js\nimport leo from './a.js';\nleo(); // 'leo'\n```\n\n`export default` 暴露有函数名的函数时, 在调用时相当于匿名函数.   \n\n```js\n// a.js\nexport default function f() {\n  console.log('leo')\n};\n// 或者\nfunction f() {\n  console.log('leo')\n};\nexport default f;\n\n// b.js\nimport leo from './a.js';\n```\n\n`export default` 其实是输出一个名字叫 `default` 的变量, 所以后面不能跟变量赋值语句.  \n\n```js\n// 正确\nexport let a = 1;\n\nlet a = 1;\nexport default a;\n\n// 错误\nexport default\nlet a = 1;\n```\n\n`export default` 命令的本质是将后面的值, 赋给 `default` 变量, 所以可以直接将一个值写在 `export default` 之后.   \n\n```js\n// 正确\nexport detault 1;\n// 错误\nexport 1;\n```\n\n### export 和 import 复合写法\n\n常常在先输入后输出同一个模块使用, 即转发接口, 将两者写在一起.   \n\n```js\nexport {\n  a,\n  b\n}\nfrom './leo.js';\n\n// 理解为\nimport {\n  a,\n  b\n} from './leo.js';\nexport {\n  a,\n  b\n}\n```\n\n常见的写法还有:   \n\n```js\n// 接口改名\nexport {\n  a as b\n}\nfrom './leo.js';\n\n// 整体输出\nexport * from './leo.js';\n\n// 默认接口改名\nexport {\n  default as a\n}\nfrom './leo.js';\n```\n\n**常常用在模块继承**.  \n\n### 浏览器中的加载规则\n\nES6中, 可以在浏览器使用 `<script>` 标签, 需要加入 `type=\"module\"` 属性, 并且这些都是异步加载, 避免浏览器阻塞, 即等到整个页面渲染完, 再执行模块脚本, 等同于打开了 `<script>` 标签的 `defer` 属性.   \n\n```html\n<script type=\"module\" src=\"./a.js\"></script>\n```\n\n另外, ES6模块也可以内嵌到网页, 语法与外部加载脚本一致:   \n\n```html\n<script type=\"module\">\n  import a from './a.js';\n</script>\n```\n\n`注意点` :  \n* 代码是在模块作用域之中运行, 而不是在全局作用域运行. 模块内部的顶层变量, 外部不可见.\n* 模块脚本自动采用严格模式, 不管有没有声明`use strict`.\n* 模块之中, 可以使用`import`命令加载其他模块(`.js`后缀不可省略, 需要提供`绝对 UR`L 或`相对 UR`L), 也可以使用`export`命令输出对外接口.\n* 模块之中, 顶层的`this`关键字返回`undefined`, 而不是指向`window`. 也就是说, 在模块顶层使用`this`关键字, 是无意义的.\n* 同一个模块如果加载多次, 将只执行一次.\n","categories":["web","Javascript"]},{"title":"Java知识整理-方法重载,递归","url":"/posts/12626/","content":"\n## 方法的重载\n\n### 好处\n\n- 减少方法名称的记忆\n- 可以忽略参数的自动类型转换\n\n### 定义\n\n> 方法的重载是指一个类中定义了多个相同名字的方法，需要每个方法具有不同的参数类型或者参数类型的相同个数不同，调用的时候可以根据该方法的参数类型或者个数类型区分对应的方法;方法的重载和返回值类型，修饰词没有关系\n\n### 适用场景\n\n> 当一个类中出现相同的功能时,但是需要的参数不同 参数 类型不同 个数不同\n\n### 要求\n\n1. 必须在同一个类中\n2. 方法名的相同\n3. 参数列表不同 (不同型 同型不同个 顺序)\n4. 返回值不同\n\n## 递归\n\n1. 在调用过程中不断的调用自己\n\n{% folding red, 查看解析 %}\n\n```java\npublic class text5 {\n    public static void main(String[] args){\n        int a = 1;\n        System.out.println(add(a));\n    }\n    static int add(int a){\n        return a==5?5:a+add(a+1);\n    }\n}\n```\n{% endfolding %}\n\n## 斐波那契\n\n{% folding red, java %}\n```java\npublic class text7 {\n    public static void main(String[] args) {\n        System.out.println(\"请月份数：\");\n        Scanner s = new Scanner(System.in);\n        int n = s.nextInt();\n        System.out.println(\"第\" + n + \"个数：\" + f(n));\n//        for (int n=1;n<50;n++){\n//            System.out.println(\"第\"+n+\"个数：\" + f(n));\n//        }\n    }\n    public static long f(int n) {\n        return n==1 || n==2 ? 1 : f(n - 1) + f(n - 2);\n    }\n}\n```\n{% endfolding %}\n\n{% folding red, python %}\n\n```python\n# -*- coding:utf-8 -*-\ndef f(n):\n    return n if n < 2 else f(n - 1) + f(n - 2)\nif __name__ == '__main__':\n    num = input('请输入:')\n    print(f(int(num)))\n```\n{% endfolding %}\n\n### 进制转换\n\n1. 思路: 将输入数除2判断 商是否等于0 如果等于0则终止返回，不等于0 返回余数+方法*10 每次执行方法返回的值都要乘10 最后将每次计算的都加起来\n\n{% folding red, 查看解析 %}\n\n```java\n//十进制准换二进制\nimport java.util.Scanner;\npublic class text9 {\n    public static void main(String[] args) {\n        System.out.println(\"请输入十进制数：\");\n        Scanner sc = new Scanner(System.in);\n        int num = sc.nextInt();\n        System.out.println(toBin(num));\n    }\n    static int toBin(int num) {\n        return num == 0 ? 0 : num % 2 + toBin(num / 2) * 10;\n    }\n}\n```\n{% endfolding %}\n\n## 面向对象\n\n1. 封装 权限 访问接口\n2. 继承 原有的基础之上扩展性 兼容 单继承\n3. 多态 符合规则的继续大范围扩展 向上造型 向下造型\n4. 抽象\n\n## 类和对象的概念\n\n1. 对象: 实际存在的事物\n2. 类: 实际存在的事物进行抽象形成的模板,描述对象的共同特征\n\n### 对象的创建和使用\n\n1. 类定义之后，就有了模板 模板可以创建对象 了可以创建任意多个对象\n2. 创建类 new 构造方法()\n3. 如果想使用创建的对象 需要使用变量来承接\n4. 不赋值有默认值，主动赋值默认值消失\n\n## JVM内存管理\n\n1. 栈: 先进后出 （在程序运行的过程中存放局部变量和运行中的方法）线性地址连续\n2. 方法区：已被加载的类信息，常量，静态变量;\n3. 堆: 虚拟机启动的时候,创建堆;存放对象;地址可以不连续\n4. c语言中指针是操作存储空间 java不可以操作堆地址 只能使用堆中的信息，栈中引用是指是对象的地址;打印出来的不是地址，这个变量是基本类型局部变量\n\n{% folding red, JVM %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/api/zhan.png)\n{% endfolding %}\n\n## 构造方法Constructor\n\n1. 定义: 构造方法是类中一种特殊的方法，通过构造方法可以完成对象的创建，以及对象属性的初始化操作\n2. 修饰词 类名(参数列表){方法体}`构造方法没有返回值类型`，`构造方法的方法名和类名相同`, `构造方法同来创建对象，并且为对象初始化实例变量`,`一个类中可以定义多个构造方法，需要符合方法的重载`，`实质是有返回值，返回值类型是类`，`类中不写构造方法，默认系统会自动生成一个无参构造方法`\n\n### 作用\n\n1. 创建对象\n2. 初始化对象（方法中必须赋值）\n\n{% folding red, 查看解析 %}\n\n```java\npublic class text5 {\n\tint year;\n\tint month;\n\tint day;\n\tpublic text5(int y, int m, int d) {\n\t\t// TODO 自动生成的构造函数存根\n\t\tyear = y;\n\t\tmonth = m;\n\t\tday = d;  // 就近原则this\n\t}\n\tvoid show() {\n\t\tSystem.out.println(year + \"-\" + month + \"-\" + day);\n\t}\n}\n\n// 构造方法\npublic class text6 {\n\tpublic static void main(String[] args) {\n\t\t// TODO 自动生成的方法存根\n//\t\t创建日期对象\n\t\ttext5 d5 = new text5(2021,7,22);\n\t\td5.show();\n\t\tSystem.out.print(\"------------\");\n\t}\n}\n\n```\n{% endfolding %}\n\n### 方法的重載\n\n1. 构造方法也有方法的重载\n\n## 空指针异常\n\n1. 引用为空\n2. 引用对象=> 空指针错误 `java.lang.NullPointerException`\n\n\n{% folding red, 查看解析 %}\n\n```java\npackage demo1;\npublic class text10 {\n\tpublic static void main(String[] args) {\n\t\ttext8 d = new text8(2000,10,2);\n\t\ttext9 t9 = new text9();\n\t\ttext8 w = new text8();\n\t\tw.year = 1999;\n\t\tw.month = 5;\n\t\tw.day = 4;\n\t\tt9.name = \"张三\";\n\t\tt9.id = \"001\";\n\t\tt9.birth = d;\n\t\tWife n = new Wife(\"李四\",\"002\",w);\n\t\tSystem.out.println(n.birth.ShowDate());\n\t\tSystem.out.println(t9.birth.ShowDate());\n\t}\n}\n//\npackage demo1;\n\npublic class text8 {\n\tint year;\n\tint month;\n\tint day;\n\t\n\tpublic text8() {\n\t\t// TODO 自动生成的构造函数存根\n\t\t\n\t}\n\ttext8(int y,int m, int d){\n\t\tyear=y;\n\t\tmonth=m;\n\t\tday=d;\n//\t\tSystem.out.println(ShowDate());\n\t}\n\tString ShowDate(){\n\t\treturn year+\"-\"+month+\"-\"+day;\n\t}\n}\n//\npackage demo1;\n\npublic class text9 {\n\tString name;\n\tString id;\n\ttext8 birth;\n\tpublic text9() {\n\t\t// TODO 自动生成的构造函数存根\n\t}\n}\n//\npackage demo1;\n\npublic class Wife {\n\tString name;\n\tString id;\n\ttext8 birth;\n\tpublic Wife() {\n\t\t// TODO 自动生成的构造函数存根\n\t}\n\tpublic Wife(String string, String string2, text8 d) {\n\t\t// TODO 自动生成的构造函数存根\n\t\tname = string;\n\t\tid = string2;\n\t\tbirth = d;\n\t}\n}\n\n```\n{% endfolding %}\n\n## 封装\n\n1. 在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法\n\n- 封装的优点\n1. 良好的封装能够减少耦合。\n2. 类内部的结构可以自由修改。\n3. 可以对成员变量进行更精确的控制。\n4. 隐藏信息，实现细节。\n\n2. 提供公共的入口 使用`set`修改 和 `get`访问 方法\n\n{% folding red, 查看解析 %}\n\n```java\npublic class Product {\n\tprivate int pro_id;\n\tprivate String pro_name;\n\tprivate int pro_price;\n\tpublic Product() {\n\t\t// TODO 自动生成的构造函数存根\n\t}\n//\t设置\n\tpublic void setId(int i) {\n\t\tpro_id = i;\n\t}\n\tpublic void setName(String i) {\n\t\tpro_name = i;\n\t}\n\tpublic void setPrice(int i) {\n\t\tpro_price = i;\n\t}\n//\t查看\n\tpublic int getId() {\n\t\treturn pro_id;\n\t}\n\tpublic String getName() {\n\t\treturn pro_name;\n\t}\n\tpublic int getPrice() {\n\t\treturn pro_price;\n\t}\n//\t有参封装\n\tProduct(int i,String n,int p){\n\t\tpro_id = i;\n\t\tpro_name = n;\n\t\tpro_price = p;\n\t}\n//\t返回所有的情况\n\tString ShowProduct(){\n\t\treturn \"商品id为：\"+pro_id+\"\\n商品名称为：\"+pro_name+\"\\n商品价格为\"+pro_price;\n\t}\n}\n\n// 调用\npublic class Build {\n\tpublic static void main(String[] args) {\n\t\tProduct p1 = new Product();\n\t\tp1.setId(1);\n\t\tp1.setName(\"手机\");\n\t\tp1.setPrice(12000);\n\t\tProduct p2 = new Product(2,\"电脑\",22222);\n\t\tSystem.out.println(p2.ShowProduct());\n\t\tSystem.out.println(p1.getPrice());  // 获取单个商品的信息 使用get方法\n\t\tSystem.out.println(p2.ShowProduct());\n\t}\n}\n\n```\n{% endfolding %}\n\n## this 关键字\n\n1. this本质是对象的地址，this关键字指向的是当前对象的引用\n2. this 内容相同 每个this指向对象的地址  都在堆中\n3. 本质就是一个变量或者引用，存储在对象的内部\n4. this本身的内容就是该对象的地址值\n5. this关键字来区分局部变量和实例变量。\n6. 在构造方法中 使用`this() = new 构造方法` 只能在构造方法中的第一行使用\n\n","categories":["java"]},{"title":"论文降重方法-web/python/exe","url":"/posts/644213/","content":"\n## 降重原理\n\n- 利用百度翻译通用API在不通语言间转换，由于不通语言语序不通，转换后可有效降重。\n\n>中->英->德->中 (初级)\n>中->英->德->日->葡萄牙->中 (中级)\n>中->英->德->日->葡萄牙->意大利->波兰->保加利亚->爱沙尼亚->中 (高级)\n\n## 效果图\n\n{% folding red, 查看解析 %}\n![](https://gitee.com/rbozo/picgo_image/raw/master/image/0/19da276d24b8cdc9c8c66402869f7c3.png)\n{% endfolding %}\n\n## web版本\n\n1. gitee地址 【[下载地址](https://gitee.com/rbozo/de-repeat/releases)】\n2. github地址 【[下载地址](https://github.com/Rr210/node-js/tree/master/de-repeat)】\n\n## 使用方法\n\n1. 去百度翻译API注册一个账号，并且进行高级认证\n2. 可获得每月200w字符的翻译量（开通通用型翻译）\n3. 输入appid和key即可使用\n\n## 预览图\n\n{% folding red, 查看解析 %}\n![](https://gitee.com/rbozo/picgo_image/raw/master/image/0/dfc17e62846b303b46cb119f82381b1.png)\n{% endfolding %}\n\n## python版本\n\n1. tkinter版\n{% folding red, 查看图例 %}\n![](https://gitee.com/rbozo/picgo_image/raw/master/image/0/9bd95e72f8abb3da8c3a455afd17b01.png)\n{% endfolding %}\n2. 地址【[下载地址](https://gitee.com/rbozo/de-repeat/tree/master/python)】\n\n## exe版本\n\n- 蓝奏云下载地址\n1. 【[蓝奏云](https://grr.lanzoui.com/b016ijf1g)】 密码:`cj7q`\n- gitte下载地址\n2. 【[derepeat.zip](https://gitee.com/rbozo/de-repeat/releases/)】","categories":["web","Javascript"]},{"title":"毛概考试复习资料-整合","url":"/posts/56656/","content":"\n## 党的建设理论。\n- 特别注重从思想上建党，理论和实践相结合的作风，和人民群众紧密地联系在一起的作风，以及自我批评的作风，是中国共产党区别于其他任何政党的显著标志。 \n\n## 毛泽东思想活的灵魂 \n- 毛泽东思想的活的灵魂，有三个基本方面，即`实事求是`，`群众路线`，`独立自主`。 \n- `实事求是`，就是一切从实际出发，理论联系实际，坚持在实践中检验真理和发展真理。\n  1. 坚持实事求是，就要深入实际了解事物的本来面貌，把握事物内在必然联系，按照客观规律办事。\n  2. 坚持实事求是，就要清醒认识和正确把握我国基本国情。 \n  3. 坚持实事求是，就要不断推进实践基础上的理论创新。 \n- `群众路线`，就是一切为了群众，一切依靠群众，从群众中来，到群众中去。把党的正确主张转变成为群众的自觉行动。\n  1. 坚持群众路线，就要坚持人民是推动历史发展的根本力量。 \n  2. 坚持群众路线，就要坚持全心全意为人民服务的根本宗旨。 \n  3. 坚持群众路线，就要保持党同人民群众的血肉联系。 \n- `独立自主`，就是坚持独立思考，走自己的路，就是坚定不移地维护民族独立、捍卫国家主权， 把立足点放在依靠自己力量的基础上，同时积极争取外援，开展国际经济文化交流，学习外国一切对我们有益的先进事物。 \n  1. 坚持独立自主，就要坚持中国的事情必须由中国人民自己处理。 \n  2. 坚持独立自主，就要坚持独立自主的和平外交政策，坚定不移走和平发展道路。 \n\n## 社会主义改造道路\n- 农业改造\n1. 积极引导农民组织起来，走互助合作道路。\n2. 遵循自愿互利，典型示范和国家帮助的原则，以互助合作的优越性吸引农民。\n3. 正确分析农村的阶级和阶层状况，指定正确的阶级政策。\n4. 坚持积极领导，稳步前进的方针，采取循序渐进的步骤。\n- 手工业\n1. 采取了积极领导，稳步前进的方针。\n- 资本主义工商业：\n1. 用和平赎买的方法改造\n2. 采取从低级到高级的国家资本主义的过渡形式\n3. 把资本主义工商业这改造成为自食其力的社会主义劳动者。\n\n## 社会主义改造的历史经验\n- 第一，坚持社会主义工业化建设与社会主义改造同时并举的方针，对保持社会稳定，促进生产力发展，逐步改善人民生活，推动社会进步都具有什么重要的意义。\n- 第二，采取积极引导，逐步过渡的方式，不仅没有对生产力的发展造成破坏，而且促进了生产力的发展。\n- 第三，用和平方法进行改造，不仅保证了我国社会主义改造的顺利进行，而且维护了社会的稳定，极大地促进了社会主义事业的发展。\n\n## 党在中国社会主义道路初步探索中取得了哪些重要的理论成果。 \n1. 《论十大关系》确定了一个基本方针，就是调动一切积极因素为社会主义事业服务。充 分调动一切积极因素，尽可能地克服消极因素，并且努力化消极因素为积极因素，是社会主义事业前进的现实需要。\n2. 中共八大上对中国国内矛盾和党的主要任务做出正确判断。毛泽东在《关于正确处理人民内部矛盾的问题》的报告中，系统论述了社会主义社会矛盾的理论。\n3. 正确认识和处理社会主义社会关系矛盾的思想是探索的深化和拓展。\n4. 党在探索社会主义建设道路过程中取得的重要理论成果，是毛泽东思想的重要组成部分，丰富和发展了科学社会主义理论，成为中国特色社会主义理论体系的重要思想来源。\n\n## 如何认识党对社会主义建设道路初步探索的重大意义？ \n- 巩固和发展了我国的社会主义制度。 为开创中国特色社会主义提供了宝贵经验、理论准备、物质基础。 丰富了科学社会主义的理论和实践。\n\n## 党对社会主义建设道路的初步探索有哪些经验教训？\n- 党对社会主义建设道路的初步探索，取得了巨大成就，积累了丰富的经验，同时也遭受过重大挫折，造成了严重后果，留下了深刻教训。 \n1. 第一，必须把马克思主义与中国实际相结合，探索符合中国特点的社会主义建设道路。 \n2. 第二，必须正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力。 \n3. 第三，必须从实际出发进行社会主义建设，建设规模和速度要和国力相适应，不能急于求成。 \n4. 第四，必须发展社会主义民主，健全社会主义法制。 \n5. 第五，必须坚持党的民主集中制和集体领导制度，加强执政党建设。 \n6. 第六，必须坚持对外开放，借鉴和吸收人类文明成果建设社会主义，不能关起门来搞建设。 社会主义建设道路初步探索的正反两方面经验，为今天坚持和发展中国特色社会主义提供了重要借鉴。\n\n## 邓小平理论的主要内容。\n- 围绕着“什么是社会主义、怎样建设社会主义”这个基本的理论问题，邓小平理论提出： 解放思想、实事求是的思想路线，社会主义初级阶段理论，党的基本路线，社会主义的根本任务，“三步走”战略，改革开放理论，社会主义市场经济理论，“两手抓，两手都要硬”，“一国两制”，中国问题的关键在于党，形成了一个比较完备的科学体系。\n\n## 邓小平关于社会主义本质的概括包括哪些内容？具有什么样的意义？ \n- 内容： 邓小平在南方谈话中对社会主义本质作了总结性理论概括:\"社会主义的本质， 是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕。\"\n- 邓小平关于社会主义本质的概括，遵循了科学社会主义的基本原则，反映了人民的利益和时代的要求，廓清了不合乎时代进步和社会发展规律的模糊观念，摆脱了长期以来拘泥于具体模糊观念而忽略社会主义本质的错误倾向，深化了对科学社会主义的认识。这对于我们在坚持社会主义基本制度的基础上推进改革，指导改革沿着合乎社会主义本质要求的方向发展，对于建设中国特色的社会主义，具有重大的政治意义、理论意义和实践意义。\n\n## 如何把握对三个代表重要思想的集中概括？（核心观点） \n1. 始终代表中国先进生产力的发展要求\n2. 始终代表中国先进文化的前进方向 \n3. 始终代表中国最广大人民的根本利益 \n\n## 三个代表重要思想的主要内容。\n1. 发展是党执政兴国的第一要务\n2. 建立社会主义市场经济体制\n3. 全面建设小康社会\n4. 建设社会主义政治文明\n5. 推进党的建设新的伟大工程\n\n## 科学发展观的内涵和主要内容（如何理解、把握、解读） \n- 科学发展观，第一要义是发展，核心立场是以人为本，基本要求是全面协调可持续，根本方法是统筹兼顾。这是对科学发展观的集中概括。 \n- 推动经济社会发展是科学发展观的第一要义 \n1. 坚持科学发展，必须加快转变经济发展方式。 \n2. 坚持科学发展，必须善于抓住和用好机遇\n- 以人为本是科学发展观的核心立场， 以人为本就是以最广大人民的根本利益为本。\n1. 坚持以人为本，就要坚持发展为了人民，始终把最广大人民的根本利益放在第一位 \n2. 坚持以人为本，就要坚持发展依靠人民， \n3. 坚持以人为本，就要坚持发展成果由人民共享，\n4. 坚持以人为本，最终是为了实现人的全面发展。 \n- 全面协调可持续是科学发展观的基本要求 \n1. 坚持全面发展，就是要按照中国特色社会主义事业总体布局，正确认识和把握经济建设、 政治建设、文化建设、社会建设、生态文明建设是相互联系、相互促进的有机统一体。\n2. 坚持协调发展，就是保证中国特色社会主义各个领域协调推进。\n3. 坚持可持续发展，必须走生产发展、生活富裕、生态良好的文明发展道路。\n4. 坚持可持续发展，还必须建设生态文明。 \n- 统筹兼顾是科学发展观的根本方法 深刻体现了唯物辩证法在发展问题上的科学运用，深刻揭示了实现科学发展、促进社会和谐的基本途径，是正确处理经济社会发展中重大关系的方针原则。\n1. 坚持统筹兼顾，必须正确认识和妥善处理中国特色社会主义事业中的重大关系。\n2. 坚持统筹兼顾，必须认真考虑和对待各方面的发展需要，正确反映和兼顾各阶层各群体利益要求。 \n3. 坚持统筹兼顾，要牢牢掌握统筹兼顾的科学思想方法，努力提高战略思维、创新思维、辩证思维能力，不断增强统筹兼顾的本领，更好地推动科学发展。 \n4. 坚持统筹兼顾，还要求我们既立足当前，又着眼长远，做到兼顾各方、综合平衡.\n\n## 科学发展观的主要内容\n1. 加快转变经济发展模式\n2. 发展社会主义民主政治\n3. 推进社会主义文化强国建设\n4. 构建社会主义和谐社会\n5. 推进生态文明建设\n6. 全面提高党的建设科学文化水平\n\n\n## 新时代的内涵和意义 \n1. 这个新时代是承前启后、继往开来，在新的历史条件下继续夺取中国特色社会主义伟大胜利的时代。 \n2. 是决胜全面建成小康社会、进而全面建设社会主义现代化强国的时代。 \n3. 是全国各族人民团结奋斗、不断创造美好生活、逐步实现全体人民共同富裕的时代。 \n4. 是全体中华儿女勠力同心、奋力实现中华民族伟大复兴中国梦的时代。 \n5. 是我国日益走近世界舞台中央、不断为人类作出更大贡献的时代。\n- 意义\n1. 从中华民族复兴的历史进程看，意味着近代以来久经磨难的中华民族迎来了从站起来、富起来到强起来的伟大飞跃，迎来了实现中华民族伟大复兴的光明前景。 \n2. 从科学社会主义发展进程看， 意味着科学社会主义在 21 世纪的中国焕发出强大生机活力，在世界上高高举起了中国特色社会主义伟大旗帜。 \n3. 从人类文明进程看，意味着中国特色社会主义道路、理论、制度、文化不断发展，拓展了发展中国家走向现代化的途径。\n\n## 如何理解中国梦？（提出 +内涵 +实现） \n- 习近平提出： “实现中华民族伟大复兴，就是中华民族近代以来最伟大的梦想。” \n- 科学内涵： \n1. 中国梦的本质是国家富强、民族振兴、人民幸福。 \n2. 国家富强、民族振兴是人民幸福的基础和保障；人民幸福是国家富强、民族振兴的题中之义和必然要求；人民幸福是国家富强、民族振兴的根本出发点和落脚点。 \n3. 中国梦是国家情怀、民族情怀、人民情怀相统一的梦。 \n4. 中国梦归根到底是人民的梦。人民是中国梦的主体，是中国梦的创造者和享有者。 \n5. 中国梦是国家的梦、民族的梦，也是每一个中国人的梦。 \n6. 中国梦与世界各国人民的美好梦想相通。中国梦不仅在国内引发强烈共鸣，而且在国际社会产生强烈反响。 \n- 奋力实现中国梦： 实现中国梦必须走中国道路、弘扬中国精神、凝聚中国力量。\n1. 实现中国梦必须走中国道路，这就是中国特色社会主义道路。 \n2. 实现中国梦必须弘扬中国精神，这就是以爱国主义为核心的民族精神和以改革创新为核心的时代精神。 \n3. 实现中国梦必须凝聚中国力量，这就是全国各族人民大团结的力量。 \n4. 实现中华民族伟大复兴是海内外中华儿女的共同梦想。 \n5. 实干才能梦想成真。实现中华民族伟大复兴，是一项光荣而艰巨的事业，需要每一个人付出艰苦努力，用实干托起中国梦。 \n6. 实现中国梦任重而道远，需要锲而不舍、驰而不息的艰苦努力。 \n7. 实现中国梦需要和平，只有和平才能实现梦想。\n\n\n## 贯彻新发展理念\n- 面对经济社会发展的新趋势、新机遇和新矛盾、新挑战，党的十八届五中全会坚持以人民为中心的发展思想，鲜明提出了创新、协调、绿色、开放、共享的新发展理念。 \n1. 创新是引领发展的第一动力，要求把创新摆在国家发展全局的核心位置。 \n2. 协调是持续健康发展的内在要求。坚持协调发展，要着力推动区域协调发展、城乡协调发展、物质文明和精神文明协调发展，推动经济建设和国防建设融合发展。 \n3. 绿色是永续发展的必要条件。 \n4. 开放是国家繁荣发展的必由之路。\n5. 共享是中国特色社会主义的本质要求。其内涵主要有四个方面：全民共享、全面共享、共建共享、渐进共享。 创新、 协调、 绿色、 开放、 共享的发展理念， 相互贯通、 相互促进， 是具有内在联系的集合体。创新注重的是解决发展动力问题，协调注重的是解决发展不平衡问题，绿色注重的是解决人与自然和谐问题，开放注重的是解决发展内外联动问题，共享注重的是解决社会公平正义问题。\n\n## 牢牢掌握意识形态工作领导权。\n- 建设中国特色社会主义文化，必须建设具有强大凝聚力、引领力的社会主义意识形态，使全体人民在理想信念、价值理念、道德观念上紧紧团结在一起，巩固马克思主义在意识形态领域的指导地位，牢牢掌握意识形态工作领导权。 \n1. 掌握意识形态工作领导权，要旗帜鲜明坚持马克思主义指导地位。 \n2. 要加快构建中国特色哲学社会科学。 \n3. 要坚持正确的舆论导向。 \n4. 要建设好网络空间。 \n5. 要落实好意识形态工作责任制。\n\n## 培育和践行社会主义核心价值观。 \n- 核心价值观是一个民族赖以维系的精神纽带，是一个国家共同的思想道德基础，是一个国家的重要稳定器。 富强、民主、文明、和谐，自由、民主、公正、法治，爱国、敬业、诚信、友善的 24 字表达，既体现了社会主义本质要求，继承了中华优秀传统文化，也吸收了世界文明有益成果，体现了时代精神，是当代中国精神的集中体现，凝结着全体人民共同的价值追求，是社会主义核心价值观的基本内容。\n1. 培育和践行社会主义核心价值观，要把社会主义核心价值观融入社会生活各个方面。 \n2. 要坚持全民行动、干部带头，从家庭做起、从娃娃抓起。 \n3. 必须立足中华优秀传统文化和革命文化。\n\n## 如何推动社会主义文化繁荣兴盛？\n\n## 坚持人与自然和谐共生\n- 生态文明的核心是坚持人与自然和谐共生。\n- 中华文明历来强调天人合一、尊重自然。\n- 尊重自然，是人与自然相处时应秉持的首要态度，要求人对自然怀有敬畏之心，感恩之情，报恩之意，尊重自然界的创造和存在。\n- 顺应自然，是人与自然相处时应遵循的基本原则，要求人顺应自然的客观规律，按自然规律办事。\n- 保护自然，是人与自然相处时应承担的重要责任。\n- 建设社会主义生态文明就是实现人与自然和谐发展，就是要建设以资源环境承载力为基础、以自然规律为准则、以可持续发展为目标的资源节约型、环境友好型社会，努力走向社会主义生态文明新时代。\n\n## 如何理解新时代党的建设总要求。\n- 新时代党的建设总要求是：坚持和加强党的全面领导，坚持党要管党、全面从严治党（根本方针），以加强党的长期执政能力建设、先进性和纯洁性建设为主线，以党的政治建设为统领，以坚定理想信念宗旨为根基，以调动全党积极性、主动性、创造性为着力点，全面推进党的政治建设、思想建设组织建设、作风建设、纪律建设，把制度建设贯穿其中，深入推进反腐败斗争，不断提高党的建设质量，（把党建设成为始终走在时代前列、人民衷心拥护、勇于自我革命、经得起各种风浪考验、朝气蓬勃的马克思主义执政党（建设目标））。\n- 新时代党的建设目的、方针、主线、总体布局和目标，紧密联系、相互作用、相互促进，共同构成了新时代党的建设科学有机的整体。新时代党的建设总要求，对推进党的建设新的伟大工程作出顶层设计战略部署，丰富和发展了马克思主义建党学说，标志着对执政党建设规律的认识达到新的高度。\n\n## 把党的政治建设摆在首位\n1. 第一，旗帜鲜明讲政治是我们党作为马克思主义政党的根本要求。\n2. 第二，党的政治建设是党的根本性建设，决定党的建设方向和效果。\n3. 第三，注重抓党的政治建设是党的十八大以来全面从严治党的成功经验。\n\n## 全面从严治党永远在路上\n1. 第一，加强党的思想建设，是党的基础性建设。\n2. 第二，加强党的组织建设，主要包括民主集中制建设、党的基层组织建设、干部队伍建设和党员队伍建设等。\n3. 第三，持之以恒正风肃纪，作风建设的核心是保持党同人民群众的血肉联系。\n4. 第四，将制度建设贯穿党的各项建设中。\n5. 第五，深化标本兼治，夺取反腐斗争压倒性胜利，廉政建设和反腐败斗争，是从严治党的重中之重。\n\n## 习近平新时代中国特色社会主义思想内涵十分丰富，其中最重要、最核心的内容就是党的十九大报告概括的“八个明确” 。 \n1. 明确坚持和发展中国特色社会主义，总任务是实现社会主义现代化和中华民族伟大复兴， 在全面建成小康社会的基础上，分两步走在本世纪中叶建成富强民主文明和谐美丽的社会 主义现代化强国。 \n2. 明确新时代我国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾，必须坚持以人民为中心的发展思想， 不断促进人的全面发展、 全体人民共同富裕。 \n3. 明确中国特色社会主义事业总体布局是“五位一体” 、战略布局是“四个全面” ，强调坚定 道路自信、理论自信、制度自信、文化自信。 \n4. 明确全面深化改革总目标是完善和发展中国特色社会主义制度、推进国家治理体系和治理能力现代化。 \n5. 明确全面推进依法治国总目标是建设中国特色社会主义法治体系、 建设社会主义法治国家。 \n6. 明确党在新时代的强军目标是建设一支听党指挥、能打胜仗、作风优良的人民军队。 \n7. 明确中国特色大国外交要推动构建新型国际关系，推动构建人类命运共同体。\n8. 明确中国特色社会主义最本质的特征是中国共产党领导，中国特色社会主义制度的最大优势是中国共产党领导，党是最高政治领导力量。\n\n## 习近平新时代中国特色社会主义思想也回答了新时代怎样坚持和发展中国特色社会主义，党的十九大概括为“十四个坚持” ，即新时代中国特色社会主义基本方略。\n1. 坚持党对一切工作的领导，必须增强政治意识、大局意识、核心意识、看齐意识。 \n2. 坚持以人民为中心。 \n3. 坚持全面深化改革。 \n4. 坚持新发展理念。 \n5. 坚持人民当家作主。 \n6. 坚持全面依法治国。 \n7. 坚持社会主义核心价值体系。 \n8. 坚持在发展中保障和改善民生。 \n9. 坚持人与自然和谐共生。 \n10. 坚持总体国家安全观。\n11. 坚持党对人民军队的绝对领导。\n12. 坚持“一国两制”和推进祖国统一。\n13. 坚持推动构建人类命运共同体。 \n14. 坚持全面从严治党。 \n","categories":["学习笔记","examing"]},{"title":"git笔记整理","url":"/posts/320026/","content":"## 撤销\n\n- 用暂存区中的文件覆盖工作目录中的文件： `git checkout 文件`\n- 将文件从暂存区中删除： `git rm --cached 文件`\n- 将 git 仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录：`git rest --hard commitID` \n\n## 分支命令\n\n1. `git branch`  查看当前的分支\n2. `git checkout (分支名)`  切换分支 \n3. `git merge 被合并的分支名称` 合并分支\n4. `git branch -d 分支名称`  删除分支  `-D`表示强制删除\n5. `git branch 分支名称`  创建分支\n\n## 暂时保存更改\n\n1. `git stash` 存储临时改动\n2. `git stash pop` 恢复改动\n3. `git status`  查看改动\n\n## 多人同时开发\n\n1. 解决冲突 `git pull origin master`\n\n## 跨团队协作\n\n1. 程序员 C fork仓库\n2. 程序员 C 将仓库克隆在本地进行修改\n3. 程序员 C 将仓库推送到远程\n4. 程序员 C 发起pull reqest\n5. 原仓库作者审核\n6. 原仓库作者合并代码\n\n## 创建仓库\n\n1. git push 远程仓库地址 分支名\n2. git push 远程仓库地址别名 分支名\n3. git push -u 远程仓库地址别名 分支名\n    -u 记住推送地址及分支，下次推送只需要输入git push即\n4. git remote add 远程仓库地址别名 远程仓库地\n\n## ssh免登陆\n\n1. 生成秘钥：`ssh-keygen`\n2. 秘钥存储目录：`C:\\Users\\用户\\\\.ssh`\n3. 公钥名称：`id_rsa.pub`\n4. 私钥名称：`id_rsa`\n\n## GIT忽略清单\n\n1. 将不需要被`git`管理的文件名字添加到此文件中，在执行git命令的时候，git就会忽略这些文件。\n2. git忽略清单文件名称：**.gitignore**\n3. 将工作目录中的文件全部添加到暂存区：`git add .`\n ","categories":["学习笔记","git"]},{"title":"vue学习整理（1）","url":"/posts/16696/","content":"\n### Vue 是什么？\n\n- **Vue (读音 /vjuː/，类似于 **view**) 是一套用于构建用户界面的渐进式框架**\n- vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合\n\n### 使用Vue将helloworld  渲染到页面上 \n```\n<img src=\"./images/day01-1.png\"  >\n```\n\n###  指令\n\n- 本质就是自定义属性\n- Vue中指定都是以 v- 开头 \n\n###  v-cloak\n\n- 防止页面加载时出现闪烁问题\n\n  ```html\n   <style type=\"text/css\">\n    /* \n      1、通过属性选择器 选择到 带有属性 v-cloak的标签  让他隐藏\n   */\n    [v-cloak]{\n      /* 元素隐藏    */\n      display: none;\n    }\n    </style>\n  <body>\n    <div id=\"app\">\n      <!-- 2、 让带有插值 语法的   添加 v-cloak 属性 \n           在 数据渲染完场之后，v-cloak 属性会被自动去除，\n           v-cloak一旦移除也就是没有这个属性了  属性选择器就选择不到该标签\n  \t\t 也就是对应的标签会变为可见\n      -->\n      <div  v-cloak  >{{msg}}</div>\n    </div>\n    <script type=\"text/javascript\" src=\"js/vue.js\"></script>\n    <script type=\"text/javascript\">\n      var vm = new Vue({\n        //  el   指定元素 id 是 app 的元素  \n        el: '#app',\n        //  data  里面存储的是数据\n        data: {\n          msg: 'Hello Vue'\n        }\n      });\n  </script>\n  </body>\n  </html>\n  ```\n  \n\n###  v-text\n\n- v-text指令用于将数据填充到标签中，作用于插值表达式类似，但是没有闪动问题\n- 如果数据中有HTML标签会将html标签一并输出\n- 注意：此处为单向绑定，数据对象上的值改变，插值会发生变化；但是当插值发生变化并不会影响数据对象的值\n\n```html\n<div id=\"app\">\n    <!--  \n\t\t注意:在指令中不要写插值语法  直接写对应的变量名称 \n        在 v-text 中 赋值的时候不要在写 插值语法\n\t\t一般属性中不加 {{}}  直接写 对应 的数据名 \n\t-->\n    <p v-text=\"msg\"></p>\n    <p>\n        <!-- Vue  中只有在标签的 内容中 才用插值语法 -->\n        {{msg}}\n    </p>\n</div>\n\n<script>\n    new Vue({\n        el: '#app',\n        data: {\n            msg: 'Hello Vue.js'\n        }\n    });\n\n</script>\n```\n\n###  v-html\n\n- 用法和v-text 相似  但是他可以将HTML片段填充到标签中\n\n- 可能有安全问题, 一般只在可信任内容上使用 `v-html`，**永不**用在用户提交的内容上\n\n- 它与v-text区别在于v-text输出的是纯文本，浏览器不会对其再进行html解析，但v-html会将其当html标签解析后输出。\n\n  ```html\n  <div id=\"app\">\n  　　<p v-html=\"html\"></p> <!-- 输出：html标签在渲染的时候被解析 -->\n      \n      <p>{{message}}</p> <!-- 输出：<span>通过双括号绑定</span> -->\n      \n  　　<p v-text=\"text\"></p> <!-- 输出：<span>html标签在渲染的时候被源码输出</span> -->\n  </div>\n  <script>\n  　　let app = new Vue({\n  　　el: \"#app\",\n  　　data: {\n  　　　　message: \"<span>通过双括号绑定</span>\",\n  　　　　html: \"<span>html标签在渲染的时候被解析</span>\",\n  　　　　text: \"<span>html标签在渲染的时候被源码输出</span>\",\n  　　}\n   });\n  </script>\n  ```\n\n###  v-pre\n\n- 显示原始信息跳过编译过程\n- 跳过这个元素和它的子元素的编译过程。\n- **一些静态的内容不需要编译加这个指令可以加快渲染**\n\n```html\n    <span v-pre>{{ this will not be compiled }}</span>    \n\t<!--  显示的是{{ this will not be compiled }}  -->\n\t<span v-pre>{{msg}}</span>  \n     <!--   即使data里面定义了msg这里仍然是显示的{{msg}}  -->\n<script>\n    new Vue({\n        el: '#app',\n        data: {\n            msg: 'Hello Vue.js'\n        }\n    });\n\n</script>\n```\n\n### **v-once**\n\n- 执行一次性的插值【当数据改变时，插值处的内容不会继续更新】\n\n```html\n  <!-- 即使data里面定义了msg 后期我们修改了 仍然显示的是第一次data里面存储的数据即 Hello Vue.js  -->\n     <span v-once>{{ msg}}</span>    \n<script>\n    new Vue({\n        el: '#app',\n        data: {\n            msg: 'Hello Vue.js'\n        }\n    });\n</script>\n```\n\n\n\n### 双向数据绑定\n\n- 当数据发生变化的时候，视图也就发生变化\n- 当视图发生变化的时候，数据也会跟着同步变化\n\n#### v-model\n\n- **v-model**是一个指令，限制在 `<input>、<select>、<textarea>、components`中使用\n\n```html\n <div id=\"app\">\n      <div>{{msg}}</div>\n      <div>\n          当输入框中内容改变的时候，  页面上的msg  会自动更新\n        <input type=\"text\" v-model='msg'>\n      </div>\n  </div>\n```\n\n### mvvm\n\n- MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel\n- m   model  \n  - 数据层   Vue  中 数据层 都放在 data 里面\n- v   view     视图   \n  - Vue  中  view      即 我们的HTML页面  \n- vm   （view-model）     控制器     将数据和视图层建立联系      \n  - vm 即  Vue 的实例  就是 vm  \n\n###   v-on\n\n- 用来绑定事件的\n-  形式如：v-on:click  缩写为 @click;\n\n<img src=\"images/@click.png\"  width=\"90%\">\n\n###  v-on事件函数中传入参数\n\n```html\n\n<body>\n    <div id=\"app\">\n        <div>{{num}}</div>\n        <div>\n            <!-- 如果事件直接绑定函数名称，那么默认会传递事件对象作为事件函数的第一个参数 -->\n            <button v-on:click='handle1'>点击1</button>\n            <!-- 2、如果事件绑定函数调用，那么事件对象必须作为最后一个参数显示传递，\n                 并且事件对象的名称必须是$event \n            -->\n            <button v-on:click='handle2(123, 456, $event)'>点击2</button>\n        </div>\n    </div>\n    <script type=\"text/javascript\" src=\"js/vue.js\"></script>\n    <script type=\"text/javascript\">\n        var vm = new Vue({\n            el: '#app',\n            data: {\n                num: 0\n            },\n            methods: {\n                handle1: function(event) {\n                    console.log(event.target.innerHTML)\n                },\n                handle2: function(p, p1, event) {\n                    console.log(p, p1)\n                    console.log(event.target.innerHTML)\n                    this.num++;\n                }\n            }\n        });\n    </script>\n```\n\n###  事件修饰符\n\n- 在事件处理程序中调用 `event.preventDefault()` 或 `event.stopPropagation()` 是非常常见的需求。\n- Vue 不推荐我们操作DOM    为了解决这个问题，Vue.js 为 `v-on` 提供了**事件修饰符**\n- 修饰符是由点开头的指令后缀来表示的\n\n```html\n<!-- 阻止单击事件继续传播 -->\n<a v-on:click.stop=\"doThis\"></a>\n\n<!-- 提交事件不再重载页面 -->\n<form v-on:submit.prevent=\"onSubmit\"></form>\n\n<!-- 修饰符可以串联   即阻止冒泡也阻止默认事件 -->\n<a v-on:click.stop.prevent=\"doThat\"></a>\n\n<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->\n<!-- 即事件不是从内部元素触发的 -->\n<div v-on:click.self=\"doThat\">...</div>\n\n使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。\n```\n\n### 按键修饰符\n\n- 在做项目中有时会用到键盘事件，在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 `v-on` 在监听键盘事件时添加按键修饰符\n\n```html\n<!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` -->\n<input v-on:keyup.13=\"submit\">\n\n<!-- -当点击enter 时调用 `vm.submit()` -->\n<input v-on:keyup.enter=\"submit\">\n\n<!--当点击enter或者space时  时调用 `vm.alertMe()`   -->\n<input type=\"text\" v-on:keyup.enter.space=\"alertMe\" >\n\n常用的按键修饰符\n.enter =>    enter键\n.tab => tab键\n.delete (捕获“删除”和“退格”按键) =>  删除键\n.esc => 取消键\n.space =>  空格键\n.up =>  上\n.down =>  下\n.left =>  左\n.right =>  右\n\n<script>\n\tvar vm = new Vue({\n        el:\"#app\",\n        methods: {\n              submit:function(){},\n              alertMe:function(){},\n        }\n    })\n\n</script>\n```\n\n### 自定义按键修饰符别名\n\n- 在Vue中可以通过`config.keyCodes`自定义按键修饰符别名\n\n```html\n<div id=\"app\">\n    预先定义了keycode 116（即F5）的别名为f5，因此在文字输入框中按下F5，会触发prompt方法\n    <input type=\"text\" v-on:keydown.f5=\"prompt()\">\n</div>\n\n<script>\n\t\n    Vue.config.keyCodes.f5 = 116;\n\n    let app = new Vue({\n        el: '#app',\n        methods: {\n            prompt: function() {\n                alert('我是 F5！');\n            }\n        }\n    });\n</script>\n```\n\n### v-bind\n\n- v-bind 指令被用来响应地更新 HTML 属性\n- v-bind:href    可以缩写为    :href;\n\n```html\n<!-- 绑定一个属性 -->\n<img v-bind:src=\"imageSrc\">\n\n<!-- 缩写 -->\n<img :src=\"imageSrc\">\n```\n\n#### 绑定对象\n\n- 我们可以给v-bind:class 一个对象，以动态地切换class。\n- 注意：v-bind:class指令可以与普通的class特性共存\n\n```html\n1、 v-bind 中支持绑定一个对象 \n\t如果绑定的是一个对象 则 键为 对应的类名  值 为对应data中的数据 \n<!-- \n\tHTML最终渲染为 <ul class=\"box textColor textSize\"></ul>\n\t注意：\n\t\ttextColor，textSize  对应的渲染到页面上的CSS类名\t\n\t\tisColor，isSize  对应vue data中的数据  如果为true 则对应的类名 渲染到页面上 \n\n\n\t\t当 isColor 和 isSize 变化时，class列表将相应的更新，\n\t\t例如，将isSize改成false，\n\t\tclass列表将变为 <ul class=\"box textColor\"></ul>\n-->\n\n<ul class=\"box\" v-bind:class=\"{textColor:isColor, textSize:isSize}\">\n    <li>学习Vue</li>\n    <li>学习Node</li>\n    <li>学习React</li>\n</ul>\n  <div v-bind:style=\"{color:activeColor,fontSize:activeSize}\">对象语法</div>\n\n<sript>\nvar vm= new Vue({\n    el:'.box',\n    data:{\n        isColor:true,\n        isSize:true，\n    \tactiveColor:\"red\",\n        activeSize:\"25px\",\n    }\n})\n</sript>\n<style>\n\n    .box{\n        border:1px dashed #f0f;\n    }\n    .textColor{\n        color:#f00;\n        background-color:#eef;\n    }\n    .textSize{\n        font-size:30px;\n        font-weight:bold;\n    }\n</style>\n```\n\n####  绑定class\n\n```html\n2、  v-bind 中支持绑定一个数组    数组中classA和 classB 对应为data中的数据\n\n这里的classA  对用data 中的  classA\n这里的classB  对用data 中的  classB\n<ul class=\"box\" :class=\"[classA, classB]\">\n    <li>学习Vue</li>\n    <li>学习Node</li>\n    <li>学习React</li>\n</ul>\n<script>\nvar vm= new Vue({\n    el:'.box',\n    data:{\n        classA:‘textColor‘,\n        classB:‘textSize‘\n    }\n})\n</script>\n<style>\n    .box{\n        border:1px dashed #f0f;\n    }\n    .textColor{\n        color:#f00;\n        background-color:#eef;\n    }\n    .textSize{\n        font-size:30px;\n        font-weight:bold;\n    }\n</style>\n```\n\n#### 绑定对象和绑定数组 的区别\n\n- 绑定对象的时候 对象的属性 即要渲染的类名 对象的属性值对应的是 data 中的数据 \n- 绑定数组的时候数组里面存的是data 中的数据 \n\n#### 绑定style\n\n```html\n <div v-bind:style=\"styleObject\">绑定样式对象</div>'\n \n<!-- CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来)    -->\n <div v-bind:style=\"{ color: activeColor, fontSize: fontSize,background:'red' }\">内联样式</div>\n\n<!--组语法可以将多个样式对象应用到同一个元素 -->\n<div v-bind:style=\"[styleObj1, styleObj2]\"></div>\n\n\n<script>\n\tnew Vue({\n      el: '#app',\n      data: {\n        styleObject: {\n          color: 'green',\n          fontSize: '30px',\n          background:'red'\n        }，\n        activeColor: 'green',\n   \t\tfontSize: \"30px\"\n      },\n      styleObj1: {\n             color: 'red'\n       },\n       styleObj2: {\n            fontSize: '30px'\n       }\n\n</script>\n```\n\n### 分支结构\n\n#### v-if 使用场景\n\n- 1- 多个元素 通过条件判断展示或者隐藏某个元素。或者多个元素\n- 2- 进行两个视图之间的切换\n\n```html\n<div id=\"app\">\n        <!--  判断是否加载，如果为真，就加载，否则不加载-->\n        <span v-if=\"flag\">\n           如果flag为true则显示,false不显示!\n        </span>\n</div>\n\n<script>\n    var vm = new Vue({\n        el:\"#app\",\n        data:{\n            flag:true\n        }\n    })\n</script>\n\n----------------------------------------------------------\n\n    <div v-if=\"type === 'A'\">\n       A\n    </div>\n  <!-- v-else-if紧跟在v-if或v-else-if之后   表示v-if条件不成立时执行-->\n    <div v-else-if=\"type === 'B'\">\n       B\n    </div>\n    <div v-else-if=\"type === 'C'\">\n       C\n    </div>\n  <!-- v-else紧跟在v-if或v-else-if之后-->\n    <div v-else>\n       Not A/B/C\n    </div>\n\n<script>\n    new Vue({\n      el: '#app',\n      data: {\n        type: 'C'\n      }\n    })\n</script>\n```\n\n#### v-show 和 v-if的区别\n\n- v-show本质就是标签display设置为none，控制隐藏\n  - v-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，故v-show性能更好一点。\n- v-if是动态的向DOM树内添加或者删除DOM元素\n  - v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件\n\n### 循环结构\n\n#### v-for\n\n- 用于循环的数组里面的值可以是对象，也可以是普通元素  \n\n```html\n<ul id=\"example-1\">\n   <!-- 循环结构-遍历数组  \n\titem 是我们自己定义的一个名字  代表数组里面的每一项  \n\titems对应的是 data中的数组-->\n  <li v-for=\"item in items\">\n    {{ item.message }}\n  </li> \n\n</ul>\n<script>\n new Vue({\n  el: '#example-1',\n  data: {\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]，\n   \n  }\n})\n</script>\n```\n\n- **不推荐**同时使用 `v-if` 和 `v-for`\n- 当 `v-if` 与 `v-for` 一起使用时，`v-for` 具有比 `v-if` 更高的优先级。\n\n```html\n   <!--  循环结构-遍历对象\n\t\tv 代表   对象的value\n\t\tk  代表对象的 键 \n\t\ti  代表索引\t\n\t---> \n     <div v-if='v==13' v-for='(v,k,i) in obj'>{{v + '---' + k + '---' + i}}</div>\n\n<script>\n new Vue({\n  el: '#example-1',\n  data: {\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]，\n    obj: {\n        uname: 'zhangsan',\n        age: 13,\n        gender: 'female'\n    }\n  }\n})\n</script>\n```\n\n- key 的作用\n  - **key来给每个节点做一个唯一标识**\n  - **key的作用主要是为了高效的更新虚拟DOM**\n\n```html\n<ul>\n  <li v-for=\"item in items\" :key=\"item.id\">...</li>\n</ul>\n\n```\n\n\n\n### 案例选项卡\n\n#### 1、 HTML 结构\n\n```html\n`\n    <div id=\"app\">\n        <div class=\"tab\">\n            <!--  tab栏  -->\n            <ul>\n                <li class=\"active\">apple</li>\n                <li class=\"\">orange</li>\n                <li class=\"\">lemon</li>\n            </ul>\n              <!--  对应显示的图片 -->\n            <div class=\"current\"><img src=\"img/apple.png\"></div>\n            <div class=\"\"><img src=\"img/orange.png\"></div>\n            <div class=\"\"><img src=\"img/lemon.png\"></div>\n        </div>\n    </div>\n\n\n`\n```\n\n#### 2、 提供的数据\n\n```js\n         list: [{\n                    id: 1,\n                    title: 'apple',\n                    path: 'img/apple.png'\n                }, {\n                    id: 2,\n                    title: 'orange',\n                    path: 'img/orange.png'\n                }, {\n                    id: 3,\n                    title: 'lemon',\n                    path: 'img/lemon.png'\n                }]\n```\n\n\n\n#### 3、 把数据渲染到页面\n\n- 把tab栏 中的数替换到页面上\n\n  - 把 data 中 title  利用 v-for 循环渲染到页面上 \n  - 把 data 中 path利用 v-for 循环渲染到页面上 \n\n  ```html\n      <div id=\"app\">\n          <div class=\"tab\">  \n              <ul>\n                    <!--  \n                      1、绑定key的作用 提高Vue的性能 \n                      2、 key 需要是唯一的标识 所以需要使用id， 也可以使用index ，\n  \t\t\t\t\t\tindex 也是唯一的 \n                      3、 item 是 数组中对应的每一项  \n                      4、 index 是 每一项的 索引\n                  -->\n                     <li :key='item.id' v-for='(item,index) in list'>{{item.title}}</li>\n                </ul>\n                <div  :key='item.id' v-for='(item, index) in list'>\n                      <!-- :  是 v-bind 的简写   绑定属性使用 v-bind -->\n                      <img :src=\"item.path\">\n                </div>\n          </div>\n      </div>\n  <script>\n      new  Vue({\n          //  指定 操作元素 是 id 为app 的 \n          el: '#app',\n              data: {\n                  list: [{\n                      id: 1,\n                      title: 'apple',\n                      path: 'img/apple.png'\n                  }, {\n                      id: 2,\n                      title: 'orange',\n                      path: 'img/orange.png'\n                  }, {\n                      id: 3,\n                      title: 'lemon',\n                      path: 'img/lemon.png'\n                  }]\n              }\n      })\n  \n  </script>\n  ```\n\n  \n\n#### 4、 给每一个tab栏添加事件,并让选中的高亮\n\n- 4.1 、让默认的第一项tab栏高亮\n\n  - tab栏高亮 通过添加类名active 来实现   （CSS  active 的样式已经提前写好）\n    - 在data 中定义一个 默认的  索引 currentIndex  为  0 \n    - 给第一个li 添加 active 的类名  \n      - 通过动态绑定class 来实现   第一个li 的索引为 0     和 currentIndex   的值刚好相等\n      -  currentIndex     ===  index  如果相等  则添加类名 active  否则 添加 空类名\n\n- 4.2 、让默认的第一项tab栏对应的div 显示 \n\n  - 实现思路 和 第一个 tab 实现思路一样  只不过 这里控制第一个div 显示的类名是 current\n\n  ```html\n    <ul>\n  \t   <!-- 动态绑定class   有 active   类名高亮  无 active   不高亮-->\n         <li  :class='currentIndex==index?\"active\":\"\"'\n             :key='item.id' v-for='(item,index) in list'\n             >{{item.title}}</li>\n    </ul>\n  \t<!-- 动态绑定class   有 current  类名显示  无 current  隐藏-->\n    <div :class='currentIndex==index?\"current\":\"\"' \n         \n         :key='item.id' v-for='(item, index) in list'>\n          <!-- :  是 v-bind 的简写   绑定属性使用 v-bind -->\n          <img :src=\"item.path\">\n    </div>\n  \n  <script>\n      new  Vue({\n          el: '#app',\n              data: {\n                  currentIndex: 0, // 选项卡当前的索引  默认为 0  \n                  list: [{\n                      id: 1,\n                      title: 'apple',\n                      path: 'img/apple.png'\n                  }, {\n                      id: 2,\n                      title: 'orange',\n                      path: 'img/orange.png'\n                  }, {\n                      id: 3,\n                      title: 'lemon',\n                      path: 'img/lemon.png'\n                  }]\n              }\n      })\n  \n  </script>\n  ```\n\n- 4.3 、点击每一个tab栏 当前的高亮 其他的取消高亮 \n\n  - 给每一个li添加点击事件    \n\n  - 让当前的索引 index  和  当前 currentIndex 的  值 进项比较 \n\n  - 如果相等 则当前li  添加active 类名 当前的 li 高亮  当前对应索引的 div 添加 current 当前div 显示 其他隐藏\n\n    ```html\n        <div id=\"app\">\n            <div class=\"tab\">\n                <ul>\n                    <!--  通过v-on 添加点击事件   需要把当前li 的索引传过去 \n    \t\t\t\t-->\n                    <li v-on:click='change(index)'\t\t           \t\t\t\n                        :class='currentIndex==index?\"active\":\"\"'                   \n                        :key='item.id' \n                        v-for='(item,index) in list'>{{item.title}}</li>\n                </ul>\n                <div :class='currentIndex==index?\"current\":\"\"' \n                     :key='item.id' v-for='(item, index) in list'>\n                    <img :src=\"item.path\">\n                </div>\n            </div>\n        </div>\n    \n    <script>\n        new  Vue({\n            el: '#app',\n                data: {\n                    currentIndex: 0, // 选项卡当前的索引  默认为 0  \n                    list: [{\n                        id: 1,\n                        title: 'apple',\n                        path: 'img/apple.png'\n                    }, {\n                        id: 2,\n                        title: 'orange',\n                        path: 'img/orange.png'\n                    }, {\n                        id: 3,\n                        title: 'lemon',\n                        path: 'img/lemon.png'\n                    }]\n                },\n                methods: {\n                    change: function(index) {\n                        // 通过传入过来的索引来让当前的  currentIndex  和点击的index 值 相等 \n                        //  从而实现 控制类名    \n                        this.currentIndex = index;\n                    }\n                }\n        \n        })\n    \n    </script>\n    ```\n\n    ","categories":["web","Vue"]},{"title":"Python GUI之tkinter窗口视窗","url":"/posts/64935/","content":"\n## tkinter是什么\n\n1. Tkinter 是使用 python 进行窗口视窗设计的模块。Tkinter模块(\"Tk 接口\")是Python的标准Tk GUI工具包的接口。作为 python 特定的GUI界面，是一个图像的窗口，tkinter是python 自带的，可以编辑的GUI界面，我们可以用GUI 实现很多直观的功能，比如想开发一个计算器，如果只是一个程序输入，输出窗口的话，是没用用户体验的。所有开发一个图像化的小窗口，就是必要的。\n\n## Label标签\n\n1. 创建好主窗口才能在上面放置各种控件元素\n2. `tk.Lable(window,text=\"文本内容\"，bg='背景颜色',font=('字体family',字体大小)),width=标签宽度,height=标签高度 以字符的大小为单位`\n3. `window.title('窗口名称')`\n4. window.geometry('窗口的大小')\n5. 放置标签x.pack()或者x.place()\n\n{% folding green, 参考代码 %}\n```py\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# author:洪卫\n \nimport tkinter as tk  # 使用Tkinter前需要先导入\n \n# 第1步，实例化object，建立窗口window\nwindow = tk.Tk()\n \n# 第2步，给窗口的可视化起名字\nwindow.title('My Window')\n \n# 第3步，设定窗口的大小(长 * 宽)\nwindow.geometry('500x300')  # 这里的乘是小x\n \n# 第4步，在图形界面上设定标签\nl = tk.Label(window, text='你好！this is Tkinter', bg='green', font=('Arial', 12), width=30, height=2)\n# 说明： bg为背景，font为字体，width为长，height为高，这里的长和高是字符的长和高，比如height=2,就是标签有2个字符这么高\n \n# 第5步，放置标签\nl.pack()    # Label内容content区域放置位置，自动调节尺寸\n# 放置lable的方法有：1）l.pack(); 2)l.place();\n \n# 第6步，主窗口循环显示\nwindow.mainloop()\n# 注意，loop因为是循环的意思，window.mainloop就会让window不断的刷新，如果没有mainloop,就是一个静态的window,传入进去的值就不会有循环，mainloop就相当于一个很大的while循环，有个while，每点击一次就会更新一次，所以我们必须要有循环\n# 所有的窗口文件都必须有类似的mainloop函数，mainloop是窗口文件的关键的关键。\n```\n{% endfolding %}\n\n## Button窗口部件\n\n\n1. 定义一个函数功能（内容自己自由编写），供点击Button按键时调用，调用命令参数command=函数名\n\n{% folding green, 查看答案 %}\n```py\n\nimport tkinter as tk  # 使用Tkinter前需要先导入\n\n# 第1步，实例化object，建立窗口window\nwindow = tk.Tk()\n\n# 第2步，给窗口的可视化起名字\nwindow.title('My Window')\n\n# 第3步，设定窗口的大小(长 * 宽)\nwindow.geometry('500x300')  # 这里的乘是小x\n# 第4步，在图形界面上设定标签\n# 说明： bg为背景，font为字体，width为长，height为高，这里的长和高是字符的长和高，比如height=2,就是标签有2个字符这么高\nvar = tk.StringVar()  # 将label标签的内容设置为字符类型，用var来接收hit_me函数的传出内容用以显示在标签上\nl = tk.Label(window, textvariable=var, bg='green', fg='white', font=('Arial', 12), width=30, height=2)\n# 说明： bg为背景，fg为字体颜色，font为字体，width为长，height为高，这里的长和高是字符的长和高，比如height=2,就是标签有2个字符这么高\nl.pack()\n# 定义一个函数功能（内容自己自由编写），供点击Button按键时调用，调用命令参数command=函数名\non_hit = False\ndef hit_me():\n    global on_hit\n    if on_hit == False:\n        on_hit = True\n        var.set('you hit me')\n    else:\n        on_hit = False\n        var.set('')\n# 第5步，在窗口界面设置放置Button按键\nb = tk.Button(window, text='hit me', font=('Arial', 12), width=10, height=1, command=hit_me)\n# 第5步，放置标签\n# x.pack()  # Label内容content区域放置位置，自动调节尺寸\nb.pack()\n# 放置lable的方法有：1）l.pack(); 2)l.place();\n\n# 第6步，主窗口循环显示\nwindow.mainloop()\n# 注意，loop因为是循环的意思，window.mainloop就会让window不断的刷新，如果没有mainloop,就是一个静态的window,传入进去的值就不会有循环，mainloop就相当于一个很大的while循环，有个while，每点击一次就会更新一次，所以我们必须要有循环\n# 所有的窗口文件都必须有类似的mainloop函数，mainloop是窗口文件的关键的关键。\n```\n{% endfolding %}\n\n## Entry窗口部件\n\n1. Entry是tkinter类中提供的的一个单行文本输入域，用来输入显示一行文本，收集键盘输入(类似 HTML 中的 text)\n\n{% folding green, 查看答案 %}\n```py\ne1 = tk.Entry(window, show='*', font=('Arial', 14))   # 显示成密文形式\ne2 = tk.Entry(window, show=None, font=('Arial', 14))  # 显示成明文形式\ne2.pack()\n```\n{% endfolding %}\n\n## Text窗口部件\n\n1. Text是tkinter类中提供的的一个多行文本区域，显示多行文本，可用来收集(或显示)用户输入的文字(类似 HTML 中的 textarea)，格式化文本显示，允许你用不同的样式和属性来显示和编辑文本，同时支持内嵌图象和窗口。\n2. insert 在焦点处插入 ，end 在文本末尾插入数据\n\n{% folding green, 查看答案 %}\n```py\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# author:洪卫\n\nimport tkinter as tk  # 使用Tkinter前需要先导入\n\n# 第1步，实例化object，建立窗口window\nwindow = tk.Tk()\n\n# 第2步，给窗口的可视化起名字\nwindow.title('My Window')\n\n# 第3步，设定窗口的大小(长 * 宽)\nwindow.geometry('500x300')  # 这里的乘是小x\n\n# 第4步，在图形界面上设定输入框控件entry框并放置\ne = tk.Entry(window, show=None)  # 显示成明文形式\ne.pack()\n\n\n# 第5步，定义两个触发事件时的函数insert_point和insert_end（注意：因为Python的执行顺序是从上往下，所以函数一定要放在按钮的上面）\ndef insert_point():  # 在鼠标焦点处插入输入内容\n    var = e.get()\n    t.insert('insert', var)\n\n\ndef insert_end():  # 在文本框内容最后接着插入输入内容\n    var = e.get()\n    t.insert('end', var)\n\n\n# 第6步，创建并放置两个按钮分别触发两种情况\nb1 = tk.Button(window, text='insert point', width=10,\n               height=2, command=insert_point)\nb1.pack()\nb2 = tk.Button(window, text='insert end', width=10,\n               height=2, command=insert_end)\nb2.pack()\n\n# 第7步，创建并放置一个多行文本框text用以显示，指定height=3为文本框是三个字符高度\nt = tk.Text(window, height=3)\nt.pack()\n\n# 第8步，主窗口循环显示\nwindow.mainloop()\n```\n{% endfolding %}\n\n## Listbox窗口部件\n\n1. Text是tkinter类中提供的的列表框部件，显示供选方案的一个列表。listbox能够被配置来得到radiobutton或checklist的行为。\n2. lb.get(lb.curselection()) 获取列表选中文本的值\n3. 可以使用insert将值遍历到listbox中\n\n{% folding green, 查看答案 %}\n```py\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# author:洪卫\n\nimport tkinter as tk  # 使用Tkinter前需要先导入\n\n# 第1步，实例化object，建立窗口window\nwindow = tk.Tk()\n\n# 第2步，给窗口的可视化起名字\nwindow.title('My Window')\n\n# 第3步，设定窗口的大小(长 * 宽)\nwindow.geometry('500x300')  # 这里的乘是小x\n\n# 第4步，在图形界面上创建一个标签label用以显示并放置\nvar1 = tk.StringVar()  # 创建变量，用var1用来接收鼠标点击具体选项的内容\nl = tk.Label(window, bg='green', fg='yellow', font=('Arial', 12), width=10, textvariable=var1)\nl.pack()\n\n\n# 第6步，创建一个方法用于按钮的点击事件\ndef print_selection():\n    value = lb.get(lb.curselection())  # 获取当前选中的文本\n    var1.set(value)  # 为label设置值\n\n\n# 第5步，创建一个按钮并放置，点击按钮调用print_selection函数\nb1 = tk.Button(window, text='print selection', width=15, height=2, command=print_selection)\nb1.pack()\n\n# 第7步，创建Listbox并为其添加内容\nvar2 = tk.StringVar()\nvar2.set((1, 2, 3, 4))  # 为变量var2设置值\n# 创建Listbox\nlb = tk.Listbox(window, listvariable=var2)  # 将var2的值赋给Listbox\n# 创建一个list并将值循环添加到Listbox控件中\nlist_items = [11, 22, 33, 44]\nfor item in list_items:\n    lb.insert('end', item)  # 从最后一个位置开始加入值\nlb.insert(1, 'first')  # 在第一个位置加入'first'字符\nlb.insert(2, 'second')  # 在第二个位置加入'second'字符\nlb.delete(2)  # 删除第二个位置的字符\nlb.pack()\n\n# 第8步，主窗口循环显示\nwindow.mainloop()\n```\n{% endfolding %}\n\n## Radiobutton窗口部件\n\n1. 代表一个变量，它可以有多个值中的一个。点击它将为这个变量设置值，并且清除与这同一变量相关的其它radiobutton。类似于单选\n2. tk.Radiobutton(window, text='Option A', variable=var, value='A', command=print_selection)\n\n{% folding green, 查看答案 %}\n```py\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# author:洪卫\n \nimport tkinter as tk  # 使用Tkinter前需要先导入\n \n# 第1步，实例化object，建立窗口window\nwindow = tk.Tk()\n \n# 第2步，给窗口的可视化起名字\nwindow.title('My Window')\n \n# 第3步，设定窗口的大小(长 * 宽)\nwindow.geometry('500x300')  # 这里的乘是小x\n \n# 第4步，在图形界面上创建一个标签label用以显示并放置\nvar = tk.StringVar()    # 定义一个var用来将radiobutton的值和Label的值联系在一起.\nl = tk.Label(window, bg='yellow', width=20, text='empty')\nl.pack()\n \n# 第6步，定义选项触发函数功能\ndef print_selection():\n    l.config(text='you have selected ' + var.get())\n \n# 第5步，创建三个radiobutton选项，其中variable=var, value='A'的意思就是，当我们鼠标选中了其中一个选项，把value的值A放到变量var中，然后赋值给variable\nr1 = tk.Radiobutton(window, text='Option A', variable=var, value='A', command=print_selection)\nr1.pack()\nr2 = tk.Radiobutton(window, text='Option B', variable=var, value='B', command=print_selection)\nr2.pack()\nr3 = tk.Radiobutton(window, text='Option C', variable=var, value='C', command=print_selection)\nr3.pack()\n \n# 第7步，主窗口循环显示\nwindow.mainloop()\n```\n{% endfolding %}\n\n\n## Checkbutton窗口部件\n\n1. 代表一个变量，它有两个不同的值。点击这个按钮将会在这两个值间切换，选择和取消选择。\n2. `l.config` 将值显示在标签上\n\n{% folding green, 查看答案 %}\n```py\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# author:洪卫\n\nimport tkinter as tk  # 使用Tkinter前需要先导入\n\n# 第1步，实例化object，建立窗口window\nwindow = tk.Tk()\n\n# 第2步，给窗口的可视化起名字\nwindow.title('My Window')\n\n# 第3步，设定窗口的大小(长 * 宽)\nwindow.geometry('500x300')  # 这里的乘是小x\n\n# 第4步，在图形界面上创建一个标签label用以显示并放置\nl = tk.Label(window, bg='yellow', width=20, text='empty')\nl.pack()\n\n\n# 第6步，定义触发函数功能\ndef print_selection():\n    if (var1.get() == 1) & (var2.get() == 0):  # 如果选中第一个选项，未选中第二个选项\n        l.config(text='I love only Python ')\n    elif (var1.get() == 0) & (var2.get() == 1):  # 如果选中第二个选项，未选中第一个选项\n        l.config(text='I love only C++')\n    elif (var1.get() == 0) & (var2.get() == 0):  # 如果两个选项都未选中\n        l.config(text='I do not love either')\n    else:\n        l.config(text='I love both')  # 如果两个选项都选中\n\n\n# 第5步，定义两个Checkbutton选项并放置\nvar1 = tk.IntVar()  # 定义var1和var2整型变量用来存放选择行为返回值\nvar2 = tk.IntVar()\nc1 = tk.Checkbutton(window, text='Python', variable=var1, onvalue=1, offvalue=0,\n                    command=print_selection)  # 传值原理类似于radiobutton部件\nc1.pack()\nc2 = tk.Checkbutton(window, text='C++', variable=var2, onvalue=1, offvalue=0, command=print_selection)\nc2.pack()\n\n# 第7步，主窗口循环显示\nwindow.mainloop()\n```\n{% endfolding %}\n\n\n## Scale窗口部件\n\n1.  尺度（拉动条），允许你通过滑块来设置一数字值。\n\n{% folding green, 查看答案 %}\n```py\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# author:洪卫\n \nimport tkinter as tk  # 使用Tkinter前需要先导入\n \n# 第1步，实例化object，建立窗口window\nwindow = tk.Tk()\n \n# 第2步，给窗口的可视化起名字\nwindow.title('My Window')\n \n# 第3步，设定窗口的大小(长 * 宽)\nwindow.geometry('500x300')  # 这里的乘是小x\n \n# 第4步，在图形界面上创建一个标签label用以显示并放置\nl = tk.Label(window, bg='green', fg='white', width=20, text='empty')\nl.pack()\n \n# 第6步，定义一个触发函数功能\ndef print_selection(v):\n    l.config(text='you have selected ' + v)\n \n# 第5步，创建一个尺度滑条，长度200字符，从0开始10结束，以2为刻度，精度为0.01，触发调用print_selection函数\ns = tk.Scale(window, label='try me', from_=0, to=10, orient=tk.HORIZONTAL, length=200, showvalue=0,tickinterval=2, resolution=0.01, command=print_selection)\ns.pack()\n \n# 第7步，主窗口循环显示\nwindow.mainloop()\n```\n{% endfolding %}\n\n## Canvas窗口部件\n\n1. 画布，提供绘图功能(直线、椭圆、多边形、矩形) 可以包含图形或位图，用来绘制图表和图，创建图形编辑器，实现定制窗口部件。\n\n{% folding green, 查看答案 %}\n```py\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# author:洪卫\n \nimport tkinter as tk  # 使用Tkinter前需要先导入\n \n# 第1步，实例化object，建立窗口window\nwindow = tk.Tk()\n \n# 第2步，给窗口的可视化起名字\nwindow.title('My Window')\n \n# 第3步，设定窗口的大小(长 * 宽)\nwindow.geometry('500x300')  # 这里的乘是小x\n \n# 第4步，在图形界面上创建 500 * 200 大小的画布并放置各种元素\ncanvas = tk.Canvas(window, bg='green', height=200, width=500)\n# 说明图片位置，并导入图片到画布上\nimage_file = tk.PhotoImage(file='pic.gif')  # 图片位置（相对路径，与.py文件同一文件夹下，也可以用绝对路径，需要给定图片具体绝对路径）\nimage = canvas.create_image(250, 0, anchor='n',image=image_file)        # 图片锚定点（n图片顶端的中间点位置）放在画布（250,0）坐标处\n# 定义多边形参数，然后在画布上画出指定图形\nx0, y0, x1, y1 = 100, 100, 150, 150\nline = canvas.create_line(x0-50, y0-50, x1-50, y1-50)                   # 画直线\noval = canvas.create_oval(x0+120, y0+50, x1+120, y1+50, fill='yellow')  # 画圆 用黄色填充\narc = canvas.create_arc(x0, y0+50, x1, y1+50, start=0, extent=180)      # 画扇形 从0度打开收到180度结束\nrect = canvas.create_rectangle(330, 30, 330+20, 30+20)                  # 画矩形正方形\ncanvas.pack()\n \n# 第6步，触发函数，用来一定指定图形\ndef moveit():\n    canvas.move(rect, 2, 2) # 移动正方形rect（也可以改成其他图形名字用以移动一起图形、元素），按每次（x=2, y=2）步长进行移动\n \n# 第5步，定义一个按钮用来移动指定图形的在画布上的位置\nb = tk.Button(window, text='move item',command=moveit).pack()\n \n# 第7步，主窗口循环显示\nwindow.mainloop()\n```\n{% endfolding %}\n\n\n## Menu窗口部件\n\n{% folding green, 查看答案 %}\n```py\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# author:洪卫\n\nimport tkinter as tk  # 使用Tkinter前需要先导入\n\n# 第1步，实例化object，建立窗口window\nwindow = tk.Tk()\n\n# 第2步，给窗口的可视化起名字\nwindow.title('My Window')\n\n# 第3步，设定窗口的大小(长 * 宽)\nwindow.geometry('500x300')  # 这里的乘是小x\n\n# 第4步，在图形界面上创建一个标签用以显示内容并放置\nl = tk.Label(window, text='      ', bg='green')\nl.pack()\n\n# 第10步，定义一个函数功能，用来代表菜单选项的功能，这里为了操作简单，定义的功能比较简单\ncounter = 0\n\n\ndef do_job():\n    global counter\n    l.config(text='do ' + str(counter))\n    counter += 1\n\n\n# 第5步，创建一个菜单栏，这里我们可以把他理解成一个容器，在窗口的上方\nmenubar = tk.Menu(window)\n\n# 第6步，创建一个File菜单项（默认不下拉，下拉内容包括New，Open，Save，Exit功能项）\nfilemenu = tk.Menu(menubar, tearoff=0)\n# 将上面定义的空菜单命名为File，放在菜单栏中，就是装入那个容器中\nmenubar.add_cascade(label='File', menu=filemenu)\n\n# 在File中加入New、Open、Save等小菜单，即我们平时看到的下拉菜单，每一个小菜单对应命令操作。\nfilemenu.add_command(label='New', command=do_job)\nfilemenu.add_command(label='Open', command=do_job)\nfilemenu.add_command(label='Save', command=do_job)\nfilemenu.add_separator()  # 添加一条分隔线\nfilemenu.add_command(label='Exit', command=window.quit)  # 用tkinter里面自带的quit()函数\n\n# 第7步，创建一个Edit菜单项（默认不下拉，下拉内容包括Cut，Copy，Paste功能项）\neditmenu = tk.Menu(menubar, tearoff=0)\n# 将上面定义的空菜单命名为 Edit，放在菜单栏中，就是装入那个容器中\nmenubar.add_cascade(label='Edit', menu=editmenu)\n\n# 同样的在 Edit 中加入Cut、Copy、Paste等小命令功能单元，如果点击这些单元, 就会触发do_job的功能\neditmenu.add_command(label='Cut', command=do_job)\neditmenu.add_command(label='Copy', command=do_job)\neditmenu.add_command(label='Paste', command=do_job)\n\n# 第8步，创建第二级菜单，即菜单项里面的菜单\nsubmenu = tk.Menu(filemenu)  # 和上面定义菜单一样，不过此处实在File上创建一个空的菜单\nfilemenu.add_cascade(label='Import', menu=submenu, underline=0)  # 给放入的菜单submenu命名为Import\n\n# 第9步，创建第三级菜单命令，即菜单项里面的菜单项里面的菜单命令（有点拗口，笑~~~）\nsubmenu.add_command(label='Submenu_1', command=do_job)  # 这里和上面创建原理也一样，在Import菜单项中加入一个小菜单命令Submenu_1\n\n# 第11步，创建菜单栏完成后，配置让菜单栏menubar显示出来\nwindow.config(menu=menubar)\n\n# 第12步，主窗口循环显示\nwindow.mainloop()\n```\n{% endfolding %}\n\n##  Frame 窗口部件\n\n1. 框架，用来承载放置其他GUI元素，就是一个容器，是一个在 Windows 上分离小区域的部件, 它能将 Windows 分成不同的区,然后存放不同的其他部件. 同时一个 Frame 上也能再分成两个 Frame, Frame 可以认为是一种容器.\n\n{% folding green, 查看答案 %}\n```py\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# author:洪卫\n \nimport tkinter as tk  # 使用Tkinter前需要先导入\n \n# 第1步，实例化object，建立窗口window\nwindow = tk.Tk()\n \n# 第2步，给窗口的可视化起名字\nwindow.title('My Window')\n \n# 第3步，设定窗口的大小(长 * 宽)\nwindow.geometry('500x300')  # 这里的乘是小x\n \n# 第4步，在图形界面上创建一个标签用以显示内容并放置\ntk.Label(window, text='on the window', bg='red', font=('Arial', 16)).pack()   # 和前面部件分开创建和放置不同，其实可以创建和放置一步完成\n \n# 第5步，创建一个主frame，长在主window窗口上\nframe = tk.Frame(window)\nframe.pack()\n \n# 第6步，创建第二层框架frame，长在主框架frame上面\nframe_l = tk.Frame(frame)# 第二层frame，左frame，长在主frame上\nframe_r = tk.Frame(frame)# 第二层frame，右frame，长在主frame上\nframe_l.pack(side='left')\nframe_r.pack(side='right')\n \n# 第7步，创建三组标签，为第二层frame上面的内容，分为左区域和右区域，用不同颜色标识\ntk.Label(frame_l, text='on the frame_l1', bg='green').pack()\ntk.Label(frame_l, text='on the frame_l2', bg='green').pack()\ntk.Label(frame_l, text='on the frame_l3', bg='green').pack()\ntk.Label(frame_r, text='on the frame_r1', bg='yellow').pack()\ntk.Label(frame_r, text='on the frame_r2', bg='yellow').pack()\ntk.Label(frame_r, text='on the frame_r3', bg='yellow').pack()\n \n# 第8步，主窗口循环显示\nwindow.mainloop()\n```\n{% endfolding %}\n\n## messageBox窗口部件\n\n1. 类似于弹窗的操作\n```py\n tkinter.messagebox.showinfo(title='Hi', message='你好！')  # 提示信息对话窗\n    tkinter.messagebox.showwarning(title='Hi', message='有警告！')       # 提出警告对话窗\n    tkinter.messagebox.showerror(title='Hi', message='出错了！')         # 提出错误对话窗\n    print(tkinter.messagebox.askquestion(title='Hi', message='你好！'))  # 询问选择对话窗return 'yes', 'no'\n    print(tkinter.messagebox.askyesno(title='Hi', message='你好！'))     # return 'True', 'False'\n    print(tkinter.messagebox.askokcancel(title='Hi', message='你好！'))  # return 'True', 'False'\n```\n\n{% folding green, 查看答案 %}\n```py\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# author:洪卫\n\nimport tkinter as tk  # 使用Tkinter前需要先导入\nimport tkinter.messagebox  # 要使用messagebox先要导入模块\n\n# 第1步，实例化object，建立窗口window\nwindow = tk.Tk()\n\n# 第2步，给窗口的可视化起名字\nwindow.title('My Window')\n\n# 第3步，设定窗口的大小(长 * 宽)\nwindow.geometry('500x300')  # 这里的乘是小x\n\n\n# 第5步，定义触发函数功能\ndef hit_me():\n    tkinter.messagebox.showinfo(title='Hi', message='你好！')  # 提示信息对话窗\n    tkinter.messagebox.showwarning(title='Hi', message='有警告！')       # 提出警告对话窗\n    tkinter.messagebox.showerror(title='Hi', message='出错了！')         # 提出错误对话窗\n    print(tkinter.messagebox.askquestion(title='Hi', message='你好！'))  # 询问选择对话窗return 'yes', 'no'\n    print(tkinter.messagebox.askyesno(title='Hi', message='你好！'))     # return 'True', 'False'\n    print(tkinter.messagebox.askokcancel(title='Hi', message='你好！'))  # return 'True', 'False'\n\n\n# 第4步，在图形界面上创建一个标签用以显示内容并放置\ntk.Button(window, text='hit me', bg='green', font=('Arial', 14), command=hit_me).pack()\n\n# 第6步，主窗口循环显示\nwindow.mainloop()\n```\n{% endfolding %}\n\n- [参考文章](https://blog.csdn.net/low5252/article/details/106366257?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-8&spm=1001.2101.3001.4242)","categories":["Python","tkinter"]},{"title":"小程序的学习笔记","url":"/posts/60054/","content":"\n\n## 小程序文件分析\n\n1. `WXML WXSS JavaScript JSON`\n2. `page` 首页 `log`日志\n3. 顶部标题的颜色必须为block和white\n\n\n## tabBar\n\n1. 表示地址的tab栏\n2. 【[官网地址](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#tabBar)】\n\n## 注意事项\n\n1. 在使用bool类型充当类型属性时，在属性值的位置前面不能加空格\n2. 列表循环 `wx:for=\"数组或者对象\"\n3. 只有一层循环时可以将一下省略\n4. 列表循环`wx:for-item=\"循环项的名称\" `wx:for-index='index'`\n3. wx:key=\"唯一的值\"\n4. 条件渲染 `wx:if`  `wx:elif` `wx:else`\n5. hidden 是添加样式使用\n6. 对象循环` wx:for=\"{{对象/数组}}\" wx:for-item=\"对象的值\" wx:for-index=\"循环项目的属性\"`\n\n{% folding green, 查看答案 %}\n```html\n<!--pages/demo/demo.wxml-->\n<view>轮播图</view>\n<!-- image width 700px height 277px \n  x/1 = 277/700   x=277/700\n-->\n<swiper class=\"swiper\" autoplay interval=\"1000\" circular indicator-dots>\n  <swiper-item> <image mode=\"widthFix\" src=\"https://m.360buyimg.com/mobilecms/s700x280_jfs/t1/175759/5/697/309624/605fa953Eaddcc402/30b0ea12dc5cc42c.jpg!cr_1125x445_0_171!q70.jpg.dpg\" alt=\"\"/></swiper-item>\n  <swiper-item> <image mode=\"widthFix\" src=\"https://m.360buyimg.com/mobilecms/s700x280_jfs/t1/143564/28/18582/124317/60667523E2a4840dd/301bbb3de0243db8.jpg!q70.jpg.dpg\" alt=\"\"/></swiper-item>\n  <swiper-item> <image mode=\"widthFix\" src=\"https://m.360buyimg.com/mobilecms/s700x280_jfs/t1/155887/8/16711/104572/60534627Eb979dc75/cc416de39d2e83b0.jpg!cr_1125x445_0_171!q70.jpg.dpg\" alt=\"\"/></swiper-item>\n</swiper>\n<!-- 单选框 -->\n<radio-group bindchange=\"bindChange\">\n  <radio name=\"sex\" value=\"male\">男</radio>\n  <radio name=\"sex\" value=\"female\">女</radio>\n  <view wx:if=\"{{gerder == 'male'}}\">-您选择的按钮为男</view>\n  <view wx:elif=\"{{gerder == 'female'}}\">-您选择的按钮为女</view>\n  <view wx:else=\"{{gerder == ''}}\">-您选择的按钮为</view>\n</radio-group>\n<!-- 复选框 -->\n<view>\n  <checkbox-group bindchange=\"bandelItemchange\">\n    <checkbox wx:for=\"{{fruit}}\" wx:key=\"id\" value=\"{{item.value}}\">\n      {{item.name}}\n    </checkbox>\n    <view>选中的是：{{checkList}}</view>\n</checkbox-group>\n</view>\n<!-- 组件 -->\n<Tabs></Tabs>\n<rich-text class=\"\" nodes=\"{{html}}\">\n  \n</rich-text>\n  \n<view>input标签</view>\n<input type=\"text\" bindinput=\"handleInput\"/>\n<view class=\"btn\">\n  <button size=\"mini\" bindtap=\"handeltap\" data-opertation=\"1\">+</button>\n<button size=\"mini\" bindtap=\"handeltap\" data-opertation=\"{{-1}}\">-</button>\n</view>\n<image mode=\"widthFix\" src=\"https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/wallhaven-oxxw29.webp\"></image>\n<view>{{num}}</view>\n<view>----------------------------</view>\n<text>测试页面</text>\n<view>'text'相当于web中的span元素，view相当于web中的div标签块级元素</view>\n<view>测试wx:for标签</view>\n<view>---------------------</view>\n<view>列表循环</view>\n<view wx:for=\"{{list}}\" wx:for-item=\"item\" wx:for-index=\"index\" wx:key=\"username\">\n  属性：{{item.id}}\n  索引: {{index}}\n  名称：{{item.name}}\n  年龄：{{item.age}}\n  年龄：{{item.msg.con}}\n</view>\n<view>对象循环</view>\n<view wx:for=\"{{msg}}\" wx:for-item=\"value\" wx:for-index=\"key\" wx:key=\"id\">\n  {{value}}\n  {{key}}\n</view>\n<view>---------------------</view>\n<view>测试 wx:if</view>\n<view wx:if=\"{{false}}\">1</view>\n<view wx:elif=\"{{false}}\">2</view>\n<view wx:elif=\"{{true}}\">3</view>\n<view>---------------------</view>\n<view>测试 hidden</view>\n<view hidden=\"{{true}}\">1</view>\n<view hidden>1</view>\n```\n{% endfolding %}\n\n## 事件绑定\n\n1. input标签绑定input事件  使用`bindinput`属性\n2. 通过事件源对象来获取input输入的值 `e.detail.value`\n3. 与data同级 并且可以将input中输入的值与data中定义的属性绑定，使用`this.setData({属性:e.detail.value})`\n4. 加入一个点击事件 `bindtap`属性，无法直接传参 通过自定义属性的方法来传参\n- 在自定义属性时要注意 如果传递的参数为数字，应该加`{{}}`使得传递的参数为number，不加为string\n- 注意input输入后的值为字符型，需要将输入的值转换\n\n## 图片问题\n\n1. 比例尺的关系 `1px =750rpx*设置的尺寸大小/page的宽度`\n2. text 才能实现长按复制  `selectable decode`解码和复制\n3. `image` 中属性`mode` `aspectFit` 是长边能显示出来  `aspecFill` 使得短边显示出来 `widthFix` 按照比例缩放\n4. 图片支持懒加载`lazy-load`   布尔值\n\n## 轮播图swiper\n\n1. 轮播项 `swiper-item` 标签里面放入图片 swiper 存在默认高度 150px\n2. 高度无法实现由内容撑开\n3. 图片使用`mode=“widthFix”`\n4. indicator-dots 显示面板指示点 `indicator-color`  `indicator-active-color`\n5. autoplay 自动轮播  5秒一次\n6. interval 可以切换时间间隔\n7. circular 是否循环轮播\n8. 给图片加100%宽度 ，swipter的高度自适应 `100vw * 图片的宽度 / 高度`\n{% folding green, 查看答案 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/21231sa.webp)\n{% endfolding %}\n{% folding green, 查看答案 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/fadsfdgdhfertrqrhf.webp)\n{% endfolding %}\n\n## navigator 导航\n\n1. `url` 表示要跳转的页面路径\n2. 相当于块级元素\n3. target 跳转小程序，默认当前小程序  可选值 `self/minProgram`\n4. open-type  跳转方式\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/dwadawdzxzx21342.png)\n\n## rich-text 富文本标签\n\n1. nodes 接受字符串\n2. 对象数组 \n\n## button标签\n\n1. size属性 ` default/ mini`\n2. open-type\n\n## icon图标 \n\n1. type类型\n2. size 大小 默认23\n3. color 改变颜色\n\n## radio/checkbox\n\n1. radio-ground 绑定change事件 `bindchange`\n2. checkbox-ground 绑定事件change\n\n## 自定义组件\n\n1. 在使用自定义组件时 要注意 在使用函数方法时要写到`methods`中\n2. 并且将被使用的组件写到需要渲染页面的json文件中\n3. 父组件向子组件 传递数据 通过自定义属性来传递  `properties`  要接受的数据名称 ·` type/value·`类型和值\n4. 子向父传递  `this.triggerEvent('名称',传递的参数)` 传递的时候要注意 传递的参数是什么形式，相对应\n5. 子传父,在子中定义一个要传递的事件方法和参数，在父中对事件方法进行绑定，然后在父中使用方法 \n6. 数据在谁上，谁有权修改\n\n{% folding green, 查看答案 %}\n```js\n    handleitemtap(e){\n      // 将点击的事件加入自定义属性\n      // console.log(e);\n      const {index} = e.currentTarget.dataset\n      let {tabs} = this.data\n      // console.log(index);\n      // 对以上的导航数据使用foreach进行遍历\n      tabs.forEach((v,i)=>i===index?v.isActive=true:v.isActive=false)\n      this.setData({\n        tabs\n      })\n    }\n-------------------\n<view class=\"nav\">\n  <view bindtap=\"handleitemtap\" wx:for=\"{{tabs}}\" wx:key=\"id\" class=\"title_item {{item.isActive?'active':''}}\" data-index=\"{{index}}\">{{item.name}}</view>\n</view>\n```\n{% endfolding %}\n\n1. slot标签其实就是一个占位符，等到父组件调用子组件的时候，在传递标签\n\n## 生命周期\n\n{% folding green, 查看答案 %}\n```js\n// app.js\nApp({\n  // 表示在应用第一次启用时就执行\n  onLaunch(e){\n    console.log(e);\n    console.log('launch');\n    // 不能触发\n    // wx.navigateTo({\n    //   url: 'url',\n    // })\n  },\n  // 应用被用户看到时执行\n  onShow(e){\n    // 对数据的重置\n    console.log('onshow');\n  },\n  // 应用被隐藏的时候所执行的\n  onHide(e){\n    // 清除定时器\n    console.log('onHide');\n  },\n  // 应用发生错误时执行\n  onError(err){\n    console.log('onError'); \n    // console.log(err);\n  },\n  // 应用找不到页面时触发\n  onPageNotFound(e){\n    // 无法跳转到tabbar页面，如果页面不存在可以重定向到第二个页面\n    console.log('onPageNotFound');\n    wx.navigateTo({\n      url: '/pages/demo/demo',\n    })\n  }\n})\n```\n{% endfolding %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/dawdawsadacthe3341.png)\n\n## 页面生命周期\n\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/dawdawade2131.png)\n\n## 项目制作\n\n1. promise封装函数\n{% folding green, 查看答案 %}\n```js\nexport const request=(params)=>{\n    return new Promise((resolve,reject)=>{\n        wx.request({\n          ...params,\n          success:(result)=>{\n              resolve(result)\n          },\n          fail:(err)=>{\n              reject(err)\n          }\n        });\n          \n    })\n}\n\nrequest({url:\"https://api-hmugo-web.itheima.net/api/public/v1/home/swiperdata\"})\n    .then(result=>{\n      this.setData({\n            swiper_list: result.data.message\n          })\n    })\n```\n{% endfolding %}\n\n## 缓冲事件\n\n1. 设置一个缓冲事件，获取本地的存储中的数据进行判断\n2. ·`{time:Date.now(),data:[...]}`\n3. web:` localStorage.setItem(\"key\",\"value\")` `localStorage.getItem(\"key\")`\n4. 优化接口的路径  使用prominse中的params将url解构出来\n\n## es7 async语法\n\n1. 解决回溯的最终方案\n2. async\n\n## 触底事件\n\n1. `onReachBottom` 页面触底事件\n2. 页面上拉触底事件的处理函数。触底事件，当页面触底之后，在进行请求，并且将请求到的数据在追加到原来的数组中，并且在触底后还要进行判断如果总数据的页数>=当前的页数，要返回wxwx.showToast({title: 'title',}),否则继续请求\n{% folding green, 查看答案 %}\n```js\n// pages/goods_list/goods_list.js\nimport { request } from \"../../request/index.js\";\nPage({\n\n  /**\n   * 页面的初始数据\n   */\n  data: {\n    // 将这些数据导入到子文件中\n    tabs: [{\n        id: 0,\n        value: '综合',\n        isActive: true\n      },\n      {\n        id: 1,\n        value: '销量',\n        isActive: false\n      },\n      {\n        id: 2,\n        value: '价格',\n        isActive: false\n      }\n    ],\n    first_list:[],\n  },\n    // 设置请求后返回的总页面的数量\n  totalpages:1,\n  handleChage(e){\n    // console.log(e);\n    // 将子传递给父亲的索引值解构出来\n    const {id} = e.detail\n    // 将父亲data的数据进行解构\n    let {tabs} = this.data\n    // 将data中的数据进行遍历 如果此时的索引值等于数据中的id值则将数据中的isActive的值改为true\n    // 这里的v表示的是遍历的数据，i表示的是索引号\n    tabs.forEach((v,i) =>i===id?v.isActive=true:v.isActive=false);\n    // 将这里修改的数据加到源数据中\n    this.setData({\n      tabs\n    })\n  },\n  // 页面触底事件\n\n  pageParams:{\n    query:'',\n    cid:'',\n    pagenum:1,\n    pagesize:10\n  },\n  // 对接口数据进行请求\n  async getgoodList(e){\n    const res = await request({\n      url:'/goods/search',\n      data: this.pageParams\n    })\n    console.log(res);\n    // 先获取页面的总数据，计算出页码信息\n    const goodspages = Math.ceil(res.data.message.total / this.pageParams.pagesize)\n    console.log(goodspages)\n    this.totalpages = goodspages\n    this.setData({\n      // 这一步是将请求到的数据在使用数组拼接的方式拼接起来，这里用到了数组解构的方法\n      first_list:[...this.data.first_list,...res.data.message.goods],\n    })\n  },\n  /**\n   * 生命周期函数--监听页面加载\n   */\n  onLoad: function (options) {\n    // console.log(options);\n    this.pageParams.cid = options.cat_id\n    this.getgoodList()\n  },\n    /**\n   * 页面上拉触底事件的处理函数。触底事件，当页面触底之后，在进行请求，并且将请求到的数据在追加到原来的数组中，并且在触底后还要进行判断如果总数据的页数>=当前的页数，要返回wxwx.showToast({title: 'title',}),否则继续请求\n   */\n  onReachBottom: function () {\n    this.pageParams.pagenum++;\n    // 进行页面触底的判断\n    if(this.totalpages<=this.pageParams.pagenum){\n      wx.showToast({\n        title: '页面加载完成',\n      })\n    }else{\n      this.getgoodList()\n    }\n    \n  },\n\n  /**\n   * 生命周期函数--监听页面初次渲染完成\n   */\n  onReady: function () {\n\n  },\n\n  /**\n   * 生命周期函数--监听页面显示\n   */\n  onShow: function () {\n\n  },\n\n  /**\n   * 生命周期函数--监听页面隐藏\n   */\n  onHide: function () {\n\n  },\n\n  /**\n   * 生命周期函数--监听页面卸载\n   */\n  onUnload: function () {\n\n  },\n\n  /**\n   * 页面相关事件处理函数--监听用户下拉动作\n   */\n  onPullDownRefresh: function () {\n\n  },\n  /**\n   * 用户点击右上角分享\n   */\n  onShareAppMessage: function () {\n\n  }\n})\n```\n{% endfolding %}\n\n## 下拉刷新页面\n\n1. 重置数据\n2. 重置页码 \n3. 然后在请求方法的最后加上 关闭下拉刷新的方法\n4. 显示加载中提示，在页面请求之前显示 `complete方法`\n5. 在页面请求加载之前首先先显示加载按钮在页面加载结束后隐藏 调用wx.request方法中的第三个函数方法complete\n\n{% folding green, 查看答案 %}\n```js\n// 如果在执行异步操作时，对隐藏加载按钮进行处理，不做处理页面还未加载完成就结束了\nlet ajaxtimes = 0;\nexport const request=(params)=>{\n    ajaxtimes++;\n    // 在页面请求加载之前首先先显示加载按钮在页面加载结束后隐藏 调用wx.request方法中的第三个函数方法complete\n    wx.showLoading({\n        title: '加载中',\n      })\n    // 将接口的公共部分解构出来，在进行拼接\n    const baseUrl = 'https://api-hmugo-web.itheima.net/api/public/v1'\n    return new Promise((resolve,reject)=>{\n        wx.request({\n          ...params,\n          url:baseUrl+params.url,\n          success:(result)=>{\n              resolve(result)\n          },\n          fail:(err)=>{\n              reject(err)\n          },\n        //   请求完成或者失败都会执行\n          complete:()=>{\n              ajaxtimes--;\n            //   如果ajaxtimes的值不等于0，不执行隐藏函数\n            if(ajaxtimes===0){\n                wx.hideLoading()\n            } \n          }\n        });    \n    })\n}\n```\n{% endfolding %}\n\n## css省略号\n\n{% folding green, 查看答案 %}\n```css\ndisplay: -webkit-box;\n-webkit-box-orient: vertical;\n-webkit-line-clamp: 2;\noverflow: hidden;\n```\n{% endfolding %}\n\n## 预览大图\n\n1. 点击轮播图位置得图片实现大图得预览效果\n2. 为轮播图添加一个点击事件\n3. 使用事件 `previewImage`\n4. 给小程序添加大图预览效果 使用  wx.previewImage方法来实现，首先是在轮播图的遍历图片的位置添加一个函数方法，然后在方法内使用pre方法，并且将获取到的图片从列表中选出后生成一个新的列表使用map方法,由于是异步函数，所以必须将列表单独拿出来,给swiper加上一个自定义id值，当用户点击某一张图片时将该图片放大,获取该点击事件得图片id值，使用解构得方法\n\n## 购物车模拟\n\n1. 对加入购物车事件进行处理，点击加入购物车 先对本地缓冲中得cart缓冲进行判断如果存在则使得该商品得总数num+1，否则将当前商品得数量设置为1，使用`findIndex`方法，如果不满足条件则返回-1\n{% folding green, 查看答案 %}\n```js\n  handleshopAdd(e) {\n    let cart = wx.getStorageSync('cart') || []\n    let index = cart.findIndex(v =>v.data.message.goods_id === this.infoData.data.message.goods_id)\n    if (index === -1) {\n      this.infoData.num = 1\n      cart.push(this.infoData)\n    } else {\n      cart[index].num++;\n      // console.log(cart[index].num);\n    }\n    // console.log(index);\n    wx.setStorageSync('cart', cart)\n    wx.showToast({\n      title: '加入购物车成功',\n      icon: 'success',\n      // 防抖操作\n      mask: true\n    })\n  }\n```\n{% endfolding %}\n\n\n## 获取地址信息\n\n{% folding green, 查看答案 %}\n```js\ndata: {\n    address: false\n  },\n  // 点击获取地址按钮事件\n  handleButtonAddress(e){\n    // console.log(e);\n    // 将获取到得地址信息存入到缓冲中\n    wx.chooseAddress({\n      success: (result) => {\n        // console.log(result);\n        // 设置一个缓冲信息\n        wx.setStorageSync('address', result);\n      }\n    }) \n  },\n  // 在onshow事件内进行判断如果缓冲中存在数据则将地址呈现到页面中\n  onShow: function(){\n    // 先判断缓冲中是否存在信息，如果存在将数据存入到 data中并呈现到页面中\n    // 先获取缓冲中得数据\n    let address = wx.getStorageSync('address');\n    if(address){\n      this.setData({\n        address\n      })\n      // 将数据呈现到页面中\n      console.log(this.data.address);\n    }else{\n      console.log('缓冲中得数据不存在');\n    }\n}\n```\n{% endfolding %}\n\n## 结算功能\n\n1. 使用遍历中的every方法\n\n{% folding green, 查看答案 %}\n```js\n//Page Object\nPage({\n  data: {\n    address: false,\n    cart_list: [],\n    Allchecked: false,\n    totalPrice:0,\n    totalNum:0\n  },\n  // 点击获取地址按钮事件\n  handleButtonAddress(e) {\n    // console.log(e);\n    // 将获取到得地址信息存入到缓冲中\n    wx.chooseAddress({\n      success: (result) => {\n        console.log(result);\n        // 设置一个缓冲信息\n        wx.setStorageSync('address', result);\n      }\n    })\n  },\n  // 在onshow事件内进行判断如果缓冲中存在数据则将地址呈现到页面中\n  onShow: function () {\n    // 先判断缓冲中是否存在信息，如果存在将数据存入到 data中并呈现到页面中\n    // 先获取缓冲中得数据\n    let address = wx.getStorageSync('address');\n    // 获取缓存中的购物车信息\n    const cart_list = wx.getStorageSync('cart') || []\n    // 使用遍历方法every \n    // const Allchecked = cart_list.length ? cart_list.every(v => v.checked) : false\n    // 购物车结算，将用户选中的商品的数量相加，为总数量；单个商品的价格和数量相乘相加得到商品的总价格\n    this.setCart(cart_list)\n    if (address) {\n      this.setData({\n        address\n      })\n      // 将数据呈现到页面中\n      // console.log(this.data.address);\n    }\n  },\n  // 给checkbox添加一个改变属性\n  handleItemChecked(e){\n    // console.log(e);\n    // 获取选中改变商品的id,解构出来\n    const {id} = e.currentTarget.dataset\n    // 找到缓冲中的相应的商品，同时进行判断如果修改checed属性值\n    const {cart_list} = this.data\n    // 使用findIndex方法对缓冲中的数组进行遍历\n    const index = cart_list.findIndex(v=>v.data.message.goods_id==id)\n    // 找出用户改变商品选中状态的索引值,修改该索引值下商品的checked的值\n    cart_list[index].checked = !cart_list[index].checked\n    // console.log(index);\n    this.setCart(cart_list)\n  },\n  // 封装一个计算商品总数和商品总价格的函数方法\n  setCart(cart_list){\n    let totalPrice = 0;\n    let totalNum = 0;\n    let Allchecked = true\n    // 使用forEach方法对缓冲中的数组进行遍历\n    cart_list.forEach(v=>{\n      if(v.checked){\n        totalPrice += v.data.message.goods_price*v.num\n        totalNum += v.num\n      }else{\n        Allchecked= false\n      }\n    })\n    // 并且当用户的列表为空时不进行遍历\n    Allchecked=cart_list.length !=0?Allchecked:false\n    // console.log(cart_list);\n    // console.log(Allchecked);\n    this.setData({\n      cart_list,\n      Allchecked,\n      totalPrice,\n      totalNum\n    })\n  },\n```\n{% endfolding %}\n\n## 登录获取用户信息\n\n1. 使用getgetUserProfile\n\n{% folding green, 查看答案 %}\n```js\n  getUserProfile(e) {\n    // console.log(e);\n    // 判断缓冲中是否存在用户id\n    wx.getUserProfile({\n      desc: '用于完善会员资料', // 声明获取用户个人信息后的用途，后续会展示在弹窗中，请谨慎填写\n      success: (res) => {\n        this.setData({\n          userInfo: res.userInfo,\n          hasUserInfo: true\n        })\n        wx.setStorageSync('userinfo', res.userInfo);\n        const userinfo = wx.getStorageSync('userinfo');\n        if (userinfo) {\n          wx.switchTab({\n            url: '/pages/user/user'\n          })\n        }\n      }\n    })\n  }\n```\n{% endfolding %}\n\n## 防抖和节流\n\n1. 使用定时器解决防抖\n\n## 图片的上传\n\n","categories":["web","wx"]},{"title":"ajax的学习 整理","url":"/posts/18286/","content":"\n## Ajax运行原理\n\n> Ajax相当于浏览器发送请求与接受响应的代理人,以实现不影响用户浏览页面的情况下，局部更新页面数据，从而提高用户体验\n\n## 实现步骤\n\n1. 创建Ajax对象  `new XMLHttpRequest()`\n2. 告诉Ajax请求地址以及请求方式 ` open`\n3. 发送请求` send`方法\n4. 获取服务器端给予客户端的响应数据 onload   获取响应数据` responseText`\n\n{% folding green, 查看答案 %}\n```js\n// 1. 创建ajax对象\nvar xhr = new XMLHttpRequest()\n// 2. 告诉ajax对象发送的位置，和方式,第一个参数是请求方式，第二个请求地址\nxhr.open('get', 'http://localhost:3000/first')\n// 3. 发送请求\nxhr.send()\n// 4. 获取响应数据\nxhr.onload = function(){\nconsole.log(xhr.responseText);\n}\n```\n{% endfolding %}\n\n## 响应的数据格式\n\n1. json对象作为响应数据的格式，请求返回的数据为json字符串\n2. 将json字符串转化为json对象\n\n{% folding green, 查看答案 %}\n```js\n// 1. 创建ajax对象\nvar xhr = new XMLHttpRequest()\n// 2. 告诉ajax对象发送的位置，和方式,第一个参数是请求方式，第二个请求地址\nxhr.open('get', 'http://localhost:3000/responseData')\n// 3. 发送请求\nxhr.send()\n// 4. 获取响应数据，接受完请求后onload事件自动响应\nxhr.onload = function(){\n// 返回的是字符串类型\n// console.log(xhr.responseText);\n// 将json字符串转换为json对象\nlet respnseText = JSON.parse(xhr.responseText)\nconsole.log(respnseText);\nconsole.log(typeof respnseText);\n// 将转换的json对象中的信息获取，并且将数据信息渲染到页面中\nlet str = `<h2>${respnseText.name}</h2>`\ndocument.body.innerHTML = str\n}\n```\n{% endfolding %}\n\n## 请求参数传递\n\n1. get请求`xx.open('get',url)`\n\n{% folding green, 查看答案 %}\n```js\n        let username =document.querySelector('#username')\n        let email =document.querySelector('#email')\n        let submit =document.querySelector('#submit')\n\n        // 给按钮添加一个点击事件\n        submit.onclick = function(){\n            // 获取从用户在表单中输入的值\n            let emaildata = email.value\n            let usernamedata = username.value\n            // 对获取到数据进行字符串的拼接\n            let str = `username=${usernamedata}&email=${emaildata}`\n            // 创建一个ajax对象\n            console.log(str);\n            let xhr = new XMLHttpRequest()\n            // 创建ajax对象的请求方式\n            xhr.open('get',`http://localhost:3000/get?${str}`)\n            xhr.send()\n            xhr.onload = function(){\n                console.log(xhr.responseText);\n            }\n        }\n// res.send(req.query)\n```\n{% endfolding %}\n\n2. get请求只能的请求头类型只能是`application/x-www-form-urlencoded`,并且在解析请求地址时通过 body-parser中的urlencoded()方法进行解析,get请求不能提交对象数据格式的\n\n\n## post请求方式\n1. 请求的方式为json时，如果要得到请求的json内容 需要使用 body-parser中的bodyPaser.json()方法\n\n```js\n    // 1. 创建ajax对象\n    var xhr = new XMLHttpRequest()\n    // 2. 告诉ajax对象发送的位置，和方式,第一个参数是请求方式，第二个请求地址\n    xhr.open('post', 'http://localhost:3000/json')\n    xhr.setRequestHeader('Content-Type','application/json');\n    \n    // 3. 发送请求\n    xhr.send(JSON.stringify({name:'list',age:50}))\n    // 4. 获取响应数据，接受完请求后onload事件自动响应\n    xhr.onload = function(){\n        // 返回的是字符串类型\n        console.log(xhr.responseText);\n        // 将json字符串转换为json对象\n    }\n```\n\n## ajax状态码\n\n1. 获取服务器端的响应\n2. 0 请求未初始化\n3. 1 请求以及简历，但是还没有发送\n4. 2 请求已经发送\n5. 3 表示请求正在处理中，部分代码可以使用\n6. 4 响应已经完成  \n7. xhr.readyState  获取Ajax状态码  onreadystatechange事件\n8. onload比以上事件的请求方式更为效率\n\n## ajax错误处理\n\n1. xhr.status获取http状态码 400\n```js\n  var btn = document.getElementById('btn')\n        // 当用户点击后发送错误请求\n        btn.onclick=()=>{\n            var xhr = new XMLHttpRequest()\n            xhr.open('get','http://localhost:3000/error')\n            // 对请求的http的状态码进行判断\n            xhr.send();\n            xhr.onload=()=>{\n                console.log(xhr.status);\n                if(xhr.status === 400){\n                    alert(xhr.responseText)\n                }\n            }\n        }\n```\n\n2. 404错误状态码 输入错误的情况较多 ,检测请求地址是否有误\n3. 500错误代码时服务器端错误\n4. 断网时无法触发onload事件，可以执行onerror()事件\n\n`注意`ajax状态码表示的是服务器的请求过程的状态，http状态码表示的是请求的结果\n\n## 低版本的缓存问题\n\n1. 在请求地址上加一个参数，并且保证每次请求参数的值不同即可\n\n## 同步异步\n\n1. 封装一个简单的异步函数`get`\n2. get请求需要拼接到请求地址的后方，post请求放在send的方法中\n\n{% folding green, 查看答案 %}\n```js\nfunction ajax (params){\n    let xhr = new XMLHttpRequest();\n    let options = ''\n    params.data.forEach((v,i)=>{\n        params += v + '=' + params.data[i] + '&'\n    })\n    params.substr(0,params.length-1)\n    xhr.open(\n        params.type,params.url\n    )\n    xhr.send()\n    xhr.onload = ()=>{\n        params.success(xhr.responseText)\n    }\n}\najax({\n    type:'get',\n    url:'http://localhost:3000/first1',\n    data:{\n        name:'zs',\n        age:20\n    }\n    success:(data)=>{\n        console.log('这里是success函数'+data);\n    }\n})\n```\n{% endfolding %}\n\n2. 封装get请求和post请求参数的时候\n\n{% folding green, 查看答案 %}\n```js\nfunction ajax(params) {\n    let xhr = new XMLHttpRequest();\n    let options = ''\n    for (let attr in params.data) {\n        options += attr + '=' + params.data[attr] + '&'\n    }\n    options = options.substr(0, options.length - 1)\n    // console.log(options)\n    if (params.type === 'get') {\n        params.url = params.url + '?' + options\n    }\n    xhr.open(params.type, params.url)\n    if (params.type == 'post') {\n        let contentType = params.header['Content-Type']\n        xhr.setRequestHeader('Content-Type', contentType)\n        if (contentType === 'application/json') {\n            xhr.send(JSON.stringify(params.data))\n        } else {\n            xhr.send(options)\n        }\n    } else {\n        xhr.send()\n    }\n    xhr.onload = () => {\n        // 对http的状态码进行判断如果状态码为200则调用success函数，如果失败则调用error函数\n        if (xhr.status == 200) {\n            let responseHeader = xhr.getResponseHeader('Content-Type')\n            let resText = xhr.responseText\n            if (responseHeader.includes('application/json')) {\n                resText = JSON.parse(resText)\n            }\n            params.success(resText, xhr)\n        } else {\n            params.error(resText, xhr)\n        }\n    }\n}\najax({\n    type: 'get',\n    url: 'http://localhost:3000/responseData',\n    data: {\n        name: 'sz',\n        age: 20\n    },\n    header: {\n        'Content-Type': 'application/json'\n        // 'Content-Type':'application/x-www-form-urlencoded'\n    },\n    success: (data,xhr) => {\n        console.log('这里是success函数');\n        console.log(data);\n        console.log(xhr);\n    },\n    error: (data) => {\n        console.log('这里是error函数' + data);\n    }\n})\n```\n{% endfolding %}\n\n3. 获取请求中的数据 `getResponseHeader()`方法  在页面加载完成后调用`onload`事件中 如果获取到的请求类型为`application/json`类型,将json字符串以json对象的方式输出，使用方法`JSON.parse()`\n4. `Object.assign()`  如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。并且该方法是`浅拷贝`\n\n{% folding green, 查看答案 %}\n```js\nfunction ajax(params) {\n    // 给ajax设定一个默认值\n    let defaults = {\n        type: 'get',\n        url: '',\n        data: {},\n        header: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        success: (data) => {\n\n        },\n        error: (data) => {\n\n        }\n    }\n    // 使用Object.assign()方法 将之间的对象覆盖\n    Object.assign(defaults,params)\n    let xhr = new XMLHttpRequest();\n    let options = ''\n    for (let attr in params.data) {\n        options += attr + '=' + defaults.data[attr] + '&'\n    }\n    options = options.substr(0, defaults.length - 1)\n    // console.log(options)\n    if (defaults.type === 'get') {\n        defaults.url = defaults.url + '?' + options\n    }\n    xhr.open(defaults.type, defaults.url)\n    if (defaults.type == 'post') {\n        let contentType = defaults.header['Content-Type']\n        xhr.setRequestHeader('Content-Type', contentType)\n        if (contentType === 'application/json') {\n            xhr.send(JSON.stringify(defaults.data))\n        } else {\n            xhr.send(options)\n        }\n    } else {\n        xhr.send()\n    }\n    xhr.onload = () => {\n        // 对http的状态码进行判断如果状态码为200则调用success函数，如果失败则调用error函数\n        if (xhr.status == 200) {\n            let responseHeader = xhr.getResponseHeader('Content-Type')\n            let resText = xhr.responseText\n            if (responseHeader.includes('application/json')) {\n                resText = JSON.parse(resText)\n            }\n            defaults.success(resText, xhr)\n        } else {\n            defaults.error(resText, xhr)\n        }\n    }\n}\najax({\n    url: 'http://localhost:3000/responseData',\n    data: {\n        name: 'sz',\n        age: 20\n    },\n    success: (data, xhr) => {\n        console.log('这里是success函数');\n        console.log(data);\n        console.log(xhr);\n    }\n})\n```\n{% endfolding %}\n## 模板引擎\n\n1. 使用模板引擎 `art-template` 在客户端的使用步骤\n\n{% folding green, 查看答案 %}\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>模板引擎</title>\n    <script src=\"/js/art-template.js\"></script>\n</head>\n<body>\n    <div class=\"container\"></div>\n    <script type=\"text/html\" id=\"idt\">\n        <h1>{{username}} {{age}}</h1>\n    </script>\n    <script type=\"text/javascript\">\n        let html = template('idt',{username:'zs',age:20})\n        document.querySelector('.container').innerHTML = html\n    </script>\n</body>\n</html>\n```\n{% endfolding %}\n\n\n## 验证邮箱\n\n{% folding green, 查看答案 %}\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>验证邮箱地址</title>\n    <script src=\"/js/ajax.js\"></script>\n    <!-- <script src=\"/js/template.js\"></script> -->\n</head>\n\n<body>\n    <style>\n        body {\n            background: -webkit-linear-gradient(left, rgb(216, 236, 235), rgb(241, 229, 241));\n        }\n\n        .box {\n            margin: 200px auto;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            flex-direction: column;\n        }\n\n        .email_login {\n            border-radius: 10px;\n            width: 400px;\n            height: 30px;\n            padding: 10px;\n            /* outline-color: aliceblue; */\n        }\n\n        .email_login:hover {\n            outline-color: bisque;\n            border: none;\n        }\n\n        .message {\n            background: rgb(221, 208, 208);\n        }\n\n        .success {\n            background-color: rgb(82, 82, 173);\n        }\n\n        .error {\n            background-color: rgb(226, 106, 106);\n        }\n    </style>\n    <div class=\"box\">\n        <input type=\"email\" class=\"email_login\" value=\"\" placeholder=\"请在此输入您要初测的邮箱账号！！\">\n        <p class=\"message\"></p>\n    </div>\n    <script type=\"text/javascript\">\n        // 获取元素\n        let email = document.querySelector('.email_login')\n        let message = document.querySelector('p')\n        // 当输入框失去焦点时的事件\n        email.onblur = function () {\n            // console.log(e);\n            // 获取用户输入的值，对用户输入的值判断\n            let email_value = this.value\n            // 正则判断输入的值\n            let reg = /^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$/\n            if (!reg.test(email_value)) {\n                message.innerHTML = '输入的邮箱规则格式有误，请重新输入！！！'\n                message.className = 'message'\n                return;\n            }\n            ajax({\n                type: 'post',\n                url: \"http://localhost:3000/emailbox\",\n                data: {\n                    email: email_value\n                },\n                success: function (response) {\n                    if (response.message.includes('恭喜')) {\n                        message.innerHTML = response.message\n                        message.className = 'success'\n                    } else {\n                        message.innerHTML = response.message\n                        message.className = 'error'\n                    }\n                },\n                error: (res) => {\n                    message.innerHTML = res.message\n                    message.className = 'error'\n                }\n            });\n        }\n\n    </script>\n</body>\n</html>\n```\n{% endfolding %}\n\n{% folding green, 请求路由 %}\n```js\napp.get('/emailbox',(req,res)=>{\n    if(req.query.email == 'iui9@qq.com'){\n        res.send({message:'您好邮箱已注册，请您重新输入！！'})\n    }else{\n        res.send({message:'恭喜您注册的邮箱可用！！！！'})\n    }\n})\napp.post('/emailbox',(req,res)=>{\n    if(req.body.email == 'iui9@qq.com'){\n        res.send({message:'您好邮箱已注册，请您重新输入！！'})\n    }else{\n        res.send({message:'恭喜您注册的邮箱可用！！！！'})\n    }\n})\n```\n{% endfolding %}\n\n{% folding green, ajax封装 %}\n```js\nfunction ajax(params) {\n    // 给ajax设定一个默认值\n    let defaults = {\n        type: 'get',\n        url: '',\n        data: {},\n        header: {\n            'Content-Type': 'application/json'\n        },\n        success: (data) => {},\n        error: (data) => {}\n    }\n    // 使用Object.assign()方法 将之间的对象覆盖\n    Object.assign(defaults,params)\n    let xhr = new XMLHttpRequest();\n    let options = ''\n    for (let attr in params.data) {\n        options += attr + '=' + defaults.data[attr] + '&'\n    }\n    options = options.substr(0, defaults.length - 1)\n    // console.log(options)\n    if (defaults.type === 'get') {\n        defaults.url = defaults.url + '?' + options\n    }\n    xhr.open(defaults.type, defaults.url)\n    if (defaults.type == 'post') {\n        let contentType = defaults.header['Content-Type']\n        xhr.setRequestHeader('Content-Type', contentType)\n        if (contentType === 'application/json') {\n            xhr.send(JSON.stringify(defaults.data))\n        } else {\n            xhr.send(options)\n        }\n    } else {\n        xhr.send()\n    }\n    xhr.onload = () => {\n        // 对http的状态码进行判断如果状态码为200则调用success函数，如果失败则调用error函数\n        if (xhr.status == 200) {\n            let responseHeader = xhr.getResponseHeader('Content-Type')\n            let resText = xhr.responseText\n            if (responseHeader.includes('application/json')) {\n                resText = JSON.parse(resText)\n            }\n            defaults.success(resText, xhr)\n        } else {\n            defaults.error(resText, xhr)\n        }\n    }\n}\n```\n{% endfolding %}\n\n## 搜索框内容自动提示\n\n1. 使用定时器的操作，延时对请求接口发送ajax请求，在每次请求之前将之前的定时器清除\n2. 设置防抖操作，对用户输入的值进行判断如果用户没有在手术框中输入内容，将提示信息  使用trim()函数，将文本框中的空格清除 阻止程序向下执行 `return`\n\n## 三级联动（省市区）\n\n\n\n1. 接口地址：[接口地址](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/province1.json)\n2. JSON.stringify() 方法可以将对象的数据存储在本地的内存中\n\n{% folding green, 查看答案 %}\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>三级联动 省市区</title>\n    <script src=\"js/ajax.js\"></script>\n    <script src=\"js/art-template.js\"></script>\n</head>\n<style>\n    body {\n        background-color: #ccc;\n    }\n\n    .box {\n        margin: 100px auto;\n        width: 500px;\n        height: 300px;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n    }\n</style>\n\n<body>\n    <div class=\"box\">\n        <div class=\"form_group\">\n            <select name=\"\" id=\"province\">\n                <!-- <option value=\"\">请选择省份</option> -->\n            </select>\n        </div>\n        <div class=\"form_group\">\n            <select name=\"\" id=\"city\">\n                <option value=\"\">请选择城市</option>\n            </select>\n        </div>\n        <div class=\"form_group\">\n            <select name=\"\" id=\"area\">\n                <option value=\"\">请选择县城</option>\n            </select>\n        </div>\n    </div>\n</body>\n<script type=\"text/html\" id=\"provinceTpl\">\n    <option value=\"\">请选择省份</option>\n    {{each provices_list}}\n        <option value=\"{{$value.pindex}}\">{{$value.provices_list}}</option>\n    {{/each}}\n</script>\n<script type=\"text/html\" id=\"cityTpl\">\n    <option value=\"\">请选择城市</option>\n    {{each city_lists}}\n    <option value=\"\">{{$value.citysName}}</option>\n    {{/each}}\n</script>\n<script>\n    // 封装一个函数\n    let All_lists = []\n    function getaddressData() {\n        ajax({\n            type: \"get\",\n            url: \"https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/province1.json\",\n            success: function (response) {\n                console.log(response);\n                All_lists = response.provinces\n                localStorage.setItem('address_data', JSON.stringify(response.provinces))\n            }\n        });\n    }\n    let province = document.querySelector('#province')\n    let city = document.querySelector('#city')\n    let addressData = localStorage.getItem('address_data')\n    if (!addressData) {\n        this.getaddressData()\n    } else {\n        All_lists = JSON.parse(addressData)\n        let provices_list = All_lists.map((v,i) => {\n            let arr = {provices_list:v.provinceName,pindex:i}\n            return arr\n        })\n        // console.log(provices_list);\n        let html = template('provinceTpl',{provices_list})\n        province.innerHTML = html\n    }\n    // 给省份选择框添加一个改变事件监听 select的变化\n    province.onchange = function(e){\n        let id = this.value\n        let city_lists = JSON.parse(addressData)[Number(id)].citys\n        // console.log(city_lists);\n        let html1 = template('cityTpl',{city_lists})\n        city.innerHTML = html1\n    }\n</script>\n\n</html>\n```\n{% endfolding %}\n\n## FormData对象的作用\n\n1. 模拟HTML表单\n2. 异步上传二进制文件\n3. 本身是一个构造函数\n4. 使用formidable模块来解析FormData对象\n5. formData.get('属性名')，formData.set('属性名','属性值')，formData.delete('key'),formData.append('key','value')\n6. 默认接收最后一个实例方法\n7. set方法和append方法的区别：在属性名已经存在的情况下，set会覆盖原来的键名的值，append会保留两个值\n\n{% folding green, 查看答案 %}\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>FormData对象</title>\n</head>\n<body>\n    <form id=\"form\">\n        <input type=\"text\" name=\"username\" id=\"\" />\n        <input type=\"password\" name=\"password\" id=\"\" />\n        <input type=\"button\" id=\"btn\" value=\"提交\"/>\n    </form>\n    <script type=\"text/javascript\">\n    // 获取按钮\n    var btn = document.querySelector('#btn')\n    var form = document.querySelector('#form')\n    btn.onclick = function(){\n        // 将普通的html表单转换为表单对象\n        let formData = new FormData(form)\n        let xhr = new XMLHttpRequest()\n        xhr.open('post','http://localhost:3000/formData')\n        // 发送ajax请求\n        xhr.send(formData)\n        // 监听xhr对象下面的onload事件\n        xhr.onload = function(){\n            if(xhr.status==200){\n                console.log(xhr.responseText);\n            }\n        }\n    }\n    </script>\n</body>\n</html>\n```\n{% endfolding %}\n\n{% folding green, 配置路由 %}\n```js\n// 加入formidable模板\napp.post('/formData',(req,res)=>{\n    const form = new formidable.IncomingForm();\n    form.parse(req,(err,fields,files)=>{\n        res.send(fields)\n    })\n})\n```\n{% endfolding %}\n## formData二进制上传\n\n1. get请求方式不能用于文件的上传\n\n{% folding green, 查看答案 %}\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>FormData二进制文件的上传</title>\n</head>\n\n<body>\n    <input type=\"file\" name=\"\" id=\"file\" />\n    <script type=\"text/javascript\">\n        let file = document.querySelector('#file')\n        file.onchange = function(){\n            let formData = new FormData()\n            formData.append('attrName',this.files[0])\n            var xhr = new XMLHttpRequest()\n            xhr.open('post','http://localhost:3000/up_file')\n            xhr.send(formData)\n            xhr.onload = function(){\n                if(xhr.status==200){\n                    console.log(xhr.responseText);\n                }\n            }\n        }\n    </script>\n</body>\n\n</html>\n```\n{% endfolding %}\n\n## 上传进度条\n\n1. 使用上传事件中的`onprogress`事件\n\n{% folding green, 查看答案 %}\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>上传进度条</title>\n</head>\n<style>\n    .progress_warp{\n        width: 800px;\n        height: 40px;\n        background-color: #ccc;\n        border-radius: 5px;\n    }\n    .progress_event{\n        border-radius: 5px;\n        width: 0;\n        height: 100%;\n        color: #fff;\n        background-color: rgb(53, 27, 68);\n    }\n</style>\n<body>\n    <input type=\"file\" name=\"\" id=\"file\" />\n    <div class=\"progress_warp\">\n        <div class=\"progress_event\" style=\"width: 0%;\" id=\"bar\"></div>\n    </div>\n    <script type=\"text/javascript\">\n        let file = document.querySelector('#file')\n        let bar = document.querySelector('#bar')\n        file.onchange = function(){\n            let formData = new FormData()\n            formData.append('attrName',this.files[0])\n            var xhr = new XMLHttpRequest()\n            xhr.open('post','http://localhost:3000/up_file')\n            xhr.upload.onprogress = function(e){\n                // console.log(e);\n                let bar_data = (e.loaded / e.total).toFixed(2) * 100 + '%'\n                bar.style.width = bar_data\n                bar.innerHTML = bar_data\n            }\n            xhr.send(formData)\n            xhr.onload = function(){\n                if(xhr.status==200){\n                    console.log(xhr.responseText);\n                }\n            }\n        }\n    </script>\n</body>\n</html>\n```\n{% endfolding %}\n\n## 图片加载预览\n\n{% folding green, 查看答案 %}\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>上传进度条</title>\n</head>\n<style>\n    .progress_warp{\n        width: 800px;\n        height: 40px;\n        background-color: #ccc;\n        border-radius: 5px;\n    }\n    .box_img{\n        padding: 20px;\n    }\n    .box_img img{\n        width: 100px;\n        border-radius: 10px;\n    }\n    .progress_event{\n        border-radius: 5px;\n        width: 0;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        font-size: 20px;\n        font-weight: 550;\n        margin: 10px 0;\n        height: 100%;\n        color: #fff;\n        background-color: rgb(53, 27, 68);\n    }\n</style>\n<body>\n    <input type=\"file\" name=\"\" id=\"file\" />\n    <div class=\"box_img\">\n        \n    </div>\n    <div class=\"progress_warp\">\n        <div class=\"progress_event\" style=\"width: 0%;\" id=\"bar\"></div>\n    </div>\n    <script type=\"text/javascript\">\n        let file = document.querySelector('#file')\n        let bar = document.querySelector('#bar')\n        let box_img = document.querySelector('.box_img')\n        file.onchange = function(){\n            let formData = new FormData()\n            formData.append('attrName',this.files[0])\n            var xhr = new XMLHttpRequest()\n            xhr.open('post','http://localhost:3000/up_file')\n            xhr.upload.onprogress = function(e){\n                // console.log(e);\n                let bar_data = (e.loaded / e.total).toFixed(2) * 100 + '%'\n                bar.style.width = bar_data\n                bar.innerHTML = bar_data\n            }\n            xhr.send(formData)\n            xhr.onload = function(){\n                if(xhr.status==200){\n                    // console.log(xhr.responseText);\n                    // 动态创建一个图片 将上传的文件的路径名称赋值给uploads\n                    let img = document.createElement('img')\n                    img.src= '/uploads' + JSON.parse(xhr.responseText).path\n                    // 调用图片上传成功的事件onload\n                    img.onload = function (){\n                        box_img.appendChild(img)\n                    }\n                }\n            }\n        }\n    </script>\n</body>\n</html>\n```\n{% endfolding %}\n\n## ajax问题\n\n1. ajax不能向非同源服务器端发送请求\n2. 使用jsonp解决同源限制问题   \n- 将不同源的服务器请求地址写在script标签的src属性中\n- 服务端响应数据必须是以一个函数的调用\n- 在客户端全局作用域下定义函数fn（在script标签的上面）\n- 在函数内部对服务器端返回的数据进处理\n\n## post请求格式\n\n1. 必须有请求头：content-type:application/x-www-form-unlencoded\n{% folding red, 查看解析 %}\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>post请求的两种方式</title>\n</head>\n\n<body>\n    <!-- 第一种使用url形式的请求方式 -->\n    <!-- <script type=\"text/javascript\">\n        let xhr = new XMLHttpRequest()\n        xhr.open('post', 'http://localhost:3000/post')\n        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')\n        params = \"name=zs&age=12\"\n        xhr.send(params)\n        xhr.onload = function () {\n            console.log(xhr.responseText);\n        }\n    </script> -->\n    <!-- 第二种使用json形式 -->\n    <script type=\"text/javascript\">\n        let xhr = new XMLHttpRequest()\n        xhr.open('post', 'http://localhost:3000/post')\n        xhr.setRequestHeader('Content-Type', 'application/json')\n        params = {\n            name: 'zs',\n            age: 2\n        }\n        xhr.send(JSON.stringify(params))\n        xhr.onload = function () {\n            console.log(xhr.responseText);\n        }\n    </script>\n</body>\n</html>\n```\n{% endfolding %}\n\n## jsonp请求封装\n\n{% folding red, 查看客户端 %}\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>jsonp的调用</title>\n</head>\n\n<body>\n    <button id=\"btn1\">jsonP提交</button>\n    <button id=\"btn2\">jsonP提交</button>\n    <script>\n        let btn1 = document.getElementById('btn1')\n        let btn2 = document.getElementById('btn2')\n        btn2.onclick = function () {\n            jsonP({\n                url: 'http://localhost:3000/better',\n                data:{\n                    name:'zs',\n                    age:23\n                },\n                success: (e) => {\n                    console.log(e)\n                    console.log(123)\n                }\n            })\n        }\n        // 封装一个jsonP函数\n        function jsonP(e) {\n            var script = document.createElement('script')\n            // 将传递的data取出来\n            params = ''\n            for(let arr in e.data){\n                params+=`&${arr}=${e.data[arr]}`\n            }\n            // 设置window下的随机函数名\n            fName = 'myjson' + Math.random().toString().replace('.', '')\n            // 设置src中的请求地址\n            window[fName] = e.success\n            script.src = e.url + `?callback=${fName+params}`\n            document.body.appendChild(script)\n            script.onload = function () {\n                document.body.removeChild(script)\n            }\n        }\n    </script>\n</body>\n</html>\n```\n{% endfolding %}\n{% folding red, 查看服务器 %}}\n```js\napp.get('/better',(req,res)=>{\n    // const fName = req.query.callback\n    // const result = fName + '({name:\"zs\"})'\n    // res.send(result)\n    res.jsonp({name:'zs',age:98})\n})\n```\n{% endfolding %}\n\n\n## 腾讯天气API\n\n{% folding red, 查看解析 %}\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <script src=\"https://cdn.jsdelivr.net/gh/Rr210/hexofixed@v0.47/js/jquery-3.5.1.min.js\"></script>\n    <link rel=\"stylesheet\"\n        href=\"https://cdn.jsdelivr.net/gh/Rr210/hexofixed@frame/frame/bootstrap/3/css/bootstrap.min.css\">\n    <script src=\"https://cdn.jsdelivr.net/gh/Rr210/hexofixed@frame/frame/bootstrap/3/js/bootstrap.min.js\"></script>\n    <script src=\"/js/art-template.js\"></script>\n    <title>Document</title>\n</head>\n<style>\n    .ta{\n        margin: 100px;\n    }\n    th{\n        text-align: center;\n    }\n</style>\n<body>\n    <div class=\"ta table-responsive\">\n        <table class=\"table table-striped table-bordered table-hover text-center\">\n            <thead>\n                <tr>\n                    <th>degree</th>\n                    <th>update_time</th>\n                    <th>weather</th>\n                    <th>weather_code</th>\n                    <th>weather_short</th>\n                    <th>wind_direction</th>\n                    <th>wind_power</th>\n                </tr>\n            </thead>\n            <tbody id='html'></tbody>\n        </table>\n    </div>\n    <script src=\"/js/jsonp.js\"></script>\n    <script type=\"text/html\" id=\"tpl\">\n        {{each info}}\n        <tr>\n            <td>{{$value.degree + '°'}}</td>\n            <td class=\"\">{{dateFormat($value.update_time)}}</td>\n            <td>{{$value.weather}}</td>\n            <td>{{$value.weather_code}}</td>\n            <td>{{$value.weather_short}}</td>\n            <td>{{$value.wind_direction}}</td>\n            <td>{{$value.wind_power+'级'}}</td>\n        </tr>\n        {{/each}}\n    </script>\n    <script>\n        let datas = document.getElementById('html')\n        // 构造一个date函数\n        function dateFormat(dates){\n            let year = dates.substr(0,4)\n            let mounth = dates.substr(4,2)\n            let day = dates.substr(6,2)\n            let hour = dates.substr(8,2)\n            let min = dates.substr(10,2)\n            return `${year}-${mounth}-${day} ${hour}:${min}`\n        }\n        // 将自定义函数开放到模板中\n        template.defaults.imports.dateFormat = dateFormat\n        jsonP({\n            url: 'https://wis.qq.com/weather/common',\n            data: {\n                source: 'pc',\n                weather_type: 'forecast_1h|forecast_24h',\n                province: '山西省',\n                city: '晋中市'\n            },\n            success: (e) => {\n                // console.log(e);\n                let html = template('tpl', { info: e.data.forecast_1h })\n                // console.log(html);\n                datas.innerHTML = html\n            }\n        })\n    </script>\n</body>\n\n</html>\n```\n{% endfolding %}\n\n\n## cors 跨域资源共享\n\n1. 使用express方法 设置请求的报文\n2. 使用express模块中的中间件拦截请求  app.use\n3. 设置服务器的响应报文  `res.header('Access-Control-Allow-Origin','*')`\n4. 设置请求方法 `res.header('Access-Control-Allow-Method':'get,post')`\n5. 注意在使用中间件拦截时  一定要注意放行，否则无法执行后面的内容 `next()`\n\n{% folding red, 查看解析 %}}\n```js\napp.use((req,res,next)=>{\n    res.header('Access-Control-Allow-Origin','*')\n    res.header('Access-Control-Allow-Methods','get,post')\n    next()\n})\n```\n{% endfolding %}\n\n## cookie复习\n\n1. `withCredentials`：指定在涉及到跨域请求时，是否携带cookie信息，默认值为false\n2. `Access-Control-Allow-Credentials`:true 允许客户端发送请求时携带cookie\n\n{% folding red, 查看解析 %}\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>设置cook信息</title>\n</head>\n\n<body>\n    <form id=\"loginForm\">\n        <input type=\"text\" placeholder=\"用户名\" name=\"username\" />\n        <input type=\"password\" placeholder=\"密码\" name=\"pwd\" />\n    </form>\n    <button id=\"logined\">登录</button>\n    <button id=\"checklogin\">检测登录</button>\n    <script>\n        let loginform = document.getElementById('loginForm')\n        let logined = document.getElementById('logined')\n        let checklogin = document.getElementById('checklogin')\n        // 监听请求\n        logined.onclick = function () {\n            let formData = new FormData(loginform)\n            let xhr = new XMLHttpRequest()\n            xhr.open('post', 'http://localhost:3000/logins')\n            xhr.withCredentials = true\n            xhr.send(formData)\n            xhr.onload = function () {\n                console.log(xhr.responseText);\n            }\n        }\n        checklogin.onclick = function(){\n            let xhr = new XMLHttpRequest()\n            xhr.open('get', 'http://localhost:3000/checklogin')\n            // xhr.withCredentials = true\n            xhr.send()\n            xhr.onload = function () {\n                console.log(xhr.responseText);\n            }\n        }\n    </script>\n</body>\n</html>\n```\n{% endfolding %}\n\n{% folding red, 查看解析 %}\n\n```js\napp.post('/logins', (req, res) => {\n    // console.log(res);\n    const form = new formidable.IncomingForm();\n    form.parse(req, (err, fields, files) => {\n        console.log(fields);\n        if (fields.username == '123' && fields.pwd == '123') {\n            req.session.isLogin = true\n            res.send({ message: '登录成功', code: 1 })\n        } else {\n            res.send({ message: '登录失败', code: -1 })\n        }\n        // res.send(fields)\n    })\n    // 解析formdata\n})\napp.get('/checklogin', (req, res) => {\n    if (req.session.isLogin) {\n        res.send({ message: '当前已登录' })\n    }else{\n        res.send({message:'当前未登录'})\n    }\n})\n```\n{% endfolding %}\n\n\n## jquery中的$.ajax()\n\n1. 请求参数时，默认为application/x-www-form-encoded\n2. 如果使用json对象，需要将json对象转换成json字符串，并且将类型设置为application/json\n3. `beforeSend` 表示在发送ajax请求前执行的 可在其中测试传递的参数，不满足条件可以使用`return false`\n\n### seralize方法\n\n1. 将表单中的数据自动拼接成字符串类型，如：`name=zs&age=12`\n2. 使用`sealizeArray()`方法将用户输入的内容转换成数组形式\n3. 封装一个函数使数组形式转换为json对象\n\n{% folding red, 查看解析 %}\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>使用jquery中的serialize方法</title>\n</head>\n\n<body>\n    <form id=\"form\">\n        <input type=\"text\" name=\"username\" placeholder=\"用户名\" />\n        <input type=\"password\" name=\"pwd\" placeholder=\"用户名\" />\n        <input type=\"submit\" value=\"提交\" />\n    </form>\n    <script src=\"https://cdn.jsdelivr.net/gh/Rr210/hexofixed@v0.47/js/jquery-3.5.1.min.js\"></script>\n    <script>\n        $('#form').on('submit', function () {\n            //    let params =  $(\"#form\").serialize()\n            //    console.log(params);\n            //    return false;\n            serializeObject($(this))\n            return false\n        })\n        function serializeObject(obj) {\n            let result = {}\n            let params = obj.serializeArray()\n            // console.log(params)\n            $.each(params,(index,item)=>{\n                result[item.name] = item.value\n            })\n            console.log(result);\n            return result\n        }\n    </script>\n</body>\n\n</html>\n```\n{% endfolding %}\n\n\n## $.ajax() 发送jsonp请求\n\n1. `dataType:'jsonp'`   \n2. `jsonCallback:'fnName'`  指定函数名称\n3. `jsonp:'cb'`  修改callback名称\n\n{% folding red, 查看解析 %}\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>使用jquery中的jsonp方法</title>\n    <script src=\"https://cdn.jsdelivr.net/gh/Rr210/hexofixed@v0.47/js/jquery-3.5.1.min.js\"></script>\n</head>\n<body>\n    <button id=\"btn\">\n        发送请求\n    </button>\n    <script>\n        // $('#btn').on('click',function(){\n        //     $.ajax({\n        //         type:'get',\n        //         url:'jsonp',\n        //         success:(res)=>{\n        //             console.log(res);\n        //         }\n        //     })\n        // })\n        $('#btn').on('click',function(){\n            $.ajax({\n                url:\"/jsonp\",\n                type:'get',\n                dataType:'jsonp',\n                success:(res)=>{\n                    console.log(res);\n                }\n            })\n        })\n    </script>\n</body>\n</html>\n```\n{% endfolding %}\n\n\n## todoList 案例\n\n1. GitHub地址：【[github](https://github.com/Rr210/node-js)】\n2. 使用技术`node.js+express+mongoose`\n\n## ajax请求\n1. ajaxStart方法为当页面中有ajax请求时触发\n2. ajaxComplete 方法为当页面中ajax请求完成时触发\n\n\n## RESful风格\n\n1. 规范API设计\n2. `get/put/delete/`\n3.`req.params` 获取get请求参数  地址为：`user/:id`\n\n## XML是可扩展标记语言\n\n1. 作用是传输和存储数据\n2. XML DOM 即XML文档对象模型\n\n{% folding red, 查看解析 %}\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>XML的获取</title>\n</head>\n<body>\n    <button id=\"btn\">发送请求</button>\n    <div class=\"container\"></div>\n    <script type=\"text/javascript\">\n    let btn = document.getElementById('btn')\n    let container = document.getElementsByClassName('container')\n    btn.onclick = function(){\n        let xhr = new XMLHttpRequest()\n        xhr.open('get','https://u.mr90.top/other/atom.xml')\n        xhr.send()\n        xhr.onload = function(){\n            let xmlDocument = xhr.responseXML\n            let title = xmlDocument.querySelectorAll('entry title')\n            // 使用map函数将原来数组中的元素提取出来 组成新的数组\n            let arr = [...title]\n            let title_all = arr.map(v=>v.innerHTML)\n            let html = template('tit',{title_all})\n            // 将获取的html数组通过模板方法渲染到页面上\n            container.innerHTML = html\n        }\n    }\n    </script>\n</body>\n</html>\n```\n{% endfolding %}\n\n\n## 数组转换\n\n1. 使用`Array.prototype.slice.call(nodes,0)` nodes为伪数组\n2. 使用es6中的方法  `[...arr]` 或者使用`Array.from(obj)`的方法进行转换\n","categories":["web","ajax"]},{"title":"Express 框架 知识总结","url":"/posts/254/","content":"\n\n## express框架\n\n1. 使用send()方法代替end\n2. 自动设置http状态码，\n3. 自动检测响应内容的类型，\n4. 设置相应内容类型及其编码\n\n## 中间件\n\n1. 一堆方法，中间件方法，请求处理函数\n2. 使用`app.use`方法,匹配所有的方式\n3. 应用\n- 路由保护\n- 网站维护\n- 自定义404状态码\n{% folding green, 查看代码 %}\n```js\nconst express = require('express');\n// 创建网站服务器\nconst app = express();\n\n// app.get('/',(req,res)=>{\n//     // 使用send()方法代替end，自动设置http状态码，自动检测响应内容的类型，对那个设置相应内容类型及其编码\n//     res.send('启动成功')\n// })\n// app.get('/list',(req,res)=>{\n//     res.send({name:'张是',age:1})\n// })\n\n// 中间件，使用next继续执行\n// 使用app.use方法，匹配所有的请求方式,可以自定义404界面\napp.use('/',(req,res,next)=>{\n    console.log(2);\n    next()\n})\napp.get('/',(req,res,next)=>{\n    req.name = 'zs'\n    next()\n})\napp.get('/',(req,res)=>{\n    res.send(req.name)\n})\n// 可以自定义404界面\napp.use((req,res,next)=>{\n    res.status(404).send('当前访问的页面不存在')\n})\napp.listen(3000)\nconsole.log('网站服务器启动成功');\n```\n{% endfolding %}\n\n## 错误处理中间件\n\n1. 统一处理错误  `app.use((err,req,res,next)=>{})`\n2. 异步代码执行出错无法读取，手动使用next方法\n{% folding green, 同步代码 %}\n```js\n// 错误处理中间件\napp.get('/index',(req,res)=>{\n    throw new Error('程序发生了未知错误')\n})\napp.use((err,req,res,next)=>{\n    res.status(500).send(err.message)\n})\n```\n{% endfolding %}\n{% folding green, 异步代码 %}\n```js\n// 错误处理中间件\napp.get('/index',(req,res,next)=>{\n    // throw new Error('程序发生了未知错误')\n    fs.readFile('./dawdaw','utf8',(err,result)=>{\n        if(err!=null){\n            next(err)\n        }else{\n            res.send(result)\n        }\n    })\n})\napp.use((err,req,res,next)=>{\n    res.status(500).send(err.message)\n})\n```\n{% endfolding %}\n\n## 捕获错误\n\n1. `try catch` 语句\n2. 捕获异步函数错误\n{% folding green, 查看答案 %}\n```js\nconst promisify = require('util').promisify\napp.get('/index',async (req,res,next)=>{\n    try{\n        await readFile('./add.js')\n    }catch(ex){\n        next(ex)\n    }\n})\napp.use((err,req,res,next)=>{\n    res.status(500).send(err.message)\n})\n```\n{% endfolding %}\n\n## 构造模块化路由\n\n1. `express.Router()` 创建路由对象\n2. 将路由请求路径进行匹配\n\n{% folding green, 查看答案 %}\n```js\n// 路由访问二级\nconst express = require('express')\n// 创建网站服务器\nconst app = express();\nconst admin = require('./router/admin')\nconst home = require('./router/home')\napp.use('/home',home)\napp.use('/admin',admin)\napp.listen(3000)\n// module.exports = home\n```\n{% endfolding %}\n\n## get/post参数的获取\n\n1. `req.query` 获取get 的请求参数\n2. post的请求参数  使用第三方模块 `body-parser`  `req.body`获取post的请求参数\n\n##  express路由参数\n\n1. `:`后面写要传递的对象参数 `params`\n{% folding green, 查看答案 %}\n```js\napp.get('/index/:id/:name/:age',(req,res)=>{\n    res.send(req.params);\n})\n```\n{% endfolding %}\n\n## 静态资源访问\n\n1. `express.static('public')`对静态资源进行处理,pubic 表示静态资源所在的路径\n2. 格式` app.use(express,static(path.join(__dirname,'public'))`\n\n## 模板引擎\n\n1. `all-template express-art-template`\n2. 渲染某个后缀文件时 使用`express-art-tenplate`\n\n{% folding green, 查看答案 %}\n```js\nconst express = require('express')\n\nconst path = require('path')\n\nconst app = express();\n// 设置模板的渲染后缀\napp.engine('art',require('express-art-template'))\n// 设置模板的默认路径\napp.set('views',path.join(__dirname,'views'))\n// 渲染模板时不写后缀，默认的后缀进行拼接\napp.set('view engine','art')\n// 响应可滑动\napp.get('/index',(req,res)=>{\n    // 渲染模板\n    res.render('index',{\n        msg:'message'\n    })\n})\napp.listen(3000)\n\n```\n{% endfolding %}\n\n## app.locals对象\n\n1. 使用app.locals方法可以在所有的模板下可以获取到\n{% folding green, 查看答案 %}\n```js\napp.locals.users = [{\n    name:'hello',\n    age:13,\n    sex:'1'\n},{\n    name:'张三',\n    age:20,\n    sex:0\n}]\n```\n{% endfolding %}\n\n## 注意\n\n1. 静态资源是由浏览器进行解析，\n2. 子模版的相对路径就是当前文件，因为它是由模板引擎解析的\n\n## 密码加密 bcypt\n\n1. 哈希密码  单程解密\n2. `bcrypt`方法  生成随机字符串，hash方法进行加密\n3. 或者使用`crypto`实现md5简单加密，可以进行二次加密或者添加字符串进行加密处理\n\n{% folding green, 查看答案 %}\n```js\nconst md5Crypto=(str)=>{\n    const hash=crypto.createHash('md5');\n    hash.update(str);\n    //加密后是二进制的，不好看，转换成16进制，并且字母大写\n    return hash.digest(\"hex\").toUpperCase();\n}\n// 设定一个字符加入md5加密中\nmdsecret = 'MaX_daw'\n\n// 建用户集合作为模块成员进行导出，开放对象\nmodule.exports = {\n    User,md5Crypto,mdsecret\n}\n```\n{% endfolding %}\n\n4. 在进行密码比对时可以使用(bcypt.compare(暗文密码，明文密码)\n\n## cookie和session\n\n1. cookie中的数据是以域名的形式进行区分的\n2. cookie中的数据是有过期事件的，会随请求被发送到服务器端\n3. session  对象  \n4. 使用`redirect`方法重定向到用户列表页面\n5. 登录拦截 使用中间件重定向 判断session中是否存在某个属性\n6. 使用clearCookie删除页面已经保存的cookie  然后对页面进行重定向\n\n## Joi第三方模块\n\n1. JavaScript对象的规则描述语言和验证器\n2. 注意joi的版本问题 【[no function解决方法](https://blog.csdn.net/QFREX/article/details/108818047)】\n3. validate方法 为异步函数 ，对用户提交的信息进行判断并返回错误\n\n{% folding green, 查看答案 %}\n```js\nconst Joi = require('joi')\n\nconst Schema = {\n    username: Joi.string().min(2).max(10).error(new Error('username属性没有通过验证'))\n}\n\nasync function valwidate(){\n    try{\n        await Joi.validate({username:'a'},Schema)\n    }catch(e){\n        console.log(e.message);\n        return;\n    }\n    console.log('验证通过');\n} \nvalwidate()\n```\n{% endfolding %}\n\n## 对页面进行分页\n\n1. 使用`countDocuments({})` 来获取数据库集合的总数\n2. 并且定义一个总的页码\n3. 使用limit限制，使用skip跳过n个数据\n4. `-`有隐式运算\n{% folding green, 查看答案 %}\n```html\n<!--\n<% for(var i=1;i<=pages;i++){%>\n<li><a href=\"/admin/user?page=<%=i%>\"><%=i%></a></li>\n<%}%>\n-->\n下一页 \n<li style=\"display:<%= page-0+1 > pages ? 'none' : 'inline' %>\">\n<a href=\"/admin/user?page=<%= page-0+1 %>\">\n<span>&raquo;</span>\n</a>\n</li>\n```\n{% endfolding %}\n\n## 标识编码\n\n1. 使用`res.app.locals.currentLink` 来标识当前选中的页面\n2. 可以使用js来改变当前的选中情况\n3. 表单enctype属性表示编码\n4. 指定表单数据的编码类型 原型 `application/x-www-form-urlencoded`\n5. 加个表单对的数据编码成二进制的类型 `multipart/form-data`\n\n## formidable解析表单\n\n1. 解析表单，支持`get`请求参数，`post`请求参数，文件上传\n2. 使用`form.keepExtensions` 保留表单上传文件的扩展名\n3. `form.uploadDir` 表示设置文件的上传路径\n4. 可以对表单提交的二进制信息类型进行解析\n5. fields 保存普通的表单信息 files 表示文件的信息\n{% folding green, 查看答案 %}\n```js\nconst  formidable  = require(\"formidable\")\n\n// 导入第三方模块 formidable\nconst path = require('path')\n\nmodule.exports = (req,res) =>{\n    // 创建表单解析对象\n    const form = new formidable.IncomingForm()\n    // 配置上传文件的后缀\n    form.uploadDir = path.join(__dirname,'../','../','public','uploads')\n    // 保留上传文件的后缀\n    form.keepExtensions = true\n    // 解析表单\n    form.parse(req,(err,fields,files) =>{\n        // 1. err表示错误对象，如果表单解析失败 err里面存储错误信息 如果表单解析成功\n        // fields表示普通的表单数据\n        // files表示保存了和上传文件相关的数据\n        res.send(files)\n    })\n    // res.send('ok')\n}\n```\n{% endfolding %}\n\n## 文件读取\n\n1. `FileReader()`  `readAsDataURL('文件')`\n2. 并且`readAsDataURL` 为异步函数无法直接获取信息，需要调用 onload来返回读取的结果\n{% folding green, 查看答案 %}\n```js\n    let file = document.querySelector('#file');\n    let preview = document.querySelector('#preview')\n    file.onchange = function(){\n        let reader = new FileReader();\n        // 用户选择的文件列表\n        reader.readAsDataURL(this.files[0]);\n        // 监听onload事件 \n        reader.onload = function(){\n           // 将获取到的文件结果显示在页面中\n           preview.src = reader.result\n        }\n    }\n```\n{% endfolding %}\n\n## 数据分页\n\n1. 使用第三方模块 `mongoose-sex-page`\n2. page 表示当前页 size 表示每页显示数据的条数，display表示客户端显示的页码 total数据总数 pages 总页数\n3. `$index` 表示当前某个标签的索引号\n4. 在进行内容渲染时 使用正则将内容中html标签去除  replace方法`/<\\/?.+?>/g`,并且使用字符串的截取将文本溢出省略 `substr(0,150)`如果文中出现乱码可以将返回的数据以原文输出方式显示\n\n{% folding green, 查看答案 %}\n```js\nconst {Article} = require('../../model/article')\nconst pagination = require('mongoose-sex-page')\n// const dateFormat = require('dateformat')\nmodule.exports = async (req,res)=>{\n    res.app.locals.currentLink = 'acticle'\n    // 获取地址栏中的page页\n    const { page }= req.query\n    // 查询数据库中的所有数据,链式查找根据关联的id值查询 使用populate方法查询 括号内添加关联的属性\n    // 利用 lean（） 方法将多级联合的结果转化为普通对象 ，缓解两者的冲突。\n    // let article = await Article.find().populate('author').lean()\n    // console.log(article);\n    // 获取数据集合中的所有数据\n    let total = await Article.countDocuments({})\n    // res.send(article)\n    // 定义每页显示的数据\n    let pagesize = 5\n    let pagecount = Math.ceil(total/pagesize)\n    // page表示获取的是第几页数据\n    // size表示每一页数据的数量\n    // display表示页码\n    // exec()方法避免多级查询与渲染之间发生冲突\n    let articles = await pagination(Article).find().page(page).size(pagesize).display(pagecount).populate('author').exec()\n    // 像转换为字符串类型，在转换为对象的类型\n    let str = JSON.stringify(articles);\n    let articlejson = JSON.parse(str);\n    // res.send(articlejson)\n    res.render('admin/article',{\n        articles: articlejson,\n        total:total,\n        page:page\n    })\n}\n```\n{% endfolding %}\n\n3. 可以使用自定义的参数来进行上下页面的切换，\n- 比如通过对地址栏数据的获取，判断当前页面所对应的页码，然后将此页码进行判断比如进行上一页的切换，如果页面-1小于1则使得当前的地址栏中的页码数等于一，反之使得在当前页码的基础上加一，下一页雷同 注意隐式算法\n- 第二种方法使用css将其隐藏，达到某个页码时将此模块显示\n- 使用第三方模块 pagination-sex-page下的参数执行第一步操作  ，在进行上下页切换时可以使用模块化语言 使用if判断 如果满足条件才让它显示出来\n\n## mongoDB数据库添加账号\n\n1. 查看数据库  连接数据库` mongo`  查询数据库 `show dbs`\n2. 切换到admin数据库 `use admin ` \n3. 创建超级管理员账号` db.createUser({user:'root',pwd:'root',roles:['root']})`\n4. 切换到blog数据`user blog`\n5. 创建普通账号 `db.createUser({user:'xxxx',pwd:'xxxx',roles:['readWrite']})`\n6. 移除数据库 先停止` net stop mongodb`在使用`mongod --remove`\n7. 创建数据库环境 `mongod --logpath=\"D:\\mongoDB\\install\\server\\log\\newmongod.log\" --dbpath=\"D:\\mongoDB\\install\\server\\data\" --install --auth`\n8. 连接数据库 使用 `mongodb://普通用户名:用户名密码@localhost:端口号/要连接数据库名称`\n9. 启动数据库 `net start mongodb`\n\n## 开发环境和生产环境\n\n1. 使用process.env.某个指定的对象来判断当前的环境情况\n2. morgan('dev')  在开发环境中将客户端发送到服务器端的请求信息打印到控制台中，只能在开发环境中使用\n3. production 生产环境\n\n## config模块\n\n1. 将不同运行环境下的应用配置信息抽离到单独的文件中，模块内部字段判断当前的运行环境，并读取对应的配置信息\n2. 创建config文件夹  default  development production 三个json文件，通过require的方法导入\t\n3. get方法，\n4. 这个方法可以自动判断当前的运行环境，并根据相对应的配置信息返回，如果该环境配置下没有匹配到某个指定信息，则在其他的配置信息中自动查询\n5. 将敏感配置信息存储在环境变量中`custom-environment-variables.json`  自定义环境变量\n\n## 评论的创建\n\n1. 创建评论的集合规则 将评论属性的id值与文章的内容id进行关联， 设置其属性为 mongoose.Schema.Types.Objected, ref 为所关联集合名称\n2. 建立评论的路由 只有当用户登录之后才可以使用评论的模块 创建评论的模块\n3. 获取用户在文本框内输入的内容，将此内容通过所在的文章的id值新建一个数据库或者上传到文章的数据库页面\n4. 用户需要登录后才能使用评论 在用户登录后判断如果登录的用户是超级管理员则将页面重定向到博客惯例页面如果是普通用户则将页面重定向到文章的首页\n5. 将登录用户的role存储到session中，在对session进行拦截判断 并且将登录后的首页信息改为用户的信息对评论的状态进行配置，当用户登录后 在本地已经存储到一个userInfo，判断userInfo是否存在，如果存在则将评论模块呈现出来，如果未登录则将评论状态和首页头部的用户状态关闭\n6. 渲染评论页面直接在文章页面渲染\n7. 将用户信息渲染到页面页 创建评论路由 根据评论集合创建规则，上传集合对象  post请求后将页面重定向未当前页面","categories":["web","node.js"]},{"title":"Python中的正则表达式","url":"/posts/59398/","content":"\n\n## 正则表达式\n\n>规则表达式，匹配符合字符特征的模式\n\n### 修饰符-可选标志\n\n1. `re.l`,匹配的字符对大小写不敏感\n2. `re.L`,取决于本地化的设置\n3. `re.M`,多行匹配，影响^和$\n4. `re.S`，匹配包括换行在内的所有字符\n5. `re.U`,\t根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B.\n6. `re.X`,该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解\n\n### 正则表达式模式\n\n1. `^` 开头\n2. `$` 结尾\n3. `.` 匹配任意字符，不包括换行符（如果re.DOTALL标记被指定时，则可以匹配换行符的任意字符）\n4. `[...]` 用来表示一组字符，选中其中的一个\n5. `[^abc]` 匹配除了a,b,c之外的字符\n6. `re*` 匹配0个或者多个表达式\n7. `re+` 匹配1个或者多个的表达式","categories":["Python"]},{"title":"node.js 和 mongoDB的知识总结","url":"/posts/59408/","content":"\n<div class=\"note info icon flat\"><p>Node.js，es6中的异步和同步promise，还有数据库mongoDB的基础使用</p></div>\n\n## node.js\n\n1. 编程运行环境\n2. 模块化开发\n3. exports对象导出,使用require方法引入\n4. 并且导入的文件名的后缀可以省略\n5. 使用module.exports.obj  导出模块成员 \n6. exports 和module.exports指向不同的对象时 最终以后者为准\n\n## 系统模块\n\n1. f:file s:syetem\n2. fs.reaFile('文件路径'[,'文件编码'],callback)  读取方法\n\n{% folding green, 查看答案 %}\n```js\n// 通过模块的名字\nconst fs = require('fs')\nfs.readFile('./c.js', 'utf8', (err, doc) => {\n    // console.log(err);\n    // console.log(doc);\n    if(err ==null){\n        console.log(doc);\n    }\n})\n```\n{% endfolding %}\n3. 文件写入内容  fs.writeFile('文件路径','数据',callback)\n\n{% folding green, 查看答案 %}\n```js\n// 通过模块的名字\nconst fs = require('fs');\nfs.readFile('./c.js', 'utf8', (err, doc) => {\n    // console.log(err);\n    // console.log(doc);\n    if (err == null) {\n        // console.log(doc);\n        // 将另一个文件中获取的数据导入到指定的文件夹中\n        fs.writeFile('./write.js', doc, err => {\n            if(err == null){\n                console.log('写入文件成功');\n            }else{\n                console.log(`写入文件失败${err}`);\n            }\n            \n        } )\n    }\n})\n```\n{% endfolding %}\n\n4. path路径操作  path.join('路径','路径', ...)\n{% folding green, 查看答案 %}\n```js\nconst path = require('path')\n\nlet a = path.join('public','uploads','avatar')\nconsole.log(a);\n```\n{% endfolding %}\n5. 相对路径绝对路径,使用`__dirname`获取当前的绝对路径用于数据合并\n\n## 第三方模块\n\n1. npm install/ uninstall  模块名称 \n2. 安装淘宝源[淘宝源](https://blog.csdn.net/fhjdzkp/article/details/90038959?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&dist_request_id=1328642.24072.16156202445102349&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control)\n\n## gulp模块\n\n1. gulp.src() 获取任务要处理的文件\n2. gulp.dest()  输出文件\n3. gulp.task()  建立gulp任务\n4. gulp.watch()  监控文件的变化\n\n{% folding green, gulp实例 %}\n```js\n// 引用gulp\nconst gulp = require('gulp')\nconst path = require('path')  // 获取环境\nconst htmlmin = require('gulp-htmlmin')  // 压缩html\nconst fileinclude = require('gulp-file-include'); // 抽取公共的部分\nconst less = require('gulp-less');  //将less文件转化\nconst cssMin = require('gulp-css');  //压缩css\nconst jsmin = require('gulp-jsmin');  // 压缩js\nconst rename = require('gulp-rename');  //可以省略这是一个重新命名的操作\nconst babel = require('gulp-babel');\nconst uglify = require('gulp-uglify');  // 第二种压缩方法\n// 执行命令\ngulp.task('first', dnoe => {\n    console.log('人生中第一个gulp命令');\n    // 获取文件\n    gulp.src('./src/css/style.css')\n        // 压缩文件\n        .pipe(gulp.dest('dist/css'))\n        dnoe()\n})\n\n// html 任务 压缩文件，将公共代码抽取\n\ngulp.task('htmlmin', done => {\n    gulp.src('./src/*.html')\n        .pipe(fileinclude({\n            prefix: '@@',\n            basepath: '@file'\n        }))  // 抽取公共部分\n        // 压缩html文件的代码\n        .pipe(htmlmin({ collapseWhitespace: true }))\n        .pipe(gulp.dest('dist'));\n        done()\n})\n\n// css压缩  less格式转化\n// 第一种\n// gulp.task('lesscss',() =>{\n//     gulp.src('./src/css/*.less')\n//     .pipe(less({\n//       paths: [ path.join(__dirname, 'less', 'includes') ]\n// }))\n//     .pipe(gulp.dest('./src/css'));\n//     gulp.src('./src/css/*.css')\n//     .pipe(cssMin())\n//     .pipe(gulp.dest('./dist/css'))\n// })\n\n// 第二种方法\n\ngulp.task('cssless', done => {\n    gulp.src(['./src/css/*.less', './src/css/*.css'])  // 先将less文件转化为css，在进行压缩\n        .pipe(less({\n            paths: [path.join(__dirname, 'less', 'includes')]\n        }))\n        .pipe(cssMin())\n        .pipe(gulp.dest('./dist/css'))\n        done()\n})\n// 将js代码压缩  第一种  将js代码从es6转化为es5  \ngulp.task('jsmin', done => {\n    gulp.src('./src/js/*.js')\n        .pipe(jsmin())\n        .pipe(rename({ suffix: '.min' }))\n        .pipe(gulp.dest('./dist/js/'))\n        done()\n})\n// 第二种转化后压缩\ngulp.task('jsmm', done => {\n    gulp.src('./src/js/*.js')\n        .pipe(babel({\n            presets: ['@babel/env']\n        }))\n        .pipe(uglify())\n        .pipe(gulp.dest('./dist/js/'))\n        done()\n})\n// 构建任务\n// gulp.task('default',['first','htmlmin','cssless','jsmin','jsmm'])\ngulp.task('build', gulp.parallel('first', 'htmlmin', 'cssless', 'jsmin', 'jsmm'));\n```\n{% endfolding %}\n\n## node_modules文件夹问题\n\n1. 项目依赖  dependencies   使用命令 `npm install --production`\n2. 开发依赖   加`--save-dev`命令  将包添加到package\n3. package-lock.json  锁定包的版本，加快包的下载速度\n4. 别名的用法 在script中加入一个build,nodemon xx.js \n5. npm init -y 生成包\n\n### require查找规则\n\n>先找文件=>文件夹=>找package.json 中的main选项\n>如果直接写require('xx')  默认先查找系统模块  node_modules\n\n\n## 服务器端\n\n1. http  超文本协议，提供了一种发布和接受HTML页面的方法\n2. 传输协议：//服务器ip或者域名：端口/资源所在的位置\n\n### 创建web服务器\n\n1. 用于协议，创建对象req,res ，监听端口\n{% folding green, 查看答案 %}\n```js\n// 创建网址服务器模块\nconst http = require('http')\n// 网站服务器的对象\nconst app = http.createServer()\n// 当客户端有请求来的时候\napp.on('request',(req,res)=>{\n    res.end('<h2>hello user</h2>')\n})\napp.listen(3000)\nconsole.log('网站服务器启动成功');\n```\n{% endfolding %}\n\n1. http 协议  \n2. 报文  请求或者响应过程中传递的数据块\n3. 请求报文 get 请求数据  post发送请求 \n4. req.url 获取请求地址\n5. req.header  获取请求报文\n6. res.writeHead  设置响应状态码\n\n### 响应报文\n\n1. 200 请求成功\n2. 404 请求的资源没有被找到\n3. 500 服务器端错误\n4. 400 客服端请求有语法错误\n\n\n### post参数\n\n1. 获取psot参数需要使用data和end事件\n2. 使用querystring系统模块将参数转化为对象的形式\n\n{% folding green, 查看答案 %}\n```js\n// 创建网址服务器模块\nconst http = require('http')\n// 用于处理url地址\nconst url = require('url')\n// 网站服务器的对象\nconst app = http.createServer()\n// 当客户端有请求来的时候\napp.on('request',(req,res)=>{\n    // 自定义响应状态码\n    res.writeHead(200,{\n        // 设置响应信息\n        'content-type':'text/html;charset=utf8'\n    })\n    // 第一参数要解析的url地址，第二个参数是将查询参数解析成对象的形式\n    let {query,pathname} = url.parse(req.url, true)\n    console.log(query.name);\n    console.log(query.age);\n    // 解析的url地址\n    console.log(req.url);\n    // 获取请求地址\n    console.log(req.headers['accept']);  // 获取请求报文\n    if(pathname == '/index' || pathname == '/'){\n        res.end('<h2>welcome to index,欢迎来到我的主页</h2>')\n    }else{\n        res.end('not found')\n    }\n    // if(req.url == '/index' || req.url == '/'){\n    //     res.end('<h2>welcome to index,欢迎来到我的主页</h2>')\n    // }else{\n    //     res.end('not found')\n    // }\n    console.log(req.method)\n    // if(req.method=='POST'){\n    //     res.end('post')\n    // }else{\n    //     res.end('get')\n    // }\n})\napp.listen(3000)\nconsole.log('网站服务器启动成功');\n```\n{% endfolding %}\n\n{% folding green, 查看答案 %}\n```js\n// 创建网址服务器模块\nconst http = require('http')\n// 用于处理url地址\nconst url = require('url')\n// 网站服务器的对象\nconst app = http.createServer()\n// 将提交的信息转化为对象\nconst querystring = require('querystring')\n// 当客户端有请求来的时候\napp.on('request',(req,res)=>{\n    // post参数是通过事件的方式接受的\n    // data 当请求参数传递的时候发出data事件\n    // end 当参数传输完成时发出end事件\n    let postParams = ''\n    req.on('data', params =>{\n        postParams += params\n    })\n    req.on('end',()=>{\n        console.log(querystring.parse(postParams));\n        // console.log(postParams);\n    })\n    res.end('ok')\n\n})\napp.listen(3000)\nconsole.log('网站服务器启动成功');\n```\n{% endfolding %}\n\n## https请求与响应处理\n\n1. 静态资源\n\n{% folding green, 查看答案 %}\n```js\nconst http = require('http')\n\nconst app = http.createServer()\n\nconst path = require('path')\nconst fs =require('fs')\nconst url = require('url')\n// 使用第三方模块来自动判断请求路径分析出请求类型\nconst mime =require('mime')\napp.on('request', (req, res) => {\n    // 获取用户输入的路径\n\n    let pathname = url.parse(req.url).pathname\n    // 判断开始时的页面访问情况\n    pathname = pathname == '/' ? '/index.html' : pathname\n    // 获取文件的绝对路 获取系统的真实路径\n    let realname = path.join(__dirname,'public' + pathname)\n    // mime\n    let type = mime.getType(realname)\n    console.log(type);\n    // 读取文件\n    fs.readFile(realname,(error,result) =>{\n        // 读取失败响应给客服端\n        if(error != null){\n            res.writeHead(404,{\n                'content-type':'text/html;charset=utf8'\n            })\n            res.end('文件读取失败')\n            return\n        }\n        res.writeHead(200,{\n            'content-type': type\n        })\n        res.end(result)\n    })\n\n})\napp.listen(1000)\n\n```\n{% endfolding %}\n2. 动态资源\n\n\n## 同步API 异步API\n\n1. 异步API不会阻塞之后的程序，默认返回undefined\n2. 回调函数来获取异步的返回值，自己调用自己\n\n{% folding green, 查看答案 %}\n```js\n// function getData(callback){\n//     callback('213')\n// }\n// getData(function(n){\n//     console.log('callback函数被调用了');\n//     console.log(n);\n// // })\n// for(var i = 0;i<1000;i++){\n//     console.log(i);\n// }\n// // 同步会组测后面代码的执行\n// console.log('for循环后的代码');\n// 异步api不会等到api执行完成后在向下执行代码\n\n// console.log('代码开始执行');\n// // 定时器属于异步API\n// setTimeout(function(){\n//     console.log('2s');\n// },2000)\n// setTimeout(function(){\n//     console.log('0秒执行');\n// },0)\n// // 回调函数队列\n// console.log('代码结束执行');\n\n\n// 读取文件的操作就是异步api,回调\n// const fs =require('fs')\n// fs.readFile('./demo/2.js','utf8',(err,result) =>{\n//     console.log(result);\n//     fs.readFile('./demo/1.js','utf8',(err,result)=>{\n//         console.log(result);\n//     })\n// })\n// console.log('文件读取结果');\n\n\n// promise 方法 解决node.js异步编程中回调地狱的问题，参数resolve reject，分别表示传递函数，成功和失败，promise有then方法和catch方法\n// const fs =require('fs')\n// let promise =new Promise((resolve,reject)=>{\n//     fs.readFile('./demo/1.js','utf8',(err,result) => {\n//         if(err != null){\n//             reject(err)\n//         }else{\n//             resolve(result)\n//         }\n//     })\n// })\n\n// promise.then(result=>{\n//     console.log(result);\n// })\n// .catch(err=>{\n//     console.log(err);\n// })\n\nconst fs = require('fs')\nfunction p1(){\n    return new Promise((resolve,reject)=>{\n        fs.readFile('./demo/1.js','utf8',(err,result)=>{\n            resolve(result)\n        })\n    })\n}\nfunction p2(){\n    return new Promise((resolve,reject)=>{\n        fs.readFile('./demo/2.js','utf8',(err,result)=>{\n            resolve(result)\n        })\n    })\n}\nfunction p3(){\n    return new Promise((resolve,reject)=>{\n        fs.readFile('./demo/3.js','utf8',(err,result)=>{\n            resolve(result)\n        })\n    })\n}\n\np1().then(r1=>{\n    console.log(r1);\n    return p2();\n}).then(r2=>{\n    console.log(r2);\n    return p3()\n}).then(r3=>{\n    console.log(r3);\n})\n```\n{% endfolding %}\n\n## 异步函数\n\n1. 基于promise函数进行封装\n2. async() 异步函数\n3. await 只能在异步函数中使用\n4. 全局对象 global\n\n{% folding green, 查看答案 %}\n```js\nconst fs =require('fs')\nconst a = require('util').promisify\n// 返回文件结果不返回promise对象，无法加async\n// 对方法进行处理\nconst readfile= a(fs.readFile)\n// print(readfile)\n\nrun();\nasync function run(){\n   console.log(await readfile('./1.js','utf8')); \n   console.log(await readfile('./2.js','utf8')); \n   console.log(await readfile('./3.js','utf8'))\n}; \n```\n{% endfolding %}\n\n{% folding green, global %}\n```js\nglobal.console.log('我是')\n\nglobal.setTimeout(function(){\n    console.log(123);\n},2000)\n```\n{% endfolding %}\n\n## 服务器基础\n\n1.  端口 区分服务器中提供的不同服务\n2.  数据库  Mongo DB, MySQL\n\n\n## 数据库\n\n1. database 数据库，mongDB数据库软件中可以加你多个数据库\n2. collection 集合 数组\n3. document 文档  json对象\n4. field 字段 json对象属性\n\n## mongodb\n\n1. net stop mongodb  关闭服务\n2. net start mongodb 开启服务\n3. connect 方法链接数据库\n4. 无需创建数据库，mongoDB会根据代码自动判断，创建数据库\n5. 创建集合  对集合设定规则，创建集合  Schema 构造函数\n\n{% folding green, 增加文档 %}\n```js\nconst mongoose = require('mongoose')\n\nmongoose.connect('mongodb://localhost/playground',{ useUnifiedTopology: true })\n    .then(()=> console.log('数据库链接成功'))\n    .catch((err)=>console.log('数据库连接失败'+err))\n\n// 创建集合，Schema 构造函数  model 创建集合  couseSchema\n\n// 创建集合规则\nconst courseSchema = new mongoose.Schema({\n    name: String,\n    author: String,\n    isPublished: Boolean,\n})\n\n// 使用规则创建集合\nconst Course = mongoose.model('Course',courseSchema)\n\n// 创建文档 创建集合实例 调用实例对象下的save方法将数据保存到数据库中\n// 第一种方法 使用构造函数的方法\n// 实例化，与上面的集合规则一致\n// const course = new Course({\n//     name: 'node.js基础',\n//     author: '欧克',\n//     isPublished: true\n// })\n// // save方法保存数据\n// course.save()\n\n// 第二种方法,create 向集合中插入文档 \nCourse.create({\n    name: 'JavaScript',\n    author: 'world',\n    isPublished: false\n},(err,doc) =>{\n    console.log(err); // 返回错误信息，null表示插入成功\n    console.log(doc); \n})\n\n// 回调函数，说明也是异步API,通过promise对象的方法接受返回数据\nCourse.create({\n    name: 'JavaScript',\n    author: 'world',\n    isPublished: false\n}).then(result=>{console.log(result)}).catch(err=>console.log(err))\n```\n{% endfolding %}\n\n### 导入数据\n\n1. mongoimport -d 数据库的名称 -c集合名称 --file 要导入的数据文件·\n2. 如果json文件中包含数组 则使用命令 --jsonArray\n\n### 查询文档\n\n1. find（）可以查询用户集合下的所有文档\n2. findOne（） 默认返回集合中的第一个文档\n\n{% folding green, 查看答案 %}\n```js\n\n// 使用规则创建集合\nconst Course = mongoose.model('Course',courseSchema)\n\n// 查询方法  find 返回一组文档\nCourse.find({_id:'60531fab2044b239489d9bd6'}).then(result=>console.log(`我返回的是find方法${result}`))\n\n\n// findOne 方法返回的查询的一个文档,默认返回第一条文档\nCourse.findOne({_id:'60531fab2044b239489d9bd6'}).then(result=>console.log(`我返回的是findOne方法${result}`))\n\n```\n{% endfolding %}\n\n2. 使用判断条件查询数据  $gt 和$lt 分别表示><\n{% folding green, 查看答案 %}\\\n```js\nCourse.find({age: {$gt: 20, $lt: 40}}).then(result=>console.log(`我返回的是指定条件下的集合文档${result}`)).catch(err=>console.log(err))\n```\n{% endfolding %}\n3. 查询包含 `$in`\n{% folding green, 查看答案 %}\n```js\nCourse.find({age:{$in:[21]}}).then(result=>console.log(`我是$in包含条件所返回的集合数据${result}`))\n```\n{% endfolding %}\n4. 使用select方法查询数据，如果想要查询某个数据将属性写入select中不想查询某个数据将属性也写入到select中但是要加`-`\n\n{% folding green, 查看答案 %}\n```js\nCourse.find().select('name age -_id').then(result=>console.log(`我是select方法下返回的数据${result}`))\n```\n{% endfolding %}\n\n4. 可以根据某个字段对集合数据进行数据的升序和降序的操作，降序操作只需要在在某个属性的前面加个`-`\n\n{% folding green, 查看答案 %}\n```js\nCourse.find().sort('age').then(result=>console.log(`我是经过升序排列后的集合数据${result}`))\nCourse.find().sort('-age').then(result=>console.log(`我是经过降序排列后的集合数据${result}`))\n\n```\n{% endfolding %}\n\n5. skip 跳过n个数据，limit限制查询数量\n\n{% folding green, 查看答案 %}\n```js\nCourse.find().skip(2).limit(3).then(result=>console.log(`我是限制查询下返回的集合数据${result}`))\n```\n{% endfolding %}\n\n### 删除文档\n\n1. findOneAndDelete  表示删除单个文档\n2. 如果删除的条件匹配个多个文档，默认删除第一个文档\n3. 删除多个文档  deleteMany({}),默认删除全部的文档\n\n{% folding green, 查看答案 %}\n```js\nCourse.findOneAndDelete({_id:'60532205db7e8e5148e30b56'}).then(result=>console.log(`我是findOneAndDelete方法下返回的集合数据${result}`))\n```\n{% endfolding %}\n\n### 更新文档\n\n1. updateOne({查询条件},{更改的值}) 更新一个文档\n2. updateMany  更新多个文档\n\n### monfoose验证\n\n{% folding green, 查看答案 %}\n```js\nconst mongoose = require(\"mongoose\");\n\n// 导入数据  使用json文件，导入json文件使用第三方工具 mongoimport -d 数据库的名称 -c数据集合 --file 要导入的数据文件\nmongoose.connect('mongodb://localhost/playground', { useUnifiedTopology: true })\n    .then(() => console.log('数据库链接成功'))\n    .catch((err) => console.log('数据库连接失败' + err))\n\n\n// 对创建的规则进行验证处理\nconst postSchema = new mongoose.Schema({\n    // 可以将以下的属性值写为 数组的形式 required: [true,‘自定义内容]\n    title: {\n        type: String,\n        // 必传字段\n        required: true,\n        // 针对字符\n        minlength: 2,\n        maxlength: 5,\n        // 去除字符串两边的空格\n        trim: true\n    },\n    age: {\n        type: Number,\n        min: 18,\n        max: 100\n    },\n    publishDate: {\n        type: Date,\n        // default 表示的是默认的值\n        default: Date.now  //返回当前的时间 \n    },\n    category: {\n        type: String,\n        // 枚举 列举出当前字段可以拥有的值\n        enum: {\n            values:['html', 'css', 'javascript'],\n            message:'category的错误信息'\n        }\n    },\n    auchor: {\n        type:String,\n        validata:{\n            // 自定义验证器\n            validator: v =>{\n                // console.log();\n                return v && v.length > 4\n            },\n            // 自定义错误的信息\n            message: '传入的信息不符合规则'\n        }\n    }\n})\n\nconst Post = mongoose.model('Post', postSchema)\n\n// 删除某个数据  使用方法 findOneDelete\n// Post.findOneAndDelete({_id:'60544f7106b1d12d0c951070'}).then(result=>console.log('删除成功'))\n\nPost.create({ title: ' aa ', age: 18, category: 'htm' ,auchor: 'bd'})\n    .then(result => console.log(result))\n    .catch(error=>{\n    // 获取错误信息\n    const err = error.errors\n    // 循环错误信息\n    for (var attr in err){\n        console.log(err[attr]['message']);\n    }\n})\n```\n{% endfolding %}\n\n### 集合关联\n\n1. 集合关联用到的方法 为 populate('关联的对象属性')\n2. 设置关联的属性类型为  `mongoose.Schema.Types.ObjectId`, 并将ref的属性值设置为要关联的集合名称\n\n{% folding green, 查看答案 %}\n```js\n// 引入需求的库\nconst mongoose = require('mongoose')\n// 连接服务器\nmongoose.connect('mongodb://localhost/playground', { useUnifiedTopology: true })\n    .then(result => console.log(`数据库连接成功${result}`))\n    .catch(err => console.log(`数据库连接失败${err}`))\n// 创建模板并且设置集合规则\nconst User = mongoose.model('User', new mongoose.Schema({\n    name: {\n        type: String\n    }\n}))\n// 文章集合规则\nconst Post = mongoose.model('Post', new mongoose.Schema({\n    title: {\n        type: String\n    },\n    // 将文章的集合和作者的集合进行关联\n    auchor: {\n        type: mongoose.Schema.Types.ObjectId,\n        ref: 'User'\n    }\n}))\n\n// User.create({name:'itmax'}).then(result=>console.log(result))\n\n// Post.create({title:123,auchor:'60545d55a18f3852f853c4e2'}).then(result=>console.log(result))\n\n// 查询数据\n\nPost.find().populate('auchor').then(result=>console.log(result))\n\n```\n{% endfolding %}\n\n## 用户信息的增删改查案例\n\n1. 动态生成列表页\n2. 使用mongoDB\n3. 实现对页面数据的增删改查等等\n\n{% folding green, 查看答案 %}\n```js\n\nconst http = require('http')\n// 创建服务器\nconst app = http.createServer()\nconst url = require('url')\nconst mongoose = require('mongoose')\n// 将表单提交的数据转化,使用querystring.parse方法\nconst querystring = require('querystring')\n\n// 连接服务器 27017 是默认端口\nmongoose.connect('mongodb://localhost/playground', { useUnifiedTopology: true, useNewUrlParser: true })\n    .then(() => console.log('成功'))\n    .catch(() => console.log('失败'))\n// 创建用户的集合规则\nconst UserSchema = new mongoose.Schema({\n    name: {\n        type: String,\n        resquired: true,\n        minlength: 2,\n        maxlength: 20\n    },\n    age: {\n        type: Number,\n        min: 3,\n        max: 80\n    },\n    password: String,\n    email: String,\n    hobbies: [String]\n})\n// 创建集合\nconst user = mongoose.model('User', UserSchema)\n// 添加请求事件\napp.on('request', async (req, res) => {\n    // 请求方式\n    const method = req.method\n    // 获取请求的地址,使用query属性，将获取到的字符串转换为对象的形式，parse方法后面加true\n    const { pathname, query} = url.parse(req.url,true) \n    if (method == 'GET') {\n        // 呈现页面的方式,增删改\n        if (pathname == '/list' || pathname == '/') {\n            // 查询用户的信息\n            let Users = await user.find()\n            // console.log(Users);\n            let list = `<!DOCTYPE html>\n            <html lang=\"en\">\n            <head>\n                <meta charset=\"UTF-8\">\n                <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n                <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n                <title>列表页</title>\n                <script src=\"https://cdn.jsdelivr.net/gh/Rr210/hexofixed@v0.47/js/jquery-3.5.1.min.js\"></script>\n                <link rel=\"stylesheet\"\n                    href=\"https://cdn.jsdelivr.net/gh/Rr210/hexofixed@frame/frame/bootstrap/3/css/bootstrap.min.css\">\n                <script src=\"https://cdn.jsdelivr.net/gh/Rr210/hexofixed@frame/frame/bootstrap/3/js/bootstrap.min.js\"></script>\n                <style>\n                    *{\n                        padding: 0;\n                        margin: 0;\n                    }\n                    .addd{\n                        display:inline-block;\n                        margin: 20px auto;\n                    }\n                    a{\n                        margin:10px\n                    }\n                    .table {\n                        margin: 10px auto;\n                        width: 70%;\n                    }\n                    td span{\n                        margin: 0 5px;\n                    }\n                </style>\n            </head>\n            <body>\n                <a class=\"btn btn-success addd\" href=\"/add\">添加用户</a>\n                <table class=\"table table-striped table-bordered\">\n                  <thead>\n                      <tr>\n                          <th>用户名</th>\n                          <th>年龄</th>\n                          <th>爱好</th>\n                          <th>邮箱</th>\n                          <th>操作</th>\n                      </tr>\n                  </thead>\n                  <tbody>`\n            // 对数据进行循环操作\n            Users.forEach(item => {\n                list += `<tr>\n                <td>${item.name}</td>\n                <td>${item.age}</td><td>`\n                item.hobbies.forEach(item => {\n                    list += `<span>${item}</span>`\n                })\n                list += `</td><td>${item.email}</td><td><a class=\"btn btn-primary\" href=\"/modify?id=${item._id}\">修改</a><a class=\"btn btn-danger\" href=\"/remove?id=${item._id}\">删除</a></td>\n            </tr>`\n            })\n            list += ` </tbody>\n            </table>\n            <script>\n            // css的修改 获取元素\n                window.addEventListener('DOMContentLoaded',function(){\n                    // 构造函数\n                    let resize = function(){\n                        var adduser = document.querySelector('.addd')\n                        var tablebox = document.querySelector('table')\n                    // console.log(tablebox.offsetLeft);\n                    adduser.style.marginLeft = tablebox.offsetLeft + 'px'\n                    }\n                    // 当页面加载后执行一次，并且窗口改变时跟随变化\n                    resize();\n                    window.addEventListener('resize', () => {                     var adduser = document.querySelector('.addd')\n                    resize()\n                 }, false);         \n                })\n            </script>\n        </body>\n        </html>`\n            res.end(list)\n        }else if(pathname == '/add'){\n            let add = `<!DOCTYPE html>\n            <html lang=\"en\">\n            \n            <head>\n                <meta charset=\"UTF-8\">\n                <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n                <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n                <title>添加用户</title>\n                <script src=\"https://cdn.jsdelivr.net/gh/Rr210/hexofixed@v0.47/js/jquery-3.5.1.min.js\"></script>\n                <link rel=\"stylesheet\"\n                    href=\"https://cdn.jsdelivr.net/gh/Rr210/hexofixed@frame/frame/bootstrap/3/css/bootstrap.min.css\">\n                <script src=\"https://cdn.jsdelivr.net/gh/Rr210/hexofixed@frame/frame/bootstrap/3/js/bootstrap.min.js\"></script>\n            </head>\n            <style>\n                * {\n                    padding: 0;\n                    margin: 0;\n                }\n            \n                body {\n                    background-color: #ccc;\n                }\n            \n                .box {\n                    width: 770px;\n                    margin: 30px auto 0;\n                    border: 2px solid #888;\n                    border-radius: 10px;\n                }\n            \n                h5,button{\n                    margin: 20px auto;\n                    text-align: center;\n                    font-size: 20px;\n                    font-weight: 600;\n                }\n                .btn{\n                    display: block;\n                    margin-bottom: 10px;\n                }\n            \n                .form-control {\n                    width: 93%;\n                    margin: auto;\n                }\n            \n                label {\n                    margin-left: 30px;\n                    margin-right: 7px;\n                }\n                .hobb{\n                    display: block;\n                }\n            </style>\n            \n            <body>\n                <div class=\"box\">\n                    <h5>添加用户</h5>\n                    <form method=\"POST\" action=\"/add\">\n                        <div class=\"form-group\">\n                            <label for=\"username\">User Name</label>\n                            <input name=\"name\" type=\"text\" class=\"form-control\" id=\"username\" placeholder=\"请填写用户名\">\n                        </div>\n                        <div class=\"form-group\">\n                            <label for=\"mima\">Password</label>\n                            <input  name=\"password\" type=\"password\" class=\"form-control\" id=\"mima\" placeholder=\"Password\">\n                        </div>\n                        <div class=\"form-group\">\n                            <label for=\"exampleInputFile\">Age</label>\n                            <input name=\"age\" type=\"number\" id=\"exampleInputFile\" placeholder=\"请输入年龄\" class=\"form-control\">\n                        </div>\n                        <div class=\"form-group\">\n                            <label for=\"exampleInputemail\">Age</label>\n                            <input name=\"email\" type=\"email\" id=\"exampleInputemail\" placeholder=\"请输入邮箱\" class=\"form-control\">\n                        </div>\n            \n                        <div class=\"form-group\">\n                            <label for=\"\" class=\"hobb\">hobbies</label>\n                            <label for=\"football\"> 足球</label><input type=\"checkbox\" id=\"football\" name=\"hobbies\" value=\"足球\">\n                            <label for=\"baseball\"> 篮球</label><input type=\"checkbox\" id=\"baseball\" name=\"hobbies\"value=\"篮球\">\n                            <label for=\"code\"> 敲代码</label><input type=\"checkbox\" id=\"code\" name=\"hobbies\"value=\"敲代码\">\n                            <label for=\"book\"> 看书</label><input type=\"checkbox\" id=\"book\" name=\"hobbies\"value=\"看书\">\n                        </div>\n                        <button type=\"submit\" class=\"btn btn-primary\">Add User</button>\n                    </form>\n                </div>\n            \n            </body>\n            \n            </html>`\n            res.end(add)\n        }else if(pathname == '/modify'){\n            // 修改用户信息，获取数据库的中的数据将数据传入页面,使用find返回的是一组对象，使用findOne返回一组对象数据，异步返回\n            let userid = await user.findOne({_id:query.id})\n            let hobbiess = ['足球','篮球','羽毛球','学习','看书','敲代码']\n            console.log(userid);\n            let modify = `<!DOCTYPE html>\n            <html lang=\"en\">\n            \n            <head>\n                <meta charset=\"UTF-8\">\n                <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n                <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n                <title>修改用户信息</title>\n                <script src=\"https://cdn.jsdelivr.net/gh/Rr210/hexofixed@v0.47/js/jquery-3.5.1.min.js\"></script>\n                <link rel=\"stylesheet\"\n                    href=\"https://cdn.jsdelivr.net/gh/Rr210/hexofixed@frame/frame/bootstrap/3/css/bootstrap.min.css\">\n                <script src=\"https://cdn.jsdelivr.net/gh/Rr210/hexofixed@frame/frame/bootstrap/3/js/bootstrap.min.js\"></script>\n            </head>\n            <style>\n                * {\n                    padding: 0;\n                    margin: 0;\n                }\n            \n                body {\n                    background-color: #ccc;\n                }\n            \n                .box {\n                    width: 770px;\n                    margin: 30px auto 0;\n                    border: 2px solid #888;\n                    border-radius: 10px;\n                }\n            \n                h5,button{\n                    margin: 20px auto;\n                    text-align: center;\n                    font-size: 20px;\n                    font-weight: 600;\n                }\n                .btn{\n                    display: block;\n                    margin-bottom: 10px;\n                }\n            \n                .form-control {\n                    width: 93%;\n                    margin: auto;\n                }\n            \n                label {\n                    margin-left: 30px;\n                    margin-right: 7px;\n                }\n                .hobb{\n                    display: block;\n                }\n            </style>\n            \n            <body>\n                <div class=\"box\">\n                    <h5>修改用户信息</h5>\n                    <form method=\"POST\" action=\"/modify?id=${userid._id}\">\n                        <div class=\"form-group\">\n                            <label for=\"username\">User Name</label>\n                            <input value=\"${userid.name}\" name=\"name\" type=\"text\" class=\"form-control\" id=\"username\" placeholder=\"请填写用户名\">\n                        </div>\n                        <div class=\"form-group\">\n                            <label for=\"mima\">Password</label>\n                            <input value=\"${userid.password}\" name=\"password\" type=\"password\" class=\"form-control\" id=\"mima\" placeholder=\"Password\">\n                        </div>\n                        <div class=\"form-group\">\n                            <label for=\"exampleInputFile\">Age</label>\n                            <input value=\"${userid.age}\" name=\"age\" type=\"number\" id=\"exampleInputFile\" placeholder=\"请输入年龄\" class=\"form-control\">\n                        </div>\n                        <div class=\"form-group\">\n                            <label for=\"exampleInputemail\">Age</label>\n                            <input value=\"${userid.email}\" name=\"email\" type=\"email\" id=\"exampleInputemail\" placeholder=\"请输入邮箱\" class=\"form-control\">\n                        </div>\n            \n                        <div class=\"form-group\">\n                            <label for=\"\" class=\"hobb\">hobbies</label>`\n            // 遍历定义的爱好数组，使用数组中的includes方法来判断数据是否存在\n            hobbiess.forEach(item=>{\n                let Hobbies = userid.hobbies.includes(item)\n                if(Hobbies){\n                    modify += `\n                <label for=\"football\">${item}</label><input type=\"checkbox\" id=\"football\" name=\"hobbies\" value=\"${item}\" checked>`\n                }else{\n                    modify += `\n                    <label for=\"football\">${item}</label><input type=\"checkbox\" id=\"football\" name=\"hobbies\" value=\"${item}\">`\n                }\n            })\n            modify += `\n                        </div>\n                        <button type=\"submit\" class=\"btn btn-primary\">Add User</button>\n                    </form>\n                </div>\n            </body>\n            </html>`\n            res.end(modify)\n        }else if(pathname == '/remove'){\n            // res.end(query.id)\n            await user.findOneAndDelete({_id:query.id})\n            res.writeHead(301,{\n                location:'/list'\n            })\n            res.end()\n        }\n    }\n     else if (method == \"POST\") {\n        // 用户的添加功能\n        let formData = ''\n        if(pathname == '/add'){        //接受用户的信息\n            req.on('data',param=>{\n                formData += param\n            })\n            req.on('end',async () =>{\n                // 返回表单信息，并将表单信息进行转化\n                let users = querystring.parse(formData)\n                // 将解析的信息传入到数据库中\n                await user.create(users)\n                // 传入信息后将页面进行重定向，使用写入响应头的方法,301表示重定向\n                res.writeHead(301,{\n                    location:'/list'\n                });\n                res.end()\n            })\n        }else if(pathname == '/modify'){\n            req.on('data',param=>{\n                formData += param\n            })\n            req.on('end',async () =>{\n                // 返回表单信息，并将表单信息进行转化\n                let users = querystring.parse(formData)\n                // 将解析的信息修改传入到数据库中 updataOne方法中第一个参数表示查询条件，第二修改的数据对象\n                await user.updateOne({_id:query.id},users)\n                // 传入信息后将页面进行重定向，使用写入响应头的方法,301表示重定向\n                res.writeHead(301,{\n                    location:'/list'\n                });\n                res.end()\n            })\n        }\n    }\n    // res.end('ok')\n})\n// 设置监听\napp.listen(3100)\n```\n{% endfolding %}\n\n## 模板引擎\n\n1. art-template  模板引擎\n2. 模板语法\n3. 标准语法 原始语法   \n\n{% folding green, 查看答案 %}\n```html\n4. `{{}}` 标准语法，原始语法`<%=数据 %>`\n### 原文输出 \n1. `{{@ }}` 标准语法\n2. `<%- 数据%>` 原始语法\n### 条件判断\n1. 标准语法  `{{if 条件}} 。{{else if }}。{{else}}。{{ /if  }}   `\n2. 原始语法 ` <% if(value) { %>...<% }  else if (value) {%> 内容 <%} else{%> content <%}%>`\n### 循环\n1. 标准语法` {{each 数据 }{{$index}}{{$value}} {{/each}}  `\n2. 原始语法 `<% for() {%><%} %>`\n### 子模版\n1. 标准语法 `{{include '模板'}}`\n2. 原始语法`<%include('模板')%>`\n### 模板继承\n1. 将网站的html骨架抽离到独立的文件中，其他页面模板可以继承骨架文件\n2. `{{entend '继承的模板'}}`\n3. 使用`{{block ‘名称}}{{/block}}`\n​```js\nconst template = require('art-template')\nconst path = require('path')\n// template方法是用来拼接字符串,join方法将位置拼接\nconst views = path.join(__dirname,'view','index.html')\n\nconst html = template(views,{\n    name: 'ad',\n    age:18,\n    content:'<h3>我是标题</h3>',\n    users:[{\n        name:'a',\n        age:19,\n        sex:'男'\n    },{\n        name:'b',\n        age:20,\n        sex:'男'\n    },\n    {\n        name:'c',\n        age:25,\n        sex:'女'\n    },\n    ]\n})\nconsole.log(html);\n```\n```css\n/*\n{{block 'head'}}{{/block}}\n<!-- 标准语法引入子模版 -->\n{{include './header.art'}}\n<!-- 标准语法 -->\n<p>{{ name }}</p>\n<p>{{ age }}</p>\n<p>{{ 1 + 2 }}</p>\n<p>{{ 1*0 == 0 }}</p>\n<!-- 原文输出 -->\n<p>{{@ content }}</p>\n<p>{{ content }}</p>\n<!-- 条件判断 -->\n<span>{{if age > 10}} 年龄大于10 {{/if}}</span>\n<!-- 循环 -->\n<ul>\n    {{ each users }}\n    <li>{{ $value.name }}</li>\n    <li>{{ $value.age }}<span>{{if age > 10}} 年龄大于10 {{/if}}</span></li>\n    <li>{{ $value.sex }}</li>\n    {{/each}}\n</ul>\n<!-- 原始语法 -->\n<p>\n    <%= name %>\n</p>\n<p>\n    <%= content %>\n</p>\n<!-- 原文输出 -->\n<p>\n    <%- content %>\n</p>\n<!-- 条件判断 -->\n<span>\n    <%if(age>10){%>年龄大于10<%}%>\n</span>\n<!-- 循环 -->\n<ul>\n    <%for(var i=0;i < users.length;i++){ %>\n        <li>\n            <%= users[i].name%>\n        </li>\n        <li>\n            <%= users[i].age%>\n        </li>\n        <li>\n            <%= users[i].sex%>\n        </li>\n        <% }%>\n</ul>\n<!-- 原始语法引入子模版 -->\n<%include ('./footer.art')%>\n<!-- 加入模块继承使用标准语法中的block双标签填充 -->\n\n*/\n```\n{% endfolding %}\n\n\n## 模板配置\n\n1. template.defaults.imports.变量名 = 变量值\n2. 生成项目文件 `npm init -y`\n3. 使用第三方模块`router` 实现路由\n4. 对静态资源处理 `serve-static`\n5. 处理日期的第三方模块 `dateformat`\n\n{% folding green, 查看答案 %}\n\n```js\nconst http = require('http')\n// 导入连接数据库的模块\nrequire('./model/connect')\n// 有变量传入因此需要使用model.exports将变量引入\nconst Student = require('./model/user')\n// 创建网站服务器\nconst app = http.createServer();\n// 引入router模块\nconst getRouter = require('router')\n// 获取路由对象\nconst router = getRouter();\n// 引入模板引擎\nconst template = require('art-template')\n// 引入path模块\nconst path = require('path')\n// 配置模块的根目录\ntemplate.defaults.root = path.join(__dirname,'views')\n// template.defaults.extname = '.art'\n// 引入静态资源访问模块\nconst serveStatic = require('serve-static');\n// 实现静态资源访问服务\nconst serve = serveStatic(path.join(__dirname,'public'))\n// 呈递学生档案信息页面\nrouter.get('/add',(req,res)=>{\n    let html = template('add.art',{})\n    res.end(html)\n})\n// 呈递列表页面\nrouter.get('/list',(req,res)=>{\n    res.end('list')\n})\napp.on('request',(req,res)=>{\n    // 页面启用路由功能\n    router(req,res,()=>{})\n    // 页面启用静态资源访问功能\n    serve(req,res,()=>{})\n})\napp.listen(80)\n```\n{% endfolding %}\n\n{% folding green, route路由代码 %}\n```js\n\n// 有变量传入因此需要使用model.exports将变量引入\nconst Student = require('../model/user')\n// 引入模板引擎 \nconst template = require('art-template')\n// 引入querystring模块\nconst querystring = require('querystring')\n// 引入router模块\nconst getRouter = require('router')\n// 获取路由对象\nconst router = getRouter();\n// 呈递学生档案信息页面\nrouter.get('/add',(req,res)=>{\n    let html = template('add.art',{})\n    res.end(html)\n})\n// 呈递列表页面\nrouter.get('/list',async (req,res)=>{\n    // 查询学生信息\n    let students = await Student.find()\n    console.log(students);\n    let html = template('list.art',{\n        students: students\n    })\n    res.end(html)\n})\n// 实现学生信息添加功能路由\nrouter.post('/add',(req,res)=>{\n    let formData = '';\n    req.on('data',param =>{\n        formData += param\n    })\n    req.on('end',async ()=>{\n        await Student.create(querystring.parse(formData));\n        // 重定向第二个参数为对象\n        res.writeHead(301,{\n            location:'/list'\n        })\n        res.end()\n    })\n\n})\n// 将router方法暴露出来给其他模块使用\nmodule.exports = router\n```\n{% endfolding %}\n\n{% folding green, 模块代码 %}\n```js\nconst http = require('http')\n// 导入连接数据库的模块\nrequire('./model/connect')\n// 创建网站服务器\nconst app = http.createServer();\n// 引入模板引擎 \nconst template = require('art-template')\n// 引入path模块\n// 将router方法从模块中导入使用require方法\nconst router = require('./route/index')\nconst path = require('path')\n// 引入处理日期的第三方模块 dateFormat\nconst dateformat = require('dateformat')\n// 配置日期的模块处理,模块中的第一个参数表示自定义的属性名，第二个参数表示要显示的日期格式\ntemplate.defaults.imports.dateformat = dateformat\n// 配置模块的根目录\ntemplate.defaults.root = path.join(__dirname,'views')\n// template.defaults.extname = '.art'\n// 引入静态资源访问模块\nconst serveStatic = require('serve-static');\n// 实现静态资源访问服务\nconst serve = serveStatic(path.join(__dirname,'public'))\n\napp.on('request',(req,res)=>{\n    // 页面启用路由功能\n    router(req,res,()=>{})\n    // 页面启用静态资源访问功能\n    serve(req,res,()=>{})\n})\napp.listen(80)\n```\n{% endfolding %}","categories":["web","node.js"]},{"title":"Javascript的知识总结（16）","url":"/posts/18052/","content":"\n<div class=\"note primary icon flat\"><p>ES6的类和对象</p></div>\n\n## ES6 类\n\n1. 创建类 `class Star { constructor(uname){ this.uname = uname} }`\n2. 利用类创建对象  `var ldh = new Star('')`  \n3. constructor 函数只要new生成实例时，就会调用这个函数\n4. 类里面的所有函数不需要写function()，多个函数方法之间不需要添加`，`\n\n## 类的继承\n\n1. 语法 class father{ }  class son extends father{}  \n2. 继承父类的一些属性和方法\n3. `super()`关键字调用父类的构造函数\n\n{% folding green, 查看实例 %}\n```js\n        class father{\n            constructor(x,y){\n                this.x = x;\n                this.y = y;\n            }\n            sum(){\n                console.log(this.x+this.y);\n            }\n        }\n        class son extends father{\n            constructor(x,y){\n                super(x,y);\n            }\n        }\n        var Son = new son(1,2)\n        Son.sum();\n```\n{% endfolding %}\n\n## super关键字\n\n1. 关键字调用父类的构造函数\n2. 关键字可以调用普通函数\n3. 继承属性或者方法查找原则就近原则\n4. 子类构造函数调用父类函数时，super关键词必须写到 字类this之前调用\n\n{% folding green, 查看实例 %}\n```js\n        class father{\n            say(){\n                return 'didi'\n            }\n        }\n        class son extends father{\n            say(){\n                console.log(super.say());\n            }\n        }\n        var oo = new son()\n        oo.say()\n```\n{% endfolding %}\n\n## ES6类和对象要注意的问题\n\n1. 必须`先定义类`，才能通过类实例化对象\n2. 类里面共有的属性和方法一定要加`this`使用\n3. **注意this的指向问题，constructor里面的this 指向的时创建的实例化对象，方法种的this指向的调用这个方法的实例化对象**   重点\n\n{% folding green, 查看实例 %}\n```js\nclass star{\n    constructor(uname,age){\n        this.name = uname\n        this.age = age;\n        // this.sing()  可以调用函数，但是必须加this\n        // 如果添加一些事件后在执行要注意 this.sing; 函数后面不加小括号，如果加上小括号表示直接调用\n    }\n    sing(){\n        console.log(this.name);\n    }\n}\nvar iu = new star('iu')\n```\n{% endfolding %}\n\n## 面向对象案例\n\n1. 使用es6新特性添加元素 `insertAdjacentHTML(position,ele)`\n2. `e.stopPropagation()`  // 阻止冒泡事件\n3. 双击禁用选定文字  `window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty(); `\n\n{% folding green, 查看案例 %}\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<style>\n   *{\n    padding: 0;\n    margin: 0;\n    box-sizing: border-box;\n}\nbody{\n    background-color: rgb(180, 175, 175);\n}\nh4{\n    margin: 50px auto;\n    width: 200px;\n    height: 100px;\n    font-weight: 600;\n    line-height: 100px;\n    text-align: center;\n}\nli{\n    list-style: none;\n}\n.box{\n    width: 800px;\n    height: 400px;\n    border: 2px solid #ccc;\n    margin: 0 auto;\n    border-radius: 10px;\n    box-shadow: 0px -5px 10px #888;\n}\n#box ul .clickcss{\n    border-bottom: none;\n}\n.nav{\n    width: 100%;\n    height: 50px;\n}\n.nav ul {\n    height: 100%;\n    float: left;\n}\n.nav .addTab{\n    float: right;\n}\n.nav ul li{\n    position: relative;\n    width: 85px;\n    float: left;\n    border-bottom: 2px solid #ccc;\n    border-right: 2px solid #ccc;\n    height: 100%;\n    padding-top: 18px;\n    text-align: center;\n}\n.nav ul li p{\n    position: absolute;\n    right: 0;\n    top: 2px;\n    width: 15px;\n    height: 15px;\n    border-radius: 4px;\n    font-size: 12px;\n    font-weight: 600;\n    background-color: bisque;\n}\n.addTab{\n    height: 100%;\n    width: 50px;\n    font-size: 30px;\n    font-weight: 600;\n    line-height: 50px;\n    text-align: center;\n    border-left: 2px solid #ccc;\n    border-bottom: 2px solid #ccc;\n}\nsection{\n    padding: 10px;\n}\nsection p{\n    display: none;\n}\n.blockcss{\n    display: block;\n}\nspan{\n    width: 100%;\n}\nspan input{\n    width: 100%;\n} \n</style>\n<body>\n    <h4>es6 js面向对象的动态</h4>\n    <div class=\"box\" id=\"box\">\n        <div class=\"nav\">\n            <ul>\n                <li class=\"clickcss\"><span>你好世界</span><p>x</p></li>\n                <li><span>你好世界</span><p>x</p></li>\n                <li><span>你好世界</span><p>x</p></li>\n            </ul>\n            <div class=\"addTab\">+</div>\n        </div>\n        <section>\n            <p class=\"blockcss\">你好世界a</p>\n            <p class=\"\">你好世界b</p>\n            <p class=\"\">你好世界c</p>\n        </section>\n        \n    </div>\n    <script>\n        window.addEventListener('DOMContentLoaded', function () {\n    var that;\n    class Tab{\n        // 获取元素\n        constructor(id){\n            that = this;\n            this.main = document.querySelector(id);\n            this.add = this.main.querySelector('.addTab')\n            this.fitem = this.main.querySelector('section')\n            this.ul = this.main.querySelector('.nav ul:first-child')\n            this.init();\n        }\n        // 获取所有的li 和 items\n        updateTAb(){\n            this.lis = this.main.querySelectorAll('li');\n            this.remove = this.main.querySelectorAll('ul li p')\n            this.items = this.main.querySelectorAll('section p');\n            this.spans = this.main.querySelectorAll('ul li span')\n        }\n        init(){\n            // 初始化\n            this.updateTAb();\n            this.add.onclick = this.addTab;\n            for(var i = 0; i< this.lis.length;i++){\n                this.lis[i].index = i;\n                this.lis[i].onclick = this.toggleTab;\n                this.remove[i].onclick = this.removeTab;\n                this.spans[i].ondblclick = this.exit;\n                this.items[i].ondblclick = this.exit;\n            }\n        }\n        // 切换功能\n        toggleTab(){\n            // console.log(this.index);\n            that.clearClass();\n            this.className = 'clickcss'\n            that.items[this.index].className = 'blockcss'\n        }\n        clearClass(){\n            for(var i=0;i<this.lis.length;i++){\n                this.lis[i].className = ''\n                this.items[i].className = ''\n            }\n        }\n        addTab(){   \n            // 调用之前将之前的样式清除\n            that.clearClass()\n            // 创建元素 and 追加元素\n            var random = Math.random()\n            // 使用新的函数insertAdjacentHTML(position,ele)\n            var li = '<li class=\"clickcss\"><span>新标签</span><p>x</p></li>'\n            var item1 = '<p class=\"blockcss\">你好世界b'+random+'</p>'\n            // 把元素追加到父元素内孩子的最后面\n            that.ul.insertAdjacentHTML('beforeend',li)\n            that.fitem.insertAdjacentHTML('beforeend',item1)\n            that.init();\n        }\n        removeTab(e){\n            e.stopPropagation()  // 阻止冒泡事件\n            var index = this.parentNode.index\n            console.log(index);\n            // this.remove() 可以删除元素\n            that.lis[index].remove();\n            that.items[index].remove();\n            that.init()\n            // 当页面中有下面这个小li时，返回return，不执行下面的\n            if(document.querySelector('.clickcss')) return;\n            index--;\n            // 自动调用鼠标点击事件\n            that.lis[index] && that.lis[index].click();\n        }\n        exit(){\n            var str = this.innerHTML;\n            window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty(); \n            this.innerHTML = '<input type=\"text\">'\n            var input = this.children[0]\n            input.value = str;\n            input.select();\n            input.onblur = function(){\n                this.parentNode.innerHTML = this.value\n            }\n            input.onkeyup = function(e){\n                if(e.keyCode === 13){\n                    this.blur();\n                }\n            }\n    }\n}\n    new Tab('#box')\n})\n    </script>\n</body>\n</html>\n```\n{% endfolding %}\n\n## 构造函数的缺点\n\n1. 使用构造函数的方法时使用函数的方法 多个对象使用复杂数据类型会浪费内存\n2. 使用新特性`prototype`只能`函数.prototype.方法`共享方法，通过原型（对象）分配，公共的方法放到原型对象身上\n3. 静态成员在构造函数本身身上添加成员，函数.属性/方法，静态成员只能通过构造函数来访问\n4. `__proto__`指向我们构造函数的原型对象，和`prototype`是等价的，它是非标准属性，一条路线，都存在一个constructor函数\n\n## constructor 构造函数\n\n1. 在使用prototype对象时要注意`.`  和 `=` 的区别,如果使用等号时会将原来的constructor覆盖无法指向原来的函数，必须使用constructor函数重新手动指向原来的函数\n2. `.`是添加一个属性或者方法, `=`是将原来的constructor覆盖,如果修改了原来的原型对象，给原型对象赋值的是对象必须使用constructor函数重新指向原来的原型对象\n\n{% folding green, 查看实例 %}\n```js\n        function Star(name, age){\n            this.uname = name;\n            this.age = age;\n        }\n        var dd = new Star('你好')\n        // Star.prototype.title = '世界'\n        // console.log(dd.title);\n        // 使用 = 将函数原来的constructor覆盖，必须使用construtor指向原来的函数\n        Star.prototype = {\n            constructor: Star,\n            title: function(){\n                console.log('世界');\n            }\n        }\n        console.log(Star.prototype.constructor);\n        console.log(dd.__proto__.constructor)\n        //  = 和 . 有区别\n```\n{% endfolding %}\n\n2. 记录引用了哪个函数  \n3. 只要是对象就有`__proto__`\n4. object原型对象为`null`\n\n## 原型链\n\n1. js的查找机制根据原型链查找\n2. 并且遵循就近原则 \n\n{% folding green, 查看实例 %}\n```js\n        // js查找机制就近原则，按照原型链的方法\n        dd.sex = 'nv'\n        Object.prototype.sex = 'bianxingren'\n        Star.prototype.sex = 'nan'\n        console.log(dd.sex)\n```\n{% endfolding %}\n\n![构造函数与实例化对象还有原型对象的关系](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/constructor.webp)\n\n{% folding green, 查看实例 %}\n```js\n        function Star(name, age) {\n            this.uname = name;\n            this.age = age;\n        }\n        var dd = new Star('ni',18)\n        // Star.prototype.title = '世界'\n        // console.log(dd.title);\n        // 使用 = 将函数原来的prototype覆盖，必须使用construtor指向原来的函数\n        Star.prototype = {\n            constructor: Star,\n            title: function () {\n                console.log('世界');\n            }\n        }\n        // 指向原型对象\n        console.log(\"函数原型对象所使用的函数为:\"+Star.prototype.constructor);\n        // 指向原型对象\n        console.log(\"Star函数的原型对象：\"+Star.prototype); \n        console.log(Star);\n        console.log(dd);\n        console.log('判断函数的原型对象的与实例化对象指向所用的函数的关系'+Star.prototype.constructor === dd.__proto__.constructor);\n        // 原型对象指向的是Object的原型\n        console.log(\"判断函数原型对象的指向与对象的原型对象的关系:\"+(Star.prototype.__proto__ === Object.prototype));\n        // 指向原型对象 \n        console.log(\"实例化对象的指向为\"+dd.__proto__);\n        // 指向Object\n        console.log(\"函数原型对象的指向使用的函数为：\"+Star.prototype.__proto__.constructor);\n        console.log(\"Object的指向为：\"+Object.__proto__);\n        // Object原型对象的指向为null\n        console.log(\"Object的原型对象的指向为：\"+Object.prototype.__proto__);\n        //  = 和 . 有区别\n```\n{% endfolding %}\n\n## this指向\n\n1. 在构造函数中里面的this指向的是对象实例\n2. 原型对象函数里面的this指向的是实例对象\n\n## 扩展内置对象\n\n1. 数组和字符串内置对象不能给原型对象覆盖操作`Array.prototype = {}` ,只能是`Array.prototype.xxx = function(){}`的方式\n2. 可以使用原型对象里面的扩展对象，页可以自定义扩展方法\n\n{% folding green, 查看实例 %}\n```js\n        console.log(Array.prototype);\n        Array.prototype.sum = function(){\n            // console.log(this.length);\n            // console.log(this);\n            var sum  = 0;\n            for(var i= 0;i<this.length;i++){  \n                sum += this[i];\n                // console.log(this[i]);\n            }\n            return sum\n        }\n        var arr = new Array(1,2,3,4)\n        console.log(arr.length);\n        console.log(arr.sum());\n```\n{% endfolding %}\n\n## call()\n\n1. 作用：调用这个函数，可以修改调用函数的this的指向\n2. 格式： `函数.call()`  函数不加括号 ` fn.call()`\n3. call(实例化对象) 可以改变函数的this指向，并且不传递\n\n{% folding green, 查看实例 %}\n```js\n        function sun(x,y){\n            console.log(this);\n            console.log(x+y);\n        }\n        sun()\n        var no = {\n            name: 'jjj'\n        }\n        sun.call(no,1,2)\n```\n{% endfolding %}\n\n### 借用构造函数继承父类属性\n\n{% folding green, 查看实例 %}\n```js\n        function Father(uname,age){\n            this.uname = uname;\n            this.age = age\n        }\n        function Son(uname,age){\n            Father.call(this,uname,age)\n        }\n        var dd = new Son('dd',18)\n        console.log(dd);\n```\n{% endfolding %}\n\n### 借用构造函数继承父类方法\n\n1. 在使用对象的形式修改了原型对象时，使用constructor来指向原来的构造函数\n\n{% folding green, 查看实例 %}\n```js\nfunction Father(uname,age){\n    this.uname =uname\n    this.age = age\n}\nfunction Son(uname,age){\n    Father.call(this,uname,age)\n}\nSon.prototype.exam = function(){\n    console.log(10);\n}\n// Father.prototype = Son.prototype\n// 利用对象的形式修改了原型对象，记得使用constructor来指向原来的构造函数\nSon.prototype = new Father()  \n// 构造函数的原型对象始终都是指向本身\nSon.prototype.constructor = Son\nFather.prototype.money = function(){\n    console.log(11);\n}\nvar son =new Son('dd',17)\nconsole.log(son);\nconsole.log(Father.prototype);\nconsole.log(Son.prototype.constructor);\n```\n{% endfolding %}\n\n## ES5新增方法\n\n1. 数组方法 map()  every()\n- `forEach()` 遍历方法，有一个`回调函数`里面有3个参数  value，index，array，分别表示每个元素的值，每个元素的索引号，元素本身 \n- 迭代 `filter()` 筛选的作用 ，返回一个新的数组 return  迭代遍历\n- `some()`  查找元素中是否有满足条件的元素， 返回的是布尔值，找到第一个满足条件的元素终止循环\n- `every()` 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。\n- `map()` 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。\n2. 在`forEach` 和`filter`里面遇到`return true` 不会终止迭代 ，在`some`里面遇到`return true` 停止迭代\n\n{% folding green, 查看答案 %}\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n\n<body>\n    <style>\n        * {\n            padding: 0;\n            margin: 0;\n            box-sizing: border-box;\n        }\n\n        table {\n            border: 1px solid #ccc;\n            border-bottom: 0;\n            border-right: 0;\n            margin: 50px auto;\n            width: 450px;\n        }\n\n        tbody {\n            text-align: center;\n        }\n\n        thead {\n            border-bottom: 1px solid #ccc;\n        }\n\n        td,\n        th {\n            border-right: 1px solid #ccc;\n            border-bottom: 1px solid #ccc;\n        }\n\n        h4 {\n            display: inline-block;\n            margin-right: 5px;\n        }\n\n        .search {\n            text-align: center;\n            margin: 10px auto;\n        }\n\n        input {\n            width: 40px;\n        }\n\n        input,\n        button {\n            outline-style: none;\n        }\n\n        button {\n            margin-left: 5px;\n        }\n    </style>\n    <div class=\"search\">\n        <h4>按照价格查询</h4><input class=\"start\" type=\"text\">-<input class=\"end\" type=\"text\"><button\n            class=\"search-price\">搜索</button>\n        <h4>按照产品名称查询</h4><input class=\"chanp\" type=\"text\"><button class=\"search-name\">搜索</button>\n    </div>\n\n\n    <table cellspacing='0'>\n        <thead>\n            <tr>\n                <th>id</th>\n                <th>产品名称</th>\n                <th>价格</th>\n            </tr>\n        </thead>\n        <tbody>\n        </tbody>\n    </table>\n    <script>\n        var data = [{\n            id: 1,\n            pname: '小米',\n            price: 999\n        },\n        {\n            id: 2,\n            pname: '华为',\n            price: 1933\n        },\n        {\n            id: 3,\n            pname: 'iPhone',\n            price: 2999\n        },\n        {\n            id: 4,\n            pname: 'oppo',\n            price: 3999\n        }]\n        var tbody = document.querySelector('tbody')\n        // 首先通过遍历数组获取数组中的元素，然后创建新的元素，将获取到的值添加到元素的中\n        setData(data)\n        // 封装一个函数使得搜索的时候能重复调用\n        function setData(mydata) {\n            tbody.innerHTML = ''\n            mydata.forEach(function (value) {\n                var tr = document.createElement('tr')\n                tr.innerHTML = '<td>' + value.id + '</td><td>' + value.pname + '</td><td>' + value.price + '</td>'\n                tbody.appendChild(tr)\n            })\n        }\n        // 使用filter()方法 遍历迭代数组，找出满足条件的，返回一个新的数组\n        var searchPrice = document.querySelector('.search-price')\n        var start = document.querySelector('.start')\n        var end = document.querySelector('.end')\n        searchPrice.addEventListener('click', function () {\n            var newData = data.filter(function (value) {\n                return value.price >= start.value && value.price <= end.value\n            })\n            console.log(newData);\n            setData(newData)\n        })\n        // // 通过产品的名称搜索 使用filter方法\n        var chanp = document.querySelector('.chanp')\n        var searchName = document.querySelector('.search-name')\n        // searchName.addEventListener('click',function(){\n        //     var newdata1 = data.filter(function(value){\n        //         return value.pname == chanp.value\n        //     })\n        //     setData(newdata1)\n        // })\n\n        // 通过some来遍历 效率更高\n            searchName = document.addEventListener('click',function(){\n                var arr  = []\n                data.some(function(value){\n                    if(value.pname == chanp.value){\n                        arr.push(value)\n                        return true;  \n                    }\n                })\n                setData(arr)\n            })\n\n    </script>\n</body>\n\n</html>\n```\n{% endfolding %}\n\n\n### 字符串方法\n\n>`trim()` 方法 去除字符串的两侧的空格\n\n### 对象方法\n\n1. 用于获取对象自身所有的属性  Object.keys(obj)\n2. `Object.defineProperty(对象,属性,descriptor 对象的格式{ value: ''})`定义对象中的属性或者修改原有的属性\n- descriptor中的属性值：`value`表示所修改或者新增的值,默认为undefined，`writable:false` 不允许修改属性值\n- enumerable;表示目标属性是否可以被遍历，默认值为false\n- configurable:表示目标属性是否可以被修改或者删除，或者再次修改新特性 默认为false\n\n### 函数的定义方法\n\n1. 命名函数，匿名函数\n2. 利用`var fn = new function（‘参数’，’参数‘，’函数体‘）`必须以字符串的格式编写\n3. 所有的函数都是Function的实例对象,函数也属于对象\n\n### 函数的调用方式\n\n1. 普通函数的调用\n```js\nfunction fn(){\n    console.log(11);\n}\nfn(); fn.call()\n```\n2. 对象的方法调用\n```js\nvar o = {\n    fn:function(){\n        console.log(11);\n    }\n}\no.fn();\n```\n3. 构造函数的调用方法\n```js\nfunction Fn(){\n    console.log(11);\n}\nnew Fn();\n```\n4. 绑定事件函数\n```js\nobj.onclick = function(){\n    console.log(11);\n}\n```\n5. 定时器函数的调用\n```js\nsetInterval(function(){\n    console.log(11)\n},1000)\n```\n6. 立即执行函数\n```\n(function(){\n    console.log('立即执行函数'+11);\n})()\n//第二种\n(function(){\n    console.log('立即执行函数'+11);\n}())\n```\n\n### 改变函数内部的this的指向\n\n1. `call（arr，'',''）`arr为对象，后面可以传递参数；调用函数；改变函数内的this指向；主要作用可以实现继承\n2. `apply（thisarr，['']）`方法  也是调用函数可以改变函数内部的this指向，但是传递参数时必须以数组的形式传递（伪数组）\n- 调用数学内置对象 比如:`Math.max.apply(Math,arr)`,arr必须为`数组`的形式\n3. bind（thisarr,'',''）方法 `不会调用函数`，也能改变指向， 但是返回的是原函数改变this之后产生的函数\n\n{% folding green, 查看实例 %}\n```js\n// 使用bind方法来改变函数内部的this指向\nvar btn = document.querySelector('button')\nbtn.onclick = function(){\nthis.disabled = 1\nsetTimeout(function(){\nthis.disabled = 0\n}.bind(this),3000)\n}\n```\n{% endfolding %}\n\n### 严格模式\n\n1. `'use strict';`为整个脚本开启严格模式\n2. 可以为某个函数开启严格模式\n3. 不能随意删除已经定义好的变量\n4. 严格模式下的全局变量的this是`undefined`\n5. 严格模式下调用构造函数必须加new\n6. 函数名不允许有重名的情况\n7. 不允许在非函数里声明函数\n\n## 高阶函数\n\n1. 对其他函数进行操作的函数，接受函数作为`参数`或者将函数作为`返回值输出`\n2. 函数也是一种`数据类型`\n3. `回调函数`--高阶函数\n\n## 闭包（Closure）\n\n1. 函数，有权访问另一个函数作用域中变量的函数,被访问函数变量\n\n{% folding green, 查看实例 %}\n```js\n(function(){\n'use strict';\nfunction fn(){\nvar num = 10\n// function fun(){\n//     console.log(num);\n// } \n// 使用return 高级函数 可以从一个作用域访问另一个函数的局部变量，相当于继承\nreturn function(){\nconsole.log(num);\n}\n}\n// fn.apply()   执行后return 一个函数\nconsole.log(fn.apply());\n// 定义函数后在调用，可以实现全局调用\nvar f = fn()\nf();\n}())\n```\n{% endfolding %}\n\n2. 主要作用：延伸了变量的作用范围\n\n### 案例获取元素索引号，打印元素的内容类似\n{% folding green, 查看案例使用闭包获取元素索引号 %}\n```js\n// 第一种使用动态添加属性来获取某个索引号\nvar lis = document.querySelectorAll('ul li') \n// console.log(lis);\nfor(var i =0;i<lis.length;i++){\n    lis[i].index = i\n    lis[i].onclick =function(){\n        console.log(this.index);\n    }\n}\n// 第二种使用闭包的方法获取某个点击元素的索引号\nfor(var i = 0;i<lis.length;i++){\n    (function(i){\n        lis[i].onclick = function(){\n            console.log(i);\n        }\n    })(i)\n}\n```\n{% endfolding %}\n### 案例打车价格\n\n{% folding green, 查看案例 %}\n```js\n    // <!-- 使用闭包来实现 打车的收费，定义起步价；10  超过3公里 按/公里 5 ，如果有拥堵的情况多收10 -->\n    var car = (function(){\n        var start = 10\n        var total = 0\n        return {\n            price:function(n){\n                n<=3 ? total = start : total = start + (n-3)*5\n                return total\n            },\n            yd:function(flag){\n                return flag ? total+10 :total\n            }\n        }\n    })()\n    console.log(car.price(parseFloat(prompt('请输入公里数：'))));\n    console.log(car.yd(1));\n```\n{% endfolding %}\n\n## 闭包思考重点\n\n1. 匿名函数中的this指向为window，立即执行函数封装功能不污染全局变量\n2. 判断this的指向  这里的this指向的是函数的调用者，对象，使用了局部变量 闭包使用\n{% folding green, 查看实例 %}\n```js\n// 匿名函数中的this指向为window，立即执行函数封装功能不污染全局变量\nvar name = 'the window'\nvar obj = {\n    name: 'world',\n    sun: function(){\n        return function(){\n            return this.name\n        }\n    }\n}\nconsole.log(obj.sun()());\n// 判断this的指向  这里的this指向的是函数的调用者，对象，使用了局部变量 闭包使用\nvar uname = 'tt'\nvar objs = {\n    uname:'kk',\n    ff:function(){\n        var that = this\n        return function(){\n            return that.uname;\n        }\n    }\n}\n// 立即执行函数\nconsole.log(objs.ff()());  \n```\n{% endfolding %}\n\n## 递归函数\n\n1. 在函数的内部自己调用自己\n2. 递归函数中必须加退出语句\n\n{% folding green, 查看实例 %}\n```js\n// var num = 1;\n// function fn() {\n//     console.log(6);\n//     if (num == 6) {\n//         return;\n//     } num++; \n//     fn();\n// }\n// fn();\n// 使用递归函数求阶乘\nfunction sun(n){\n    if(n==1){\n        return 1;\n    }\n    return n * sun(n-1)\n}\nsun(3);\nconsole.log(sun(3));\n        // 使用递归函数求斐波那契数列（兔子序列）\n        function fb(n){\n            if(n==1 || n==2){\n                return 1;\n            }\n            return fb(n-1) +fb(n-2)\n        }\n        console.log(fb(6));\n// 使用递归查找对象属性值，深度查找 \nvar obj = [{\n    id: 1,\n    name: 'd',\n    foods: [{\n        id: 11,\n        name: 'w'\n    }, {\n        id: 12,\n        name: 'u'\n    }]\n},\n{\n    id: 2,\n    name: 's'\n}]\n// 开始遍历\nfunction getId(json, id) {\n    json.forEach(function (item) {\n        if (item.id == id) {\n            console.log(item);\n        } else if (item.foods && item.foods.length != 0) {\n            getId(item.foods, id)\n        }\n    })\n}\ngetId(obj, 1)\ngetId(obj, 11)\ngetId(obj, 2)\n```\n{% endfolding %}\n\n## 浅拷贝和深拷贝\n\n1. assign（目标对象，源对象），浅拷贝\n2. 深拷贝 使用递归函数\n\n{% folding green, 查看实例 %}\n```js\n        // 浅拷贝只拷贝地址,会影响原来的数据，不会新建一个对象\n        var obj ={\n            id:1,\n            name:'s',\n            msg:{\n                sex:'nan',\n                age:18\n            },\n            color:['red','green']\n        }\n        var o = []\n        // for (var k in obj){\n        //     o[k] = obj[k]\n        // }\n        // console.log(o);\n        // o.msg.sex = 2\n        // console.log(o);\n        // console.log(obj);\n        // 使用assign方法,类似与浅拷贝\n        // Object.assign(o,obj)\n        // o.msg.sex = 17\n        // console.log(o);\n        // console.log(obj);\n\n\n        // 深拷贝\n        function Deepcopy(newobj,oldobj){\n            for(var k in oldobj){\n                // 判断属性值属于哪种数据类型\n                var item = oldobj[k]\n                // 判断属性值是否为数组,数组也属于对象，注意顺序\n                if(item instanceof Array){\n                    newobj[k] = []\n                    Deepcopy(newobj[k],item)\n                }else if(item instanceof Object){\n                    newobj[k] = {}\n                    Deepcopy(newobj[k],item)\n                }\n                else{\n                    newobj[k] = item;\n                }\n                // 判断属性值是否为对象\n                // 判断属性值是否为简单数据类型\n            }\n        }\n        Deepcopy(o,obj)\n        // 深拷贝对源对象无影响\n        o.msg.sex = '1'\n        console.log(o);\n        console.log(obj);\n```\n{% endfolding %}\n\n## 正则表达式\n\n1. 对象 用于匹配字符串中字符组合的模式\n2. 匹配，替换，提取\n3. 不需要加引号\n\n### 创建正则表达式\n\n1. 使用RegExp对象来创建  格式`var 变量名 = new RegExp(/ /)`\n2. 利用字面量创建 格式 `var rg = /123/`\n\n### 测试是否符合规范\n\n1. test()  正则对象方法 表达式.test(str)   返回true/false\n\n### 特殊字符\n\n1. 元字符 `^ +  - / *`  等等\n2. 边界符  `^ $ `   开头或者结尾\n3. 字符类：`[]` 表示有一系列字符可供选择，匹配一个即可 ` - `表示范围\n4. 如果中括号里面有`^`表示取反\n5. 量词符 设置模式出现的次数  \n6. 量词，中间不要有空格 ,注意如果是 `/^abc{3}$/` 表示的是将c重复三次  ,如果加了小括号`（abc）`按前面的三个重复执行三次\n\n{% folding green, 查看实例 %}\n```js\nvar ld = /111/\n//(1) /11/ 表示只要字符串中含有这些相连字符，都满足条件\nconsole.log(ld.test(11)); //false\n// 开头\nvar ldd = /^11/ \nconsole.log(ldd.test(111)); //true\n// 满足结尾条件\nvar ldd = /11$/\nconsole.log(ldd.test(11)); //true\n// 满足指定条件\nvar ldd = /^11$/\nconsole.log(ldd.test(11)); //true\nconsole.log('我是分割线----------------------');\n// (2) 字符类 []  表示只要有满足条件的即可，无序\nvar ld1 = /[abc]/\nconsole.log(ld1.test('ansc')); // true\nconsole.log(ld1.test('cse')); // true\n// 表示所匹配的字符必须为 a/b/c 才行\nvar ld2 = /^[abc]$/ \nconsole.log(ld2.test('cba')); //false\n// a-z 表示 26个英文字母 - 表示范围 ,表示从以下条件中任意一个字符如果满足为true/false 中括号内的^表示的是取反 ^[]$ 表示任意一个字符\nvar ld3 = /^[^a-zA-Z0-9_-]$/\nconsole.log(ld3.test('zzz')); //false\nconsole.log(ld3.test('=')); //true\nconsole.log('------------------------');\n// （3） 量词符 重复次数 * 表示0||n ; + 表示>=0; ? 表示 1||0; {3,} 表示>=3;{4,16} >=4 <=16\nvar reg = /^a*$/\nconsole.log(reg.test(''));  // true\nconsole.log(reg.test('a')); // true\nconsole.log(reg.test('aa'));// true\nvar reg1 = /^a+$/\nconsole.log(reg1.test('')); // false\nconsole.log(reg1.test('a'));//true\nvar reg2 = /^a?$/\nconsole.log(reg2.test('')); // true\nconsole.log(reg2.test('a')); // true\nconsole.log(reg2.test('aa')); // false\nvar reg3 = /^a{4,}$/\nconsole.log(reg3.test('aaaa')); //true\nvar reg4 = /^a{4,16}$/\nconsole.log(reg4.test('aaaaaaaaa'));  //true\n```\n{% endfolding %}\n\n### 表单验证案例\n\n{% folding green, 查看案例 %}\n```html\n    <style>\n        .right{\n            color:#064406\n        }\n        .error{\n            color: #580808;\n        }\n    </style>\n    <input type=\"text\" name=\"\" id=\"\"> <span>请输入6-16位的字符</span>\n    <script>\n        var reg = /^[a-zA-Z0-9]{3,16}$/\n        var input = document.querySelector('input')\n        var span  = document.querySelector('span')\n        input.onblur = function(){\n            if(reg.test(this.value)){\n                console.log('输入正确！！');\n                span.className = 'right'\n                span.innerHTML = '您输入的格式正确'\n            }else{\n                console.log('输入错误');\n                span.className = 'error'\n                span.innerHTML = '您输入的格式有误'\n            }\n        }\n    </script>\n```\n{% endfolding %}\n\n### 预定义类\n\n1. `\\d`  `\\D` 分别匹配所有数字和匹配所有的非数字\n2. `\\w` 匹配任意的字母，数字和下划线，相当于 `[^a-zA-Z0-9_]`  大写`W `表示非数字非字母，非下划线\n3. ` \\ s ` 匹配空格  大写表示非\n4. 正则里面的或者用符号 `|` 表示\n\n{% folding green, 表单注册案例 %}\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <link rel=\"stylesheet\" href=\"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css\">\n    <title>Document</title>\n</head>\n\n<body>\n    <style>\n        body {\n            background-color: #ccc;\n        }\n\n        * {\n            padding: 0;\n            margin: 0;\n            box-sizing: border-box;\n        }\n\n        input {\n            width: 170px;\n            padding: 5px;\n            border-radius: 5px;\n            outline: none;\n            border: 1px solid #888;\n            margin-left: 10px;\n        }\n\n\n        .fa-exclamation-circle {\n            color: #0099ff;\n            font-size: 12px;\n        }\n\n        .fa-times-circle {\n            color: red;\n            font-size: 12px;\n        }\n\n        .fa-check-circle {\n            color: green;\n            font-size: 12px;\n        }\n\n        .box {\n            width: 600px;\n            height: 300px;\n            margin: 50px auto;\n            border: 2px solid #888;\n            border-radius: 10px;\n            padding: 10px;\n        }\n\n        .w {\n            margin: 10px;\n        }\n    </style>\n    <div class=\"box\">\n        <div class=\"w\">手机号<input type=\"text\" placeholder=\"请输入手机号码\" class=\"phone\">\n            <i class=\"fa\"></i>\n        </div>\n        <div class=\"w\">QQ<input type=\"text\" placeholder=\"请输入QQ号码\" class=\"qq\">\n            <i class=\"fa\"></i>\n        </div>\n        <div class=\"w\">用户名<input type=\"text\" name=\"\" id=\"\" placeholder=\"请输入密码\" value=\"\" class=\"user\">\n            <i class=\"fa\"></i>\n        </div>\n        <div class=\"w\">密码<input type=\"password\" name=\"\" id=\"\" placeholder=\"请输入密码\" value=\"\" class=\"secret\">\n            <i class=\"fa\"></i>\n        </div>\n        <div class=\"w\">确认密码<input type=\"password\" name=\"\" id=\"\" placeholder=\"请输入密码\" value=\"\" class=\"suresecret\">\n            <i class=\"fa\"></i>\n        </div>\n    </div>\n\n    <!-- <span class=\"fa fa-times-circle\">fa fa-check-circle密码较短</span></div> -->\n    <script>\n        // 第一种不使用正则使用if判断条件\n        // 知识回顾 兄弟节点  nextSibling属性与nextElementSibling属性的差别：\n        // nextSibling属性返回元素节点之后的兄弟节点（包括文本节点、注释节点即回车、换行、空格、文本等等）；\n        // nextElementSibling属性只返回元素节点之后的兄弟元素节点（不包括文本节点、注释节点）；\n        var secret = document.querySelector('.secret');\n        var is = document.querySelectorAll('i');\n        // 密码的设置  使用普通方法\n        secret.onfocus = function () {\n            this.nextElementSibling.className = 'fa fa-exclamation-circle';\n            this.nextElementSibling.innerHTML = '请输入6-16位字符的密码';\n        }\n        secret.onblur = function () {\n            var inputli = this.nextElementSibling\n            var inputli = this.nextElementSibling\n            if (this.value == '') {\n                inputli.innerHTML = ''\n                inputli.className = '';\n            } else if (secret.value.length < 6 || secret.value.length > 16) {\n                inputli.className = 'fa fa-times-circle';\n                inputli.nextElementSibling.innerHTML = '您输入的密码不符合要求，请输入6-16位字符'\n            }\n            else {\n                inputli.className = 'fa fa-check-circle';\n                inputli.innerHTML = '您输入的格式正确！！'\n            }\n        }\n        // 第二种使用正则判断, 首先获取元素，手机号案例\n        var phone = document.querySelector('.phone')\n        var pnum = /^1[3|4|5|8|9]\\d{9}$/\n        // 然后是给元素添加事件，获取焦点和失去焦点\n        phone.onfocus = function () {\n            this.nextElementSibling.className = 'fa fa-exclamation-circle';\n            this.nextElementSibling.innerHTML = '请输入1-11位字符的手机号码';\n        }\n        phone.onblur = function () {\n            var inputli = this.nextElementSibling\n            if (this.value == '') {\n                inputli.innerHTML = ''\n                inputli.className = '';\n            } else if (pnum.test(this.value)) {\n                inputli.className = 'fa fa-check-circle';\n                inputli.innerHTML = '您输入的格式正确！！'\n            } else {\n                inputli.className = 'fa fa-times-circle';\n                inputli.innerHTML = '您输入的手机号格式有误，请输入1-11位的手机号码'\n            }\n        }\n        // 第三种 封装一个函数，如果需要判断的表单过多\n        var qq = document.querySelector('.qq')\n        var qqreg = /^[1-9]\\d{4,9}$/\n        // 函数格式  input表示所要判断嗯等元素对象，i表示获得焦点时所呈现的条件，reg为每个表单的正则判断，errorend表示失去焦点后如果不满足正则条件所返回的内容  这里还用到了闭包\n        function Judge(input, i, reg, errorend) {\n            input.onfocus = function () {\n                this.nextElementSibling.className = 'fa fa-exclamation-circle';\n                this.nextElementSibling.innerHTML = i\n            }\n            input.onblur = function () {\n                var inputli = this.nextElementSibling\n                if (this.value == '') {\n                    inputli.innerHTML = ''\n                    inputli.className = '';\n                } else if (reg.test(this.value)) {\n                    inputli.className = 'fa fa-check-circle';\n                    inputli.innerHTML = '您输入的格式正确！！'\n                } else {\n                    inputli.className = 'fa fa-times-circle';\n                    inputli.innerHTML = errorend\n                }\n            }\n        }\n        var qq = Judge(qq, '请输入5-10位的号码', qqreg, '您输入的格式错误,请输入5-10位的号码')\n        // 编写昵称的正则表达式，获取元素,格式要求为中文字符\n        var user = document.querySelector('.user')\n        var userreg = /^[\\u4e00-\\u9fa5]{3,5}$/\n        Judge(user, '请输入3-5位的中文字符', userreg, '你输入的格式有误，请重新输入3-5位的中文字符')\n        // 获取确认密码 \n        var suresecret = document.querySelector('.suresecret')\n        suresecret.onfocus = function () {\n            if (this.value == '') {\n                this.nextElementSibling.className = ''\n                this.nextElementSibling.innerHTML = ''\n            }\n        }\n        suresecret.onblur = function () {\n            var inputli = this.nextElementSibling\n            if (this.value == secret.value && this.value != '') {\n                inputli.className = 'fa fa-check-circle';\n                inputli.innerHTML = '两次密码一致！！'\n            } else {\n                inputli.className = 'fa fa-times-circle';\n                inputli.innerHTML = '两次密码不一致请重新输入！！！'\n            }\n        }\n    </script>\n</body>\n\n</html>\n```\n{% endfolding %}\n\n### 正则表达式替换\n\n1. `stringObject.repalce('被替换的字符/正则表达式',' 要替换的字符')`  使用repalce来实现字符串的替换\n2. /表达式/[switch]  swith参数 也称为i修饰符\n- `g`  全局匹配  `//g`\n- `i` 忽略大小写\n\n\n## ES6声明变量的关键字\n\n>ECMAScript  脚本语言\n\n### let关键字\n\n1. `let` 声明变量\n- 块级作用域   {}\n- 块级作用域  在大括号中使用let关键词才具有块级作用域\n- 防止循环变量变成全局变量\n- 使用let关键字的变量没有变量提升  先声明在提升\n- 使用let关键词声明的变量具有暂时性死区  与所在的{}绑定\n\n{% folding green, 查看实例 %}\n```js\n// 经典面试题 使用var 定义变量  这里时执行完for循环才会执行函数，所以获取到的数据始终都是全局变量下的数\n            var arr = []\n            for(var i = 0;i<2;i++){\n                arr[i] = function() {\n                    console.log(i);\n                }\n            }\n            arr[0]()\n            arr[1]()\n            console.log('----------------------');\n            // 使用let关键字 使用块级作用域效果 \n            let arr1 = []\n            for(let i = 0;i<2;i++){\n                arr1[i] = function(){\n                    console.log(i);\n                }\n            }\n            arr1[0]()\n            arr1[1]()\n```\n{% endfolding %}\n\n### const关键字\n\n1. 声明常量，不能变化的量，变量无法提升\n2. const常量的初始值必须赋值\n3. 常量声明后值不可更改，复杂数据类型中的值可以更改，直接赋值不允许\n\n### 解构赋值\n\n1. 允许从数组中按照一一对应的关系提取值，并将值赋给变量\n2. 格式 `let [a,b,c] = [1,2,3]`  变量与值相对，如果不对应 输出的值为undefined\n3. 对象解构，与数组类似`let {}`,允许使用变量的名字匹配对象的属性\n{% folding green, 查看答案 %}\n```js\n// 第一种获取属性值的方法 对象解构\nlet per = {name:'ww',sex:'nan'}\nlet {name,sex} = per\nconsole.log(name);\nconsole.log(sex);\n// const 对象解构第二种获取属性值的方法/\nlet perpon = {name:'mm',age:18} \nlet {name:myname,age:ages} = perpon\nconsole.log(myname);\nconsole.log(ages);\n// 数组解构\nlet re =  [1,2,3]\nlet [a,c,b] = re\nconsole.log(b);\n```\n{% endfolding %}\n\n### 箭头函数\n\n1. 简化函数定义语法  格式： `() => {}`\n2. 形参只有一个可以省略外侧的小括号\n3. 箭头函数不绑定this关键字\n4. say方法的箭头函数中的this指向的是定义这个方法的，对象是无法产生作用域的，所以这里的say中的this指向的是window，所以返回的值是undefined\n{% folding green, 查看答案 %}\n```js\nvar age = 100\nvar obj = {\nname: 'mm',\nage:15,\nsay:() =>{\nconsole.log(this.name);\n}\n}\n```\n{% endfolding %}\n\n### 剩余参数\n\n1. 将不定量的参数表示一个数组\n{% folding green, 查看答案 %}\n```js\n        // 剩余参数 ...args\n        const sum = (...args) => {\n            // 这里只能使用let，和var 定义变量  不能使用const, 为定值无法改变\n            let total = 0;\n            // 遍历传入数组的值\n            args.forEach(items => total += items)\n            return total\n        } \n        console.log(sum(1,2,3))\n        console.log(sum(1,2))\n```\n{% endfolding %}\n\n## 扩展运算符\n\n1. 可以将数组拆分成以`，`分隔的参数序列  `，`在控制器中为空格分隔符\n2. 可以合并数组\n3. 将伪数组转换为真正的数组 ` [...ary]`   `ary`为获取元素所定义的属性\n{% folding green, 合并数组的两种方法 %}\n```js\n// 方法一\nlet arr = [1, 2, 3]\nlet a = [4, 5, 6]\nlet c = [...a, ...arr]\nconsole.log(c);\n// 方法二使用push方法\narr.push(...a)\nconsole.log(arr);\n```\n{% endfolding %}\n4. array.from() 也可以将伪数组转换为真正的数组\n{% folding green, 查看答案 %}\n```js\n    // 使用from的方法将伪数组转换为数组\n    let obj = {\n        '0':'a',\n        '1':'b',\n        '2':'c',\n        length:3\n    }\n    console.log(obj);\n    console.log(Array.from(obj));\n```\n{% endfolding %}\n\n### find()和findIndex()方法 includes()，startsWith,endsWith()\n\n1. 找出第一个符合条件的成员 `find((,) => {})`\n2. findIndex() 方法返回数组中满足提供的测试函数的第一个元素的索引\n3. includes() 判断数组中是否包含某个值  括号内为判断的数组内容  返回值为true或者false\n4. 将某个字符串重复输出n次 repeat(n)\n\n## 模板字符串\n\n1. `${变量名}`， 注意必须加 ``反引号\n2. 可以调用函数\n3. 模板字符串可以换行\n\n## Set数据结构\n\n1. 类似于数组，成员的值都是唯一的，没有重复的值\n2. 本身是一个构造函数\n3. 可以使用set（）方法来实现数组去重\n4. 使用add方法向set（）中添加值\n\n{% folding green, 查看答案 %}\n```js\n// 伪数组\nlet obj = {\n    '0': 1,\n    '1': 2,\n    '2': 'a',\n    length: 3\n}\nconsole.log(obj);\n// 使用Array.from()的方法将伪数组转化为真正的数组\nconsole.log(Array.from(obj));\n\n// 使用find()方法  判断数组中是否存在某个元素并返回满足条件的第一个值,如果没有满足条件的则返回的值为undefined\n// let a = [1,2,3]\nlet a = [{\n    id: 1,\n    name: 'm'\n},\n{\n    id: 2,\n    name: 'a'\n}]\nconsole.log(a.find(item => item.id == 3));\n\n// 使用findIndex()方法来判断数组或者对象中的值是否存在，如果存在则返回的值为该元素的索引号，不存在则返回-1\nconsole.log(a.findIndex(item => item.id == 3));\n\n// 使用includes() 方法用于判断字符串或者数组是否包含指定的子字符串，返回布尔值\nlet b = [1, 2, 3]\nconsole.log(b.includes(1))\n\n// 模板字符串  使用格式 `${变量名}`  必须加``反引号 符号，模板字符串可以换行\nlet name = 'world'\nlet uname = `hello ${name} wo`\nconsole.log(uname);\nconsole.log('startsWith()'+uname.startsWith('hello'));\nconsole.log('endsWith()'+uname.endsWith('wo'));\nconsole.log(`你好世界 ${name}`);\nconsole.log(uname.repeat(4))  // 使用repeat()方法 将字符串重复n次\n// 模板字符串可以调用函数   `$(fn())`\n\n// Set() 方法\n\nconst ol = new Set(['a','b','c' ,'a']) // 将重复的值过滤掉\nconsole.log(ol);\nconsole.log(ol.size);\n// 利用set（）方法 实现数组去重\nconsole.log([...ol]);\n\n// 使用add方法\nlet n = new Set()\nn.add('a').add('b')  // 向set结构中添加值\nn.delete('a')\nconsole.log([...n]);  //将set结构中的值删除\nconsole.log(n.has('a'));  // 使用has方法来判断set结构中是否存在某个值\nn.clear() // 可以将set结构中的值清除\nconsole.log([...n]);  \n```\n{% endfolding %}\n\n\n\n\n","categories":["web","Javascript"]},{"title":"Python+GitHub实现CSDN的自动签到抽奖+网易云签到，并用钉钉机器人通知","url":"/posts/8609/","content":"\n<div class=\"note success icon flat\"><p>使用python+GitHub实现CSDN的自动签到，并用钉钉通知加入自动抽奖</p></div>\n\n## 仓库地址\n- 【[地址](https://github.com/Rr210/qiandao)】\n- 下面代码为**部分代码**，去仓库获取完整代码\n- 加入网易云音乐签到\n\n## 自动签到代码\n\n{% folding green, 查看代码 %}\n```py\nimport requests\nimport os  #加入环境变量\nif __name__ == '__main__':\n    COOKIE = os.environ[\"COOKIE\"]  # 点击签到后在控制台从heard里面找到COOKIE\n    USERNAME = os.environ[\"USERNAME\"]  # 这里是’CSDN‘的用户名，链接后面的\n    DDSECRET = os.environ[\"DDSECRET\"]  # 钉钉通知加签\n    DDPOSTURL = os.environ[\"DDPOSTURL\"]  # 钉钉通知机器人的链接地址\n\nheaders = {\n    'accept': 'application/json, text/plain, */*',\n    'accept-encoding': 'gzip, deflate, br',\n    'accept-language': 'zh-CN,zh;q=0.9,en;q=0.8',\n    'content-length': '246',\n    'content-type': 'application/json;charset=UTF-8',\n    'cookie': COOKIE,\n    'origin': 'https://i.csdn.net',\n    'referer': 'https://i.csdn.net/',\n    'sec-ch-ua': '\"Chromium\";v=\"88\", \"Google Chrome\";v=\"88\", \";Not A Brand\";v=\"99\"',\n    'sec-ch-ua-mobile': '?0',\n    'sec-fetch-dest': 'empty',\n    'sec-fetch-mode': 'cors',\n    'sec-fetch-site': 'same-site',\n    'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36'\n}\n\ndata = {\n    'ip': '',\n    'platform': 'pc-my',\n    'product': 'pc',\n    'user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36',\n    'username': USERNAME,\n    'uuid': '10_10212595300-1608558661367-119405',\n}\n\nr = requests.post(\"https://me.csdn.net/api/LuckyDraw_v2/signIn\",headers=headers,data=data).content.decode(\"unicode_escape\")\nprint(r)  # 输出结果\nimport json\ntimedata = json.loads(r)\n# 将json转化为数组形式\nprint(timedata)\nisSign = timedata['data']['isSigned']\n# print(isSign) #返回签到逻辑值\nt = timedata['data']['msg']\nprint(t)  # 返回签到结果\n\n\n# 钉钉通知模块\nimport time\nimport hmac\nimport hashlib\nimport base64\nimport urllib.parse\nimport requests, json\n\ntimestamp = str(round(time.time() * 1000))\nsecret = DDSECRET\nsecret_enc = secret.encode('utf-8')\nstring_to_sign = '{}\\n{}'.format(timestamp, secret)\nstring_to_sign_enc = string_to_sign.encode('utf-8')\nhmac_code = hmac.new(secret_enc, string_to_sign_enc, digestmod=hashlib.sha256).digest()\nsign = urllib.parse.quote_plus(base64.b64encode(hmac_code))\n# 导入依赖库\nheaders = {'Content-Type': 'application/json'}  # 定义数据类型\n# 截至到&timestamp之前\nwebhook = DDPOSTURL + timestamp + \"&sign=\" + sign\n# 定义要发送的数据\n# \"at\": {\"atMobiles\": \"['\"+ mobile + \"']\"\nif isSign:\n    data = {\n    #定义内容\n    \"msgtype\": \"markdown\",\n     \"markdown\": {\n         \"title\":\"CSDN签到通知\",\n         \"text\": \">CSDN 签到已成功\\n - 签到详情:\" + t + \"\\n⭐项目地址：[https://github.com/Rr210/qiandao](https://github.com/Rr210/qiandao)\"\n     }\n      }\n    res = requests.post(webhook, data=json.dumps(data), headers=headers)   #发送post请求\n    print(res.text)\nelse:\n    data = {\n        # 定义内容\n        \"msgtype\": \"markdown\",\n        \"markdown\": {\n            \"title\": \"CSDN签到通知\",\n            \"text\": \"签到失败\" + '\\n 签到详情' + t + \"\\n项目地址：[https://github.com/Rr210/qiandao](https://github.com/Rr210/qiandao)\"\n        }\n    }\n    res = requests.post(webhook, data=json.dumps(data), headers=headers)  # 发送post请求\n    print(res.text)\n```\n{% endfolding %}\n\n## py加入自动抽奖操作\n\n{% folding green, 查看部分代码 %}\n```py\nimport requests\nimport os  #加入环境变量\nif __name__ == '__main__':\n    COOKIE = os.environ[\"COOKIE\"]  # 点击签到后在控制台从heard里面找到COOKIE\n    USERNAME = os.environ[\"USERNAME\"]  # 这里是’CSDN‘的用户名，链接后面的\n    DDSECRET = os.environ[\"DDSECRET\"]  # 钉钉通知加签\n    DDPOSTURL = os.environ[\"DDPOSTURL\"]  # 钉钉通知机器人的链接地址\n\nheaders = {\n    'accept': 'application/json, text/plain, */*',\n    'accept-encoding': 'gzip, deflate, br',\n    'accept-language': 'zh-CN,zh;q=0.9,en;q=0.8',\n    'content-length': '246',\n    'content-type': 'application/json;charset=UTF-8',\n    'cookie': COOKIE,\n    'origin': 'https://i.csdn.net',\n    'referer': 'https://i.csdn.net/',\n    'sec-ch-ua': '\"Chromium\";v=\"88\", \"Google Chrome\";v=\"88\", \";Not A Brand\";v=\"99\"',\n    'sec-ch-ua-mobile': '?0',\n    'sec-fetch-dest': 'empty',\n    'sec-fetch-mode': 'cors',\n    'sec-fetch-site': 'same-site',\n    'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36'\n}\n\ndata = {\n    'ip': '',\n    'platform': 'pc-my',\n    'product': 'pc',\n    'user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36',\n    'username': USERNAME,\n    'uuid': '10_10212595300-1608558661367-119405',\n}\n\nr = requests.post(\"https://me.csdn.net/api/LuckyDraw_v2/signIn\",headers=headers,data=data).content.decode(\"unicode_escape\")\nprint(r)  # 输出结果\nimport json\ntimedata = json.loads(r)\n# 将json转化为数组形式\nprint(timedata)\nmessage = timedata['message']  # 返回签到的结果\nisSign = timedata['data']['isSigned']\n# print(isSign) #返回签到逻辑值\nt = timedata['data']['msg']\nprint(t)  # 返回签到结果\n# 返回签到天数，如果到了5天执行csdnlucky.py\n\n\n\n# 钉钉通知模块\nimport time\nimport hmac\nimport hashlib\nimport base64\nimport urllib.parse\nimport requests, json\n\ntimestamp = str(round(time.time() * 1000))\nsecret = DDSECRET\nsecret_enc = secret.encode('utf-8')\nstring_to_sign = '{}\\n{}'.format(timestamp, secret)\nstring_to_sign_enc = string_to_sign.encode('utf-8')\nhmac_code = hmac.new(secret_enc, string_to_sign_enc, digestmod=hashlib.sha256).digest()\nsign = urllib.parse.quote_plus(base64.b64encode(hmac_code))\n# 导入依赖库\nheaders = {'Content-Type': 'application/json'}  # 定义数据类型\n# 截至到&timestamp之前\nwebhook = DDPOSTURL + timestamp + \"&sign=\" + sign\n# 定义要发送的数据\n# \"at\": {\"atMobiles\": \"['\"+ mobile + \"']\"\nif message == '成功':\n    data = {\n    #定义内容\n    \"msgtype\": \"markdown\",\n     \"markdown\": {\n         \"title\":\"CSDN签到通知\",\n         \"text\": \">CSDN 签到已成功\\n - 签到详情:\" + t + \"\\n------------⭐项目地址：[https://github.com/Rr210/qiandao](https://github.com/Rr210/qiandao)\"\n     }\n      }\n    res = requests.post(webhook, data=json.dumps(data), headers=headers)   #发送post请求\n    print(res.text)\nelse:\n    data = {\n        # 定义内容\n        \"msgtype\": \"markdown\",\n        \"markdown\": {\n            \"title\": \"CSDN签到通知\",\n            \"text\": \">CSDN 签到失败\\n - 签到详情:\"+ timedata + \"\\n项目地址：[https://github.com/Rr210/qiandao](https://github.com/Rr210/qiandao)\"\n        }\n    }\n    res = requests.post(webhook, data=json.dumps(data), headers=headers)  # 发送post请求\n    print(res.text)\n\n```\n{% endfolding %}\n\n## 使用方法\n\n1. 将以上代码中`headers`和`data`替换成你自己的\n2. 点击这里【[签到地址](https://i.csdn.net/#/user-center/draw)】,打开浏览器调式工具`console`，`F12`或者`ctrl+shift+i`,点击`network`后点击签到控制台会生成新的文件，点击后获得此时的`header`和`data`，`ctrl+c`复制下来\n3. 转换成字典形式，转换方法【[查看方法](https://blog.csdn.net/weixin_44146025/article/details/113249043?spm=1001.2014.3001.5501)】，当然嫌麻烦可以手动修改成字典形式\n\n## Github配置\n\n1. 将你的COOKIE和USERNAME 保存替换成以上样式，记得保存好COOKIE，将COOKIE使用环境变量放到GitHub仓库的secrets里面，如图所示\n2. 修改代码第15行，第31行，第56行，第65行  将自己的信息修改\n{% folding green, 查看图例 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/csdnpyrr.webp)\n{% endfolding %}\n2. 各个参数介绍\n\n|Secrets|参数介绍|\n| :----: | :----: |\n|COOKIE|这个时签到csdn所需的COOKIE，识别用户身份必须获得|\n|USERNAME|你的CSDN的用户名|\n|DDPOSTURL|钉钉群机器人的webhook地址，参考钉钉[官方文档](https://developers.dingtalk.com/document/app/custom-robot-access)|\n|DDSECRET|设置钉钉机器人时的加签密钥|\n| LUCKYCOOLKIE| 执行抽奖时所需的COOKIR，获取方法与签到的cookie相同|\n| WYYCOOKIE| 获取方法相同|\n| WYYCSRFTOKEN| 在控制台获取 `csrf_token` 的值|\n\n3. 设置完成后可以手动执行或者点击`star`⭐\n4. 如图已设置成功\n{% folding green, 查看结果 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/csdn231892391.webp)\n{% endfolding %}\n5. 通知成功\n{% folding green, 查看结果 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/csdn7891231289h.webp)\n{% endfolding %}\n\n## 网易云音乐签到\n- 获取cookie与以上方法一致\n\n{% folding green, 查看图例 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/wyyy7123192.webp)\n{% endfolding %}\n## 设置定时\n\n1. 将`.github`文件下的`workflows`中的`csdn.yml`中的`corn`的属性值修改\n2. 注意时差mg比我们地区快8个小时\n\n\n## 参考\n\n- 【[参考的文章](https://blog.csdn.net/a12355556)】\n\n\n> 业余大佬们勿喷","categories":["技术·教程"]},{"title":"jQuery的知识整理（2）","url":"/posts/55376/","content":"\n<div class=\"note primary icon flat\"><p>jQuery的元素操作，事件处理，委托</p></div>\n\n## 元素操作\n\n1. 创建元素`var li = $('<li></li>')`\n2. 添加元素\n- 内部添加 `$('ul').append(li)`  放到内容的后面， prepend  放到内容的前面\n- 外部添加   `$('ul').before(li)` 放到指定元素的前面，after放到后面，兄弟关系\n3. 删除元素 `$('ul').remove()`zs的方式， `empty`或者`html('')`清空元素内的孩子\n\n## 事件注册/处理\n\n1. 事件处理 `ele.on({mouseenter:function(){},})`,on可以处理一个或多个事件\n2. 相同元素不同处理方法，可以使用`on(' ')`多个事件用逗号隔开\n\n## 事件委托\n\n1. on('方法'，'子元素'， '回调函数'),原理，冒泡处理\n2. on可以给未来动态创建的元素绑定事件\n3. 事件处理`off()` 解绑事件   off('某个事件')解绑某个事件  `off('click','li')`接触事件委托\n4. `one('')`事件处理 只会触发一次\n5. 自动触发方式\n-  `ele.click()`\n- trigger('事件方法')\n- triggerHandler('事件方法')   不会触发元素的默认行为  不会有光标闪烁\n\n## 事件对象\n\n1. 注意有冒泡行为\n2. 拷贝对象$.extend('deep',traget,obj,[objN])  \n3. true深拷贝完全克隆，而且不会覆盖，如果有相同属性会合并；false浅拷贝，把原来复杂数据类型地址老贝给目标对象，拷贝地址，会将原来的属性覆盖\n\n## 多库并存\n\n1. 将`$`改为`jQuery`\n2. 让jquery 释放会$的控制权  比如 `var demo = jQuery.noConflict()`\n\n## TodoList案例\n\n1. 亲兄弟才能使用`$(this).index()`\n2. splice(index,删除几个元素)，数组的删除操作\n3. attr('自定义属性')， 可获取元素的属性值\n4. 原理：输入数据后，首先获取本地的数据库，将输入的值存入本地数据库保存，在进行一系列的渲染\n5. `JSON.parse(data)`方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象\n6. `JSON.stringify()`方法将一个 JavaScript 对象或值转换为 JSON 字符串\n\n{% folding green, 查看实例 %}\n```html\n<style>\n    * {\n        padding: 0;\n        margin: 0;\n        box-sizing: border-box;\n    }\n\n    li {\n        list-style: none;\n    }\n\n    .box {\n        position: relative;\n        width: 600px;\n        height: 440px;\n        margin: 100px auto 10px;\n        background-color: #ccc;\n        border-radius: 10px;\n    }\n\n    ::-webkit-scrollbar {\n        width: 6px;\n        height: 5px;\n    }\n\n    ::-webkit-scrollbar-track {\n        background-color: rgba(50, 57, 61, 0.2);\n        border-radius: 2em;\n    }\n\n    ::-webkit-scrollbar-thumb {\n        background-color: #202b33;\n        background-image: -webkit-linear-gradient(45deg, hsla(0, 0%, 100%, 0.4) 25%, transparent 0, transparent 50%, hsla(0, 0%, 100%, .4) 0, hsla(0, 0%, 100%, .4) 75%, transparent 0, transparent);\n        border-radius: 2em;\n    }\n\n    span {\n        display: block;\n        text-align: center;\n        font-size: 20px;\n        font-weight: 600;\n        color: rgb(9, 12, 11);\n        margin: 5px;\n    }\n\n    .int {\n        margin: 20px auto 0;\n        padding: 10px;\n        display: block;\n        outline: none;\n        overflow: auto;\n        border-radius: 10px;\n    }\n\n    li p {\n        display: inline-block;\n        margin: 0 10px;\n        color: rgb(49, 66, 141);\n        font-size: 15px;\n        font-weight: 600;\n    }\n    ol li,\n    ul li {\n        background-color: rgb(204, 235, 218);\n        border-radius: 5px;\n        padding-left: 10px;\n        margin: 10px 0;\n        border: 2px solid rgb(135, 198, 228);\n    }\n\n    ol li a,\n    ul li a {\n        float: right;\n        text-decoration: none;\n        font-size: 12px;\n        font-weight: 550;\n        color: rgb(33, 16, 49);\n        line-height: 20px;\n        margin-right: 10px;\n    }\n\n    ul,ol {\n        width: 550px;\n        height: 150px;\n        background-color: rgba(80, 226, 202, 0.288);\n        border-radius: 10px;\n        margin: 5px auto 0;\n        padding: 10px;\n        overflow: auto;\n    }\n    h5{\n        margin-left: 27px;\n    }\n</style>\n\n<body>\n    <div class=\"box\">\n        <span>留言区</span>\n        <input type=\"text\" placeholder=\"请输入代办的事件\" class=\"int\">\n        <h5>正在进行中</h5>\n        <ul></ul>\n        <h5>已经完成的事件</h5>\n        <ol></ol>\n    </div>\n    <script>\n        // $(function () {\n        //     $('button').click(function () {\n        //         var li = $('<li></li>');\n        //         li.html($('textarea').val() + '<a href=\"javascript:;\">删除</a>')\n        //         if ($('textarea').val() != '') {\n        //             $('ul').prepend(li);\n        //             li.slideDown();\n        //             $('textarea').val('');\n        //         }\n        //     })\n        $(function () {\n            // todolist案例\n            eload();\n            $('.int').on('keydown', function (event) {\n                if (event.keyCode == 13) {\n                    if ($(this).val() == '') {\n                        alert('请输入内容')\n                    } else {\n                        var local = getData();\n                        // console.log(local);\n                        local.push({ title: $(this).val(), done: false });//追加数组\n                        savedata(local);\n                        eload();\n                        $(this).val('');\n                    }\n                }\n            })\n            $('ol,ul').on('click', 'input', function () {\n                var data = getData();\n                var index = $(this).siblings('a').attr('id');\n                // 修改数组中属性的值\n                data[index].done = $(this).prop('checked');\n                console.log(data);\n                savedata(data);\n                eload();\n            })\n            // 获取本地数据\n            function getData() {\n                var data = localStorage.getItem('todolist');\n                if (data !== null) {\n                    console.log(typeof data);\n                    console.log(typeof JSON.parse(data));\n                    // 方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象\n                    return JSON.parse(data)\n                } else {\n                    return [];\n                }\n            }\n            //保存本地存储\n            function savedata(data) {\n                // 设置本地存储 key，value，// 方法将一个 JavaScript 对象或值转换为 JSON 字符串\n                localStorage.setItem('todolist', JSON.stringify(data));\n                console.log(typeof JSON.stringify(data));\n                console.log(JSON.stringify(data));\n            }\n            // 本地存储渲染加载数据\n            function eload() {\n                var data = getData();\n                console.log(data);\n                // 这个操作为先删除后在进行渲染遍历\n                $('ul,ol').empty();\n                // 遍历数据，i为index，当前i下n为属性\n                $.each(data, function (i, n) {\n                    console.log(n);\n                    if (!n.done) {\n                        $('ul').prepend('<li><input type=\"checkbox\"><p>' + n.title + '</p><a href=\"javascript:;\" id=' + i + '>删除</a></li>').stop().slideDown().show();\n                    } else {\n                        $('ol').prepend('<li><input checked =\"1\" type=\"checkbox\"><p>' + n.title + '</p><a href=\"javascript:;\" id=' + i + '>删除</a></li>').stop().slideDown().show();\n                    }\n                })\n            }\n            // 删除对应的数据\n            $('ul,ol').on('click', 'li a', function () {\n                var data = getData();\n                console.log(data);\n                // 修改数据,查询自定义属性\n                var index = $(this).attr('id');\n                console.log(index);\n                //截取删除，index为删除的位置，后一个为删除的数量\n                data.splice(index, 1);\n                savedata(data);\n                eload();\n            })\n\n        })\n        //     $('ul').on('click','li a',function(){\n        //         $(this).parent('li').slideUp(function(){\n        //             $(this).remove();\n        //         }) \n        //     })\n        // })\n    </script>\n</body>\n```\n{% endfolding %}\n\n{% folding green, 查看图例 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/localcuncu.gif)\n{% endfolding %}\n\n## jQuery的尺寸\n\n1. `width()/height()`  获取元素的宽度和高度，只算width和height\n2. `innerWidth()/height()`  获取元素的width和padding的大小\n3. `outerWidth()/Height()`  包含padding，border\n4. `outerWidth(true)`  包含padding，border,margin\n\n## jQuery的位置\n\n1. `offset()` 方法 设置或返回距离文档的距离，不受父级的影响，返回的是`对象`object`{}`left/top，可以获取设置\n2. `position()`  获取元素的偏移量,先对于父级，只能获取不能设置\n3. `scrollTop()/Left`   $(window).scroll(function(){})\n4. `animate({scrollTop:0})`,做动画效果，不能是文档，让`body，html`做动画效果\n\n<span class=\"inline-tag\" style=\"--Color:#881B12\">页面滚动楼层案例</span>\n\n1. 使用排他思想，$(this).index() 获取当前索引号\n2. 使用节流阀控制滑动和点击时按钮抖动事件\n3. 使用链式编程，使用遍历`each(function(i,ele){})`方法\n4. 这里搭配节流阀，当点击按钮后flag=false，关闭页面滑动使得按钮添加类，等动画执行完成后在使得flag=true 添加一个回调函数\n\n{% folding green, 查看案例 %}\n```\n<style>\n    * {\n        margin: 0;\n        padding: 0;\n        box-sizing: border-box;\n    }\n\n    .box {\n        width: 80%;\n        height: 2000px;\n        display: flex;\n        margin: 0 auto;\n        flex-direction: column;\n    }\n    \n    .box li {\n        flex: 1;\n        margin: 10px;\n        background-color: #ccc;\n        list-style: none;\n        border-radius: 10px;\n    }\n    \n    ol {\n        position: fixed;\n        top: 30%;\n        left: 0;\n        width: 50px;\n        display: flex;\n        flex-direction: column;\n    }\n    \n    ol li {\n        display: none;\n        flex: 1;\n        list-style: none;\n        text-align: center;\n        margin: 2px;\n        background-color: #ccc;\n        border-radius: 5px;\n    }\n    \n    .box2 {\n        width: 20%;\n        height: 600px;\n        margin: 100px;\n        background-color: rgb(166, 224, 158);\n        margin: 0 auto;\n    }\n    \n    li {\n        cursor: pointer;\n    }\n    \n    .current {\n        background-color: rgb(241, 117, 117);\n    }\n</style>\n\n<body>\n    <div class=\"box2\"></div>\n    <div class=\"box\">\n        <li>1</li>\n        <li>2</li>\n        <li>3</li>\n        <li>4</li>\n    </div>\n    <ol>\n        <li class=\"current\">1</li>\n        <li>2</li>\n        <li>3</li>\n        <li>4</li>\n    </ol>\n    <script>\n        $(function () {\n            // 当页面滑动到指定位置时，左侧的楼层显示出来\n            // 封装页面刷新后不滑动bug\n            // 页面自主滑动和点击按钮左侧按钮会出现抖动bug，这时候需要添加一个节流阀来控制\n            var flag = true;\n            scro();\n            function scro(){\n                if ($(document).scrollTop() > $('.box').offset().top) {\n                    $('ol li').fadeIn();\n                }\n                else {\n                    $('ol li').stop().fadeOut();\n                }\n            }\n            $(window).scroll(function () {\n                console.log($(document).scrollTop());\n                scro();\n                // 遍历大板块使得板块变化，左侧的楼层同步变化\n                if(flag){\n                    $('.box li').each(function(i,ele){\n                    if($(document).scrollTop()>=$(ele).offset().top){\n                        console.log(i);\n                        $('ol li').eq(i).addClass('current').siblings().removeClass();\n                    }\n                })\n                }\n            })\n            // 点击楼层后使楼层切换到该位置\n            $('ol li').on('click', function () {\n                flag = false;\n                $(this).index();\n                var boxH = $('.box li').eq($(this).index()).offset().top;\n                // 这里搭配节流阀，当点击按钮后flag=false，关闭页面滑动使得按钮添加类，等动画执行完成后在使得flag=true 添加一个回调函数\n                $('body,html').scroll().animate({\n                    scrollTop: boxH\n                },function(){\n                    flag = true;\n                })\n                // 点击按钮后将背景颜色替换\n                $(this).addClass('current').siblings().removeClass();\n            })\n\n        })\n    </script>\n</body>\n```\n{% endfolding %}","categories":["web","JQuery"]},{"title":"jQuery的知识总结（1）","url":"/posts/47494/","content":"\n<div class=\"snote bug\"><p>jQuery的基础知识，常用的API</p></div>\n\n## 什么是jQuery\n\n1. jQuery是一个JavaScript函数库。jQuery是一个轻量级的\"写的少，做的多\"的JavaScript库。\n2. jQuery库包含以下功能：\n- HTML 元素选取\n- HTML 元素操作\n- CSS 操作\n- HTML 事件函数\n- JavaScript 特效和动画\n- HTML DOM 遍历和修改\n- AJAX\n- Utilities\n`<script src=\"https://cdn.jsdelivr.net/gh/Rr210/hexofixed@v0.47/js/jquery-3.5.1.min.js\"></script>`\n\n## jQuery对象\n\n1. 等待页面加载完毕` $(document).ready(function(){})`或者`$(function(){})`\n2. `$`是jQuery的别称,dollar符号，顶级对象\n3. 原生jsDOM对象，jQuery对象`$()`里面不能使用原生属性和方法\n\n## 相互转化\n\n1. DOM对象转化为jQuery对象，`$(obj)`\n2. jQuery对象转化为DOM对象 `$('div')[index]`  或者`$('div').get(index)`\n\n## jQuery API\n\n1. 选择器  `$('')`  与css获取一致\n2. 隐式迭代 `$('').css('','')`(伪数组形式存储)\n\n### 筛选选择器\n\n1. 筛选元素的方法-`first/last/eq(index)/odd/even`\n```js\n        $(function(){\n            $('ul li:first').css('color','red'); //获取第一个元素\n            $('ul li:last').css('fontSize','20px');//获取最后一个\n            $('ul li:eq(4)').css('backgroundColor','#ccc');//获取指定元素\n            $('ul li:odd').css('textShadow','1px 2px 3px #ccc'); //获取偶数元素\n            $('ul li:even').css('textIndent','10px');//获取奇数元素\n            $('ul').css('listStyle','none')\n        })\n```\n\n### 筛选方法\n\n1. `parent()`,最近一级的父代\n2. `children()`亲儿子\n3. `find()`  包括儿子和孙子\n4. `$().mouseover/mouseout`\n5. `$(this)`当前元素，`this`不要加引号\n6. 兄弟元素 `$().siblings`,除了自身的所有元素\n7. `nextAll([])`,查找元素之后所有的同辈元素，`prevAll([expr])`查找之前的所有同辈元素\n8. `hasClass('类名')`, 检查当前元素是否含有某个特定的类，如果有，返回true\n9. `eq(index)`或者使用选择器`$(li:eq(index))`\n10. `partent()` `children()`` find()`` eq()`\n11. `$(this).index()`得到当前元素的索引号\n\n\n{% folding green, 查看案例 %}\n```html\n\n<style>\n    *{\n    padding: 0;\n    margin: 0;\n}\nsection{\n    width: 600px;\n    height: 200px;\n    background-color: #ccc;\n    margin: 100px auto;\n    display: flex;\n    overflow: hidden;\n    border-radius: 10px;\n    border: 1px solid rgb(78, 177, 202);\n}\nul{\n    flex:1;\n    display: flex;\n    flex-direction: column;\n}\nul li{\n    flex: 1;\n    border-bottom: 2px solid rgb(194, 150, 83);\n    text-align: center;\n    line-height: 50px;\n}\nli{\n    list-style: none;\n}\n.content{\n    flex:5\n}\n.content img {\n    width: 100%;\n    vertical-align: middle;\n}\n</style>\n<body>\n    <section>\n    <ul>\n        <li>你好世界</li>\n        <li>你好世界</li>\n        <li>你好世界</li>\n        <li>你好世界</li>\n    </ul>\n    <div class=\"content\">\n        <li><img src=\"https://cdn.jsdelivr.net/gh/Fuukei/WebP_API/PC/web-illust_66413382_20171223_233200.webp\" alt=\"\"></li>\n        <li><img src=\"https://cdn.jsdelivr.net/gh/Fuukei/WebP_API/PC/web-illust_71658260_20181119_230056.webp\" alt=\"\"></li>\n        <li><img src=\"https://tva1.sinaimg.cn/large/a15b4afely1fnt9605xzwj21hc0u07ld.jpg\" alt=\"\"></li>\n        <li><img src=\"https://cdn.jsdelivr.net/gh/Fuukei/WebP_API/PC/web-illust_69810542_20180804_165122.webp\" alt=\"\"></li>\n    </div>\n</section>\n<script>\n    $(function(){\n    $('ul li').eq(3).css('border-bottom','none');\n    $('.content li').eq(0).siblings().hide();\n    $('ul li').mouseover(function(){\n        var index = $(this).index();\n        $('.content li').eq(index).show();\n        $('.content li').eq(index).siblings().hide();\n    })\n})\n</script>\n```\n{% endfolding %}\n\n### jQuery获取\n\n{% folding green, 查看答案 %}\n\n- jQuery.parent(expr)，找父亲节点，可以传入expr进行过滤，比如$(\"span\").parent()或者$(\"span\").parent(\".class\")\n- jQuery.parents(expr)，类似于jQuery.parents(expr),但是是查找所有祖先元素，不限于父元素\n- jQuery.children(expr)，返回所有子节点，这个方法只会返回直接的孩子节点，不会返回所有的子孙节点\n- jQuery.contents()，返回下面的所有内容，包括节点和文本。这个方法和children()的区别就在于，包括空白文本，也会被作为一个jQuery对象返回，children()则只会返回节点\n- jQuery.prev()，返回上一个兄弟节点，不是所有的兄弟节点\n- jQuery.prevAll()，返回所有之前的兄弟节点\n- jQuery.next()，返回下一个兄弟节点，不是所有的兄弟节点\n- jQuery.nextAll()，返回所有之后的兄弟节点\n- jQuery.siblings()，返回兄弟姐妹节点，不分前后\n- jQuery.find(expr)，跟jQuery.filter(expr)完全不一样：\n- jQuery.filter()，是从初始的jQuery对象集合中筛选出一部分，而\n- jQuery.find()，的返回结果，不会有初始集合中的内容，比如$(\"p\").find(\"span\")，是从<p>元素开始找`<span>`，等同于`$(\"p span\")`\n{% endfolding %}\n\n### 操作方法\n\n1. 属性名一定要加引号，数值不需要加引号\n2. 符合属性，用`,`隔开，并用驼峰名法`.css({,})`\n3. 设置类样式 \n- 添加类`addClass('不需要加.')`\n- 删除类`removeClass('类名')\n- 切换类`toggleClass('类名')`\n4. 链式操作\n\n### jQuery效果\n\n<span class=\"inline-tag\" style=\"--Color:#881B12\">显示隐藏</span>\n1. show()  hide() toggle()   显示  隐藏 切换\n2. show([speed,[easeing],[fn]])\n\n<span class=\"inline-tag\" style=\"--Color:#881B12\">滑动</span>\n1. slideDown()   向下滑动\n2. slideUp()   向上滑动\n3. slideToggle()  \n4. hover（over，out） 事件切换\n5. 包括鼠标经过离开的符合写法\n6. 只写一个参数 使用`sildeToggle()`，  使用stop() 结束上一次动画\n\n\n<span class=\"inline-tag\" style=\"--Color:#881B12\">淡入淡出</span>\n1. `fadeIn()` 淡入效果\n2. `fadeOut()` 淡出效果\n3. `fadeToggle()` 淡入淡出切换\n4. `fadeTo('[speed],opacity,[easeing],[fn]')`\n\n<span class=\"inline-tag\" style=\"--Color:#881B12\">自定义动画</span>\n1. animate(params,[speed])\n2. params 以对象形式传递{ }，属性名可以不带引号，复合属性使用驼峰命名法\n\n{% folding green, 手风琴案例 %}\n```html\n<style>\n    *{\n        padding: 0;\n        margin: 0;\n        box-sizing: border-box;\n    }\n    .box{\n        width: 950px;\n        margin: 100px auto;\n        height: 100px;\n        background-color: rgb(213, 233, 125);\n    }\n    ul {\n        width: 1000px;\n        height: 100%;\n        list-style: none;\n        margin: 0;\n        padding: 0;\n    }\n    li{\n        position: relative;\n        float: left;\n        width: 100px;\n        height: 100px;\n        margin: 0;\n        margin-right: 20px;\n        border-radius: 10px;\n        overflow: hidden;\n    }\n    li .small{\n        position: absolute;\n        width: 100px;\n        height: 100px;\n        top:0;\n        z-index: 100;\n    }\n    li .big{\n        display: none;\n        width: 224px;\n        height: 100%;\n    }\n    ul li:nth-child(1){\n        width: 224px;\n    }\n    ul li:nth-child(1) .small{\n        display: none;\n    }\n    ul li:nth-child(1) .big{\n        display: block;\n    }\n</style>\n\n<body>\n    <div class=\"box\">\n        <ul>\n            <li><img src=\"https://cdn.jsdelivr.net/gh/Rr210/image@master/admin/qqavatar.jpeg\" alt=\"\" class=\"small\"><img src=\"https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/161211-1552378331dafb.webp\" alt=\"\" class=\"big\"></li>\n            <li><img src=\"https://cdn.jsdelivr.net/gh/Rr210/image@master/admin/qqavatar.jpeg\" alt=\"\" class=\"small\"><img src=\"https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/161211-1552378331dafb.webp\" alt=\"\" class=\"big\"></li>\n            <li><img src=\"https://cdn.jsdelivr.net/gh/Rr210/image@master/admin/qqavatar.jpeg\" alt=\"\" class=\"small\"><img src=\"https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/161211-1552378331dafb.webp\" alt=\"\" class=\"big\"></li>\n            <li><img src=\"https://cdn.jsdelivr.net/gh/Rr210/image@master/admin/qqavatar.jpeg\" alt=\"\" class=\"small\"><img src=\"https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/161211-1552378331dafb.webp\" alt=\"\" class=\"big\"></li>\n            <li><img src=\"https://cdn.jsdelivr.net/gh/Rr210/image@master/admin/qqavatar.jpeg\" alt=\"\" class=\"small\"><img src=\"https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/161211-1552378331dafb.webp\" alt=\"\" class=\"big\"></li>\n            <li><img src=\"https://cdn.jsdelivr.net/gh/Rr210/image@master/admin/qqavatar.jpeg\" alt=\"\" class=\"small\"><img src=\"https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/161211-1552378331dafb.webp\" alt=\"\" class=\"big\"></li>\n            <li><img src=\"https://cdn.jsdelivr.net/gh/Rr210/image@master/admin/qqavatar.jpeg\" alt=\"\" class=\"small\"><img src=\"https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/161211-1552378331dafb.webp\" alt=\"\" class=\"big\"></li>\n        </ul>\n    </div>\n    <script>\n        $(function(){\n            $('.box').css('borderRadius',10)\n            $('.box ul li').mouseenter(function(){\n                $(this).stop().animate({\n                    width:224\n                },200).children('.small').stop().fadeOut().siblings('.big').stop().fadeIn();\n               $(this).siblings('li').stop().animate({\n                    width: 100\n                },200).children('.big').stop().fadeOut().siblings().stop().fadeIn();\n            })\n        })\n    </script>\n```\n{% endfolding %}\n\n{% folding green, 查看案例 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/shoufenq.gif)\n{% endfolding %}\n\n### prop() 属性值\n\n1. `element.prop('属性名')`  获得固有属性值\n2. `prop（'属性名','属性值')`\n\n### attr()\n\n1. `attr('属性名')`元素的自定义属性\n2. 设置和prop方法一致\n\n### 数据缓存\n\n1. `data('key','value')`存放在元素的内存里面\n2. 获取的时候(`data('key')`)\n3. 或者H5自定义属性，不需要加`data-`,而且返回的是数字型\n\n{% folding green, 全选prop()案例 %}\n```html\n<body>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n        body{\n            font-size: 13px;\n        }\n        table{\n            text-align: center;\n            margin: 100px auto;\n            border-radius: 10px;\n            overflow: hidden;\n        }\n        thead{\n            background-color: #008dd0;\n        }\n    </style>\n    \n    <body>\n        <table width=\"300px\" border=\"1\" cellspacing=\"0\">\n            <thead>\n                <tr>\n                    <th><label for=\"all\">全选<input type=\"checkbox\" id=\"all\"></label></th>\n                    <th>hello</th>\n                    <th>world</th>\n                </tr>\n            </thead>\n            <tbody>\n                <tr>\n                    <td><input type=\"checkbox\"></td>\n                    <td>你好世界</td>\n                    <td>你好世界</td>\n                </tr>\n                <tr>\n                    <td><input type=\"checkbox\"></td>\n                    <td>你好世界</td>\n                    <td>你好世界</td>\n                </tr>\n                <tr>\n                    <td><input type=\"checkbox\"></td>\n                    <td>你好世界</td>\n                    <td>你好世界</td>\n                </tr>\n                <tr>\n                    <td><input type=\"checkbox\"></td>\n                    <td>你好世界</td>\n                    <td>你好世界</td>\n                </tr>\n            </tbody>\n    \n        </table>\n        <script>\n            $(function(){\n                $('#all').change(function(){\n                    $('td input').prop('checked',$(this).prop('checked'))\n                    console.log($(this).prop('checked'));\n                })\n                $('td input').attr('data-index',1);\n                console.log($('td input').attr('data-index'));\n                $('td input').change(function(){\n                    console.log($(this).prop('checked')); \n                    if($('td input:checked').length == $('td input').length){\n                        $('#all').prop('checked',true);\n                    }else{\n                        $('#all').prop('checked',false);\n                    }\n                })\n              \n            })\n\n            // var main = document.getElementById('all');\n            // var input = document.querySelector('tbody').getElementsByTagName('input');\n            // // 当点击全选按钮时，下方的选框同步\n            // main.onclick = function () {\n            //     console.log(this.checked);\n            //     for (var i = 0; i < input.length; i++) {\n            //         input[i].checked = this.checked;\n            //     }\n            // }\n            // // 当去除下方选框，或者全部将input选框点击或取消时，全选按钮同步发生改变\n            // for (var i = 0; i <= input.length - 1; i++) {\n            //     input[i].onclick = function () {\n            //         var flag = true;\n            //         for (var i = 0; i <= input.length - 1; i++) {\n            //             if (!input[i].checked) {\n            //                 flag = false;\n            //             }                   \n            //         } \n            //         main.checked = flag;\n            //     }\n            // }\n    \n        </script>\n</body>\n```\n{% endfolding %}\n\n### 获取内容\n\n1. `html()` 带有标签\n2. `text()` 只获取文本\n3. 表单中的值 `val()`\n4. 获取指定的祖先元素  `$(this).partents('类名')`，\n5. `(n*n).toFixed(2)`保留两位小数\n\n## 元素操作\n\n1. 遍历元素  `$('类').each(回调函数function(index,domEle))`可以自己命名\n2. `$.each($('类')`，`function(index,domELe))`,遍历数组\n\n{% folding green, 购物车经典案例 %}\n```js\n$(function () {\n    $('#all').change(function () {\n        $('td .da').prop('checked', $(this).prop('checked'))\n        // console.log($(this).prop('checked'));\n    })\n    $('td .da').attr('data-index', 1);\n    // console.log($('td .da').attr('data-index'));\n    $('td .da').change(function () {\n        // console.log($(this).prop('checked'));\n        console.log($('td .da').length / 2);\n        if ($('td .da:checked').length == $('td .da').length) {\n            $('#all').prop('checked', true);\n        } else {\n            $('#all').prop('checked', false);\n        }\n    })\n    // 购物车🚗增加案例\n    $('.box .adds').click(function () {\n        var n = $(this).siblings('#nums').val();\n        n++;\n        // console.log($(this).siblings('#nums').val(n));\n        $(this).siblings('#nums').val(n);\n        // 计算小计金额\n        var p = $(this).parents('td').next('.tup').text().substr(1);\n        // console.log($(this).parents('td').eq(2).text('￥' + (p * n).toFixed(2)));\n        $(this).parents('td').next('.tup').next('.xj').text('￥' + (p * n).toFixed(2));\n        getSum();\n    })\n    $('.box .subs').click(function () {\n        var n = $(this).siblings('#nums').val();\n        if (n <= 1) {\n            return false;\n        }\n        n--;\n        // console.log($(this).siblings('#nums').val(n));\n        $(this).siblings('#nums').val(n);\n        // 计算小计金额\n        var p = $(this).parents('td').next('.tup').text().substr(1);\n        $(this).parents('td').next('.tup').next('.xj').text('￥' + (p * n).toFixed(2));\n        getSum();\n    })\n    // 当文本框中的数量发生变化时，小计同步变化\n    $('#nums').change(function () {\n        console.log($(this).parents('td').next().text().substr(1));\n        var con = $(this).val();\n        console.log($(this).val());\n        var p = $(this).parents('td').next().text().substr(1);\n        $(this).parents('td').next().next().html('￥' + (p * con).toFixed(2));\n        if ($(this).val() == 1) {\n            $(this).parents('td').next().next().html() = $(this).parents('td').next().text()\n        }\n        getSum();\n    })\n    // 计算总计数量\n    getSum();\n    function getSum() {\n        var count = 0;\n        var money = 0;\n        $('td #nums').each(function(n,ele){\n            count += parseInt($(ele).val());\n        })\n        $('.xj').each(function(n,ele){\n            money += parseFloat($(ele).text().substr(1));\n        })\n        $('.count').text(count);\n        $('.money').text(money.toFixed(2));\n}\n})\n```\n{% endfolding %}\n\n{% folding green, 查看效果 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/shoppingaa.gif)\n{% endfolding %}","categories":["web","JQuery"]},{"title":"Javascript的知识总结（15）","url":"/posts/644/","content":"\n\n<div class=\"snote bug\"><p>网页轮播图</p></div>\n\n## 网页轮播图\n\n1. 核心原理：使用动画函数，点击小圆圈，使用小圆圈的索引号来判断图片移动的距离\n2. 使用getAttribute 通过自定义属性来记录小圈圈的索引号\n3. 无缝滚动：克隆第一张，实现无缝跳转，克隆第一个节点cloneNode(),没有true浅克隆\n\n{% folding green, 查看案例 %}\n```js\nwindow.addEventListener('DOMContentLoaded', function () {\n    var w = document.querySelectorAll('.w');\n    var mains = document.getElementsByTagName('main');\n    var lunbo = document.querySelector('.lunbo');\n    var focus = document.querySelector('.focus');\n    var ul = focus.querySelector('ul');\n    var ulli = ul.querySelector('li')\n    var cul = lunbo.querySelector('ul');\n    var focuswidth = focus.offsetWidth;\n    var circle = 0;\n    var num = 0;\n    // console.log(ul.children.length);\n    // console.log(lunbo);\n    // console.log(w);\n    // console.log(mains);\n    onmouseover = function () {\n        lunbo.children[0].style.display = 'block'\n        lunbo.children[1].style.display = 'block'\n    }\n    onmouseout = function () {\n        lunbo.children[0].style.display = 'none'\n        lunbo.children[1].style.display = 'none'\n    }\n    // 动态生成图片\n    for (var i = 0; i < ul.children.length; i++) {\n        var cli = document.createElement('li');\n        cli.setAttribute('index', i);\n        cul.appendChild(cli);\n        // 使用排他思想,先全部清空再给当前的xiaoli设置元素类型\n        cli.addEventListener('click', function () {\n            for (var i = 0; i < ul.children.length - 1; i++) {\n                cul.children[i].className = '';\n                console.log(cul.children[i]);\n            }\n            this.className = 'current';\n            var index = this.getAttribute('index');\n            // 点击后获取小圈圈当前的索引值，并将值赋值给控制小圈圈的circle和控制图片所在位置的num\n            num = circle = index; \n\n            // console.log(index);\n            // console.log(focuswidth);\n            animate(ul, -index * focuswidth, 1)\n        })\n    }\n    cul.children[0].className = 'current';\n    var firstimg = ulli.cloneNode(true);\n    ul.append(firstimg);\n    // 点击右侧按钮图片移动一张\n    lunbo.children[1].addEventListener('click', function () {\n        // 生成第一张图片克隆\n        num++;\n        // 通过缓动动画来控制图片的移动\n        animate(ul, -num * focuswidth, 15);\n        if (num == ul.children.length - 1) {\n            ul.style.left = 0;\n            num = 0;\n        }\n        circle++;\n        if (circle == cul.children.length) {\n            circle = 0;\n            cul.children[cul.children.length - 1].className = '';\n            cul.children[0].className = 'current';\n        } else {\n            for (var i = 0; i <= cul.children.length - 1; i++) {\n                cul.children[i].className = ''\n            }\n            cul.children[circle].className = 'current'\n            // 小圆圈跟随变\n        }\n    })\n\n    // 左侧按钮\n    // 点击左侧按钮图片移动一张\n    lunbo.children[0].addEventListener('click', function () {\n        // 生成第一张图片克隆\n        if (num == 0) {\n            num = ul.children.length - 1;\n            ul.style.left = -num * focuswidth + 'px';\n        }\n        num--;\n        animate(ul, -num * focuswidth, 15);\n        // if (num == ul.children.length - 1) {\n        //     ul.style.left = 0;\n        //     num = 0;\n        // }\n        circle--;\n        if (circle < 0) {\n            circle = cul.children.length - 1;\n            cul.children[circle].className = 'current';\n            cul.children[0].className = '';\n        } else {\n            for (var i = 0; i <= cul.children.length - 1; i++) {\n                cul.children[i].className = ''\n            }\n            cul.children[circle].className = 'current'\n            // 小圆圈跟随变\n        }\n    })\n\n})\n```\n{% endfolding %}\n\n## 自动播放\n\n1. 定时器，手动调用事件\n2. 事件.click\n\n{% folding green, 查看实例 %}\n```js\nvar timerr = setInterval(function(){\n    lunbo.children[1].click();\n},2000)\n```\n{% endfolding %} \n\n## 节流阀\n\n> 使用回调函数，在点击事件后添加一个flag=true，来控制速率\n\n{% folding green, 查看实例 %}\n```js\nvar flag = true;\nobj.onclick = function(){\nflag=false;\nanimate(obj,target,function(){\nflag = true;\n})\n}\n```\n{% endfolding %}\n\n## 返回顶部案例\n\n1. 方法一：使html/body元素滚轮距离顶部为0\n{% folding green, 查看实例 %}\n```js\n        btn.addEventListener('click',function(){\n            document.body.scrollTop = document.documentElement.scrollTop = 0;\n        })\n```\n{% endfolding %}\n2. 方法二: 控制window滚轮的位置\n{% folding green, 查看实例 %}\n```js\n        btn.addEventListener('click',function(){\n            window.scroll(0,0);\n        })\n```\n{% endfolding %}\n3. 方法三：引入缓动动画函数\n{% folding green, 查看实例 %}\n```js\n        // 第三种 引入缓动函数\n        btn.addEventListener('click',function(){\n            animateY(window,0,15)\n        })\n```\n{% endfolding %}\n\n## 移动端事件\n\n1. 触屏事件，touchstart/touchmove/touched\n2. 触摸事件TouchEvent\n3. // touches正在触摸屏幕的所有手指的列表// targetTouches  在触摸当前元素DOM的手指列表// changedTouches 检测手指列表，手指状态变化// 当手指离开屏幕时 touches和targetTouches列表没有，只能拿到changedTouches\n4. 拖动元素三部曲：\n- 触摸元素touchstart：获取手指的初始位置，同时获得盒子原来的位置\n- 移动手指 touchmove 计算手指滑动距离，并且移动盒子，手指移动的距离加上盒子原来的位置\n- 离开手指 touchend\n\n{% folding green, 查看实例 %}\n```html\n    <style>\n        div{\n            position: absolute;\n            width: 100px;\n            height: 200px;\n            background-color: rgb(24, 153, 212);\n        }\n    </style>\n    <div>\n    \n    </div>\n    <script>\n        var startX = 0;\n        var startY = 0;\n        var x = 0;\n        var y = 0;\n        var div =document.querySelector('div')\n        div.addEventListener('touchstart',function(e){\n            console.log('我开始模拟了');\n            startX = e.targetTouches[0].pageX;\n            startY = e.targetTouches[0].pageY;\n            x = this.offsetLeft;\n            y = this.offsetTop;\n            // touches正在触摸屏幕的所有手指的列表\n            // targetTouches  在触摸当前元素DOM的手指列表\n            // changedTouches 检测手指列表，手指状态变化\n            // 当手指离开屏幕时 touches和targetTouches列表没有，只能拿到changedTouches\n        })\n        div.addEventListener('touchmove',function(e){\n            var moveX = e.targetTouches[0].pageX - startX;\n            var moveY = e.targetTouches[0].pageY -startY;\n            this.style.left = x + moveX +'px';            \n            this.style.top = y + moveY +'px';  \n            e.preventDefault();          \n        })\n```\n{% endfolding %}\n\n## 移动端无缝滚动\n\n1. 添加监听事件，加入判断事件\n2. `transitionend`,在去掉过渡效果\n\n{% folding green, 查看实例 %}\n```js\nwindow.addEventListener('load', function () {\n    var focus = document.querySelector('.focus');\n    var foli = focus.querySelectorAll('li');\n    var ul = focus.children[0];\n    var wid = focus.offsetWidth;\n    var ol = focus.querySelector('ol');\n    console.log(foli.length);\n    var index = 0;\n    var timer = setInterval(function () {\n        index++;\n        var indexw = -index * wid;\n        ul.style.transition = 'all .4s';\n        ul.style.transform = 'translateX(' + indexw + 'px)';\n    }, 2000)\n    ul.addEventListener('transitionend', function () {\n        console.log('1');\n        if (index == 3) {\n            index = 0;\n            console.log(index);\n            ul.style.transition = 'none'\n            var indexw = -index * wid;\n            ul.style.transform = 'translateX(' + indexw + 'px)';\n        } else if (index < 0) {\n            index = 2;\n            ul.style.transition = 'none'\n            var indexw = -index * wid;\n            ul.style.transform = 'translateX(' + indexw + 'px)';\n        }\n        ol.querySelector('.current').classList.remove('current');\n        ol.children[index].classList.add('current');\n    })\n    var startx = 0;\n    var movex = 0;\n    ul.addEventListener('touchstart', function (e) {\n        var startx = e.targetTouches[0].pageX;\n        console.log(startx);\n        clearInterval(timer);\n    })\n    ul.addEventListener('touchmove', function (e) {\n        var movex = e.targetTouches[0].pageX - startx;\n        var translatex = movex + index * -wid;\n        console.log(movex);\n        ul.style.transition = 'none';\n        ul.style.transform = 'translateX(' + translatex + 'px)';\n    })\n    ul.addEventListener('touchend', function (e) {\n        if (Math.abs(movex) > 50) {\n            if (movex > 0) {\n                index--;\n            }\n            else {\n                index++;\n            }\n            var translatex = -index * wid;\n            ul.style.transition = 'all .4s';\n            ul.style.transform = 'translateX(' + translatex + 'px)';\n        }else{\n            var translatex = -index * wid;\n            ul.style.transition = 'all .4s';\n            ul.style.transform = 'translateX(' + translatex + 'px)';\n        }\n    })\n})\n```\n{% endfolding %}\n\n\n## classList属性\n\n1. `classList`属性,追加类名，和ClassName对比，不需要加`.`,移除remove，格式`div.classLest.add/remove`\n2. 切换类`document.body.classList.toggle('')`\n\n## click延时解决方案\n\n1. 禁止页面的缩放\n2. 封装函数，解决300ms延时情况\n3. 引入js插件 `fastclick`，在GitHub仓库内\n\n{% folding green, 查看代码 %}\n```js\n//https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/fastclick.js\n```\n{% endfolding %}\n\n## 使用js插件/框架\n\n1. swiper的插件CDN\n2. Touchslide插件\n3. zy.media.js插件，页面适配框架适配不同浏览器\n4. 框架：bootstrap（依赖JQ），vue，react，zepto\n\n## 本地存储\n\n1. sessionStorage，生命周期为`关闭浏览器窗口`\n- 格式 sessionStorage.setItem(key,value),存储\n- sessionStorage.getItem(key)  获取\n- sessionStorage.removeItem(key) 删除数据\n- sessionStorage.clear();  删除全部数据\n2. localStroage,生命周期永久生效，使用方法雷同\n\n{% folding green, 查看实例 %}\n```html\n    <input type=\"text\" name=\"\" id=\"inp\"><input type=\"checkbox\" name=\"\" id=\"inp1\">记住用户\n    <script>\n        var inp = document.querySelector('#inp');\n        var inp1 = document.querySelector('#inp1');\n        if(localStorage.getItem('inp')){\n            inp.value = localStorage.getItem('inp');\n            inp1.checked = true;\n        }\n        inp1.addEventListener('change',function(){\n            if(this.checked && inp.value != ''){\n                localStorage.setItem('inp',inp.value)\n                console.log(inp.value);\n            }\n            else{\n                localStorage.removeItem('inp')\n            }\n        })\n    </script>\n```\n{% endfolding %}","categories":["web","Javascript"]},{"title":"JavaScript的知识总结（14）","url":"/posts/50821/","content":"\n<div class=\"tip ban font5 fas fa-ban faa-horizontal animated\"><p>网页特效，缓动动画函数封装</p><p></p></div>\n\n## 元素偏移量\n\n1. `offset`Top/Left,动态的获取位置，具有定位的父元素的距离，如果没有则以body为准\n2. `offsetWidth/Height`可以获取元素的大小 包括padding，border\n3. `offsetParent`返回带有定位的父亲，否则是body，`parentNode`返回最近一级 的父亲\n\n## offset和style\n\n1. style只能得到行内样式表中的样式值，并且获取的属性值是有单位的\n2. 获取元素使用offset更合适，更改样式使用style\n\n{% folding green, 鼠标点击盒子后获取坐标 %}\n```html\n    <script>\n        var box =document.querySelector('.box');\n        box.addEventListener('click',function(e){\n            var x = e.pageX - this.offsetLeft;\n            console.log(x);\n        })\n    </script>\n```\n{% endfolding %}\n\n## client系列\n\n1. `clientWidth`返回自身的宽度不包含边框，包含padding\n\n## 立即执行函数\n\n1. 立即执行函数(function() {})()  或者(function(){}()),\n2. (function() {})()  第二个小括号可以看作调用函数\n3. (function(){}()), 多个立即执行函数要加`;`\n4. 创建一个独立作用域，避免了命名冲突\n\n{% folding green, 放大镜效果 %}\n```html\n<style>\n    .box {\n        position: relative;\n        margin-top: 200px;\n        margin-left: 100px;\n        top: 0;\n        left: 0;\n        width: 400px;\n        height: 400px;\n        background-color: rgb(163, 155, 155);\n        border-radius: 10px;\n        cursor: move;\n    }\n\n    .box .imgs {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 64%;\n        margin-left: 74px;\n        margin-top: 3px;\n        vertical-align: middle;\n    }\n\n    .mask {\n        display: none;\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100px;\n        height: 100px;\n        border-radius: .625rem;\n        background-color: rgb(80, 29, 45);\n        opacity: .5;\n    }\n\n    .big {\n        display: none;\n        position: relative;\n        width: 600px;\n        height: 600px;\n        top: 0;\n        left: 410px;\n        border-radius: .625rem;\n        overflow: hidden;\n    }\n\n    .big .imgc {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 300px;\n        margin-left: 100px;\n    }\n</style>\n\n<body>\n    <div class=\"box\">\n        <img class=\"imgs\" src=\"https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/2ae5b713777378e1.jpg\"\n            alt=\"\">\n        <div class=\"mask\"></div>\n        <div class=\"big\"><img class=\"imgc\"\n                src=\"https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/2ae5b713777378e1.jpg\" alt=\"\">\n        </div>\n    </div>\n    <script>\n        var box = document.querySelector('.box');\n        var img = box.querySelector('.imgs');\n        var mask = box.querySelector('.mask');\n        var big = box.querySelector('.big');\n        var imgc = big.querySelector('.imgc');\n        box.addEventListener('mouseover', function () {\n            mask.style.display = 'block';\n            big.style.display = 'block';\n        })\n        box.addEventListener('mouseout', function () {\n            mask.style.display = 'none';\n            big.style.display = 'none';\n        })\n        box.addEventListener('mousemove', function (e) {\n            x = e.pageX - box.offsetLeft;\n            y = e.pageY - box.offsetTop;\n            maxX = x - mask.offsetWidth / 2;\n            maxY = y - mask.offsetHeight / 2;\n            var maxx = box.offsetWidth - mask.offsetWidth;\n            if (maxX <= 0) {\n                maxX = 0;\n            } else if (maxY <= 0) {\n                maxY = 0;\n            } else if (maxX >= maxx) {\n                maxX = maxx;\n            } else if (maxY >= maxx) {\n                maxY = maxx;\n            }\n            mask.style.left = maxX + 'px';\n            mask.style.top = maxY + 'px';\n            var bigmaxx = big.offsetWidth - imgc.offsetWidth;\n            var bigmaxy = big.offsetHeight - imgc.offsetHeight;\n            imgbx = maxX * bigmaxx / maxx;\n            imgby = maxY * bigmaxy / maxx;\n            imgc.style.left = -imgbx + 'px';\n            imgc.style.top = -imgby + 'px';\n        })\n\n    </script>\n```\n{% endfolding %}\n\n{% folding green, 查看样式图例 %}\n ![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/fangda1.gif)\n{% endfolding %}\n\n## scroll系列属性\n\n1. scrollTop/scrollLeft/ScrollWidth/scrollHeight\n2. overflow:auto   使滑动自动显示\n3. 页面被卷去的头部:可以通过window.pageYOffset获得如果是被卷的是左window.pageXoffset\n4. 注意，元素被卷去的头部是elent.scollTop ,如果是页面被卷去的头部则是window.pageYoffset\n\n{% folding green, 查看实例 %}\n```html\n<body>\n    <style>\n        * {\n            padding: 0;\n            margin: 0;\n            box-sizing: border-box;\n        }\n\n        .box1 {\n            width: 400px;\n            height: 200px;\n            background-color: rgb(37, 150, 47);\n            margin: 10px auto;\n\n        }\n\n        .box2 {\n            width: 400px;\n            height: 400px;\n            background-color: rgb(37, 127, 150);\n            margin: 10px auto;\n        }\n\n        .box3 {\n            width: 400px;\n            height: 1000px;\n            background-color: rgb(141, 37, 150);\n            margin: 10px auto;\n        }\n\n        .aside {\n            position: absolute;\n            width: 50px;\n            height: 150px;\n            background-color: rgb(141, 133, 26);\n            top: 300px;\n            right: calc(50% - 250px);\n            padding: 10px;\n            padding-top: 30px;\n            text-align: center;\n            border-radius: 10px;\n        }\n        .aside span{\n            display: none;\n            cursor: pointer;\n        }\n    </style>\n     <div class=\"aside\"><span>返回顶部</span></div>\n    <div class=\"box1\">盒子一</div>\n    <div class=\"box2\">盒子二</div>\n    <div class=\"box3\">盒子三</div>\n\n    <script>\n        var box1 = document.querySelector('.box1');\n        var box2 = document.querySelector('.box2');\n        var box3 = document.querySelector('.box3');\n        var asidese = document.querySelector('.aside');\n        var bon = asidese.offsetTop - box2.offsetTop\n        document.addEventListener('scroll', function () {\n            console.log(box2.offsetTop);\n            console.log('aside的距离'+asidese.offsetTop);\n            if (pageYOffset >= box2.offsetTop) { \n                asidese.style.position = 'fixed';\n                asidese.style.top = bon + 'px'\n            }\n            else{\n                asidese.style.position = 'absolute';\n                asidese.style.top = '300px'\n            }\n            if (pageYOffset >= box3.offsetTop) { \n                asidese.children[0].style.display = 'block';\n            }else{\n                asidese.children[0].style.display = 'none';\n            }\n        })\n        console.log(\"box3的值\"+box3.offsetTop);\n        var btn = asidese.children[0];\n        console.log(asidese.children[0]);\n        btn.addEventListener('click',function(){\n            document.body.scrollTop = document.documentElement.scrollTop = 0;\n        })\n    </script>\n```\n{% endfolding %}\n\n{% folding green, 查看图例 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/jsscrol1l.gif)\n{% endfolding %}\n\n## 三大系列的对比\n\n1. `offsetWidth` 返回自身，并且包括padding，border，不带单位,经常用于获取元素的位置\n2. `clientWidth`返回自身，但是不包括border,包括padding，经常用于获取元素的大小\n3. `scrollWidth` 返回自身实际的宽度，元素的内容，但是不含边框返回数值不带单位  经常用于获取滚动的距离，`注意`页面滚动 通过`window.pageXoffset`获得,元素滚动距离通过`scrollTop`或者`scrollLeft`获取\n\n## mouseover和mouseenter的区别\n\n1. `mouseover`：鼠标经过自身盒子触发，子盒子也会触发\n2. `mouseenter`：鼠标经过自身盒子才会触发，不会进行冒泡处理\n\n## 动画函数的封装\n\n1. 动画原理：使用定时器+元素定位+元素offset\n2. 给不同元素指定不同的定时器\n3. 缓动动画的原理：使用动画缓动执行，使速度慢慢停下来（目标值-现在的位置）\n4. 缓动动画需要将步长值改为整数，使用Math.ceil函数 向上取整\n5. 缓动动画也可以添加回调函数\n\n{% folding green, 缓动匀速封装 %}\n```html\n    <style>\n        * {\n            padding: 0;\n            margin: 0;\n        }\n\n        .box {\n            position: absolute;\n            left: 0;\n            width: 100px;\n            height: 100px;\n            margin: 100px;\n            background-color: rgb(6, 143, 153);\n        }\n        span{\n            position: absolute;\n            left: 0;\n            width: 100px;\n            height: 100px;\n            margin: 210px;\n            margin-left: 100px;\n            background-color: rgb(21, 8, 139);\n        }\n    </style>\n\n    <div class=\"box\"></div>\n    <span></span>\n    <script>\n        var box = document.querySelector('.box');\n        var span =document.querySelector('span')\n        function animate(obj, target) {\n            clearInterval(obj.timer)\n            obj.timer = setInterval(function () {\n                if (obj.offsetLeft >= target) {\n                    clearInterval(timer)\n                }\n                obj.style.left = obj.offsetLeft + 1 + 'px';\n            }, 150)\n        }\n        var box1= animate(box, 800);\n        var span1 = animate(span,900)\n    </script>\n```\n{% endfolding %}\n\n{% folding green, 缓动变速封装 %}\n```html\n    <style>\n        * {\n            padding: 0;\n            margin: 0;\n            box-sizing: border-box;\n        }\n\n        .box {\n            position: absolute;\n            display: block;\n            left: 0;\n            width: 100px;\n            height: 100px;\n            margin: 100px 0;\n            background-color: rgb(6, 143, 153);\n        }\n\n        span {\n            position: absolute;\n            left: 0;\n            width: 100px;\n            height: 100px;\n            margin: 200px 0;\n            background-color: rgb(21, 8, 139);\n        }\n    </style>\n\n    <div class=\"box\"></div>\n    <span></span>\n    <script>\n        var box = document.querySelector('.box');\n        var span = document.querySelector('span');\n\n        function animate(obj, target, callback) {\n            clearInterval(obj.timer);\n            obj.timer = setInterval(function () {\n                var step = (target - obj.offsetLeft) / 10;\n                step = step > 0 ? Math.ceil(step) : Math.floor(step);\n                if (obj.offsetLeft == target) {\n                    clearInterval(obj.timer);\n                    if (callback) {\n                        callback();\n                    }\n                }\n                obj.style.left = obj.offsetLeft + step + 'px';\n            }, 15)\n        }\n        var box1 = animate(box, 800, function () {\n            box.style.display = 'none'\n        });\n        var span1 = animate(span, 900)\n    </script>\n```\n{% endfolding %}\n\n## 缓动函数封装地址\n\n> 【[函数地址](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/animate.js)】\n\n{% folding green, 利用缓动函数做一个鼠标触碰后移动的案例 %}\n```html\n<!DOCTYPE html>\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n\n<body>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n\n        body {\n            width: 100%;\n            width: 100%;\n            overflow-x: hidden;\n        }\n        .container,.box,.box2{\n            border-radius: 10px 0 0 10px;\n        }\n        .container {\n            position: absolute;\n            right: 0px;\n            bottom: 50px;\n            width: 50px;\n            height: 50px;\n            background-color: rgb(83, 3, 3);\n        }\n\n        .box {\n            position: absolute;\n            width: 50px;\n            height: 50px;\n            right: 0;\n            bottom: 0px;\n            font-size: 20px;\n            font-weight: 600;\n            color: #fff;\n            text-align: center;\n            line-height: 50px;\n            background-color: rgb(42, 23, 94);\n        }\n\n        .box2 {\n            position: absolute;\n            right: -150px;\n            bottom: 0;\n            width: 150px;\n            height: 50px;\n            font-size: 20px;\n            font-weight: 600;\n            color: #fff;\n            text-align: center;\n            line-height: 50px;\n            background-color: rgb(42, 23, 94);\n        }\n    </style>\n    <div class=\"container\">\n        <div class=\"box\">&lt;</div>\n        <div class=\"box2\">你好世界</div>\n    </div>\n    <script>\n        var container = document.querySelector('.container');\n        var box2 = document.querySelector('.box2');\n        var box = document.querySelector('.box');\n        container.addEventListener('mouseover', function () {\n            animate(box2, -140, 15);\n            box.innerHTML = '&gt;';\n        })\n        container.addEventListener('mouseout', function () {\n            animate(box2, 140, 15);\n            box.innerHTML = '&lt;'\n        })\n    </script>\n    <script src=\"https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/animate.js\"></script>\n\n</body>\n\n</html>\n\n```\n\n{% endfolding %}\n\n{% folding green, 查看样式 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/jshanshu.gif)\n{% endfolding %}\n\n## 缓动函数 - 匀速运动\n1. 在匀速运动的过程中设置每次移动的距离如果大于`1px`,会使最后的目标位置变大，并且在封装过程中，if判断必须设置为`>=`,看一下样式效果\n2. 看控制台console(obj.offsetLeft)的值可以看出在设置匀速运动时，如果每次移动的距离大于1px，最后得到的距离左侧的位置大于目标位置，再做判断时要设置为对象距离左侧的位置`>=`目标位置\n\n{% folding green, 查看答案 %}\n![](https://img-blog.csdnimg.cn/img_convert/3c3f9833b9652545b8471c11b3f18089.gif)\n{% endfolding %}\n\n- 缓动动画函数 封装 【[地址](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/animate.js)】\n\n## 代码展示\n\n{% folding green, 查看答案 %}\n```js\n// 封装一个匀速或者变速的缓动文件\n// 第一是减速的\nfunction animate(obj, target, speed,callback) {\n    clearInterval(obj.timer);\n    obj.timer = setInterval(function () {\n        var step = (target - obj.offsetLeft) / 10;\n        step = step > 0 ? Math.ceil(step) : Math.floor(step);\n        if (obj.offsetLeft == target) {\n            clearInterval(obj.timer);\n            if (callback) {\n                callback();\n            }\n        }\n        obj.style.left = obj.offsetLeft + step + 'px';\n    }, speed)\n}\n// 第二个封装匀速\n// 对象，目标位置，每次移动的距离，移动速度，回调函数\n// var demo = animateun(obj, target, csteps, callback)\nfunction animateun(obj, target,csteps,speed,callback) {\n    clearInterval(obj.timer);\n    obj.timer = setInterval(function () {\n        // var step = (target - obj.offsetLeft) / 10;\n        // step = step > 0 ? Math.ceil(step) : Math.floor(step);\n        if (obj.offsetLeft >= target) {\n            clearInterval(obj.timer);\n            if (callback) {\n                callback();\n            }\n        }\n        obj.style.left = obj.offsetLeft + csteps + 'px';\n    }, speed)\n}\n```\n{% endfolding %}\n\n\n>以上内容是我在实际操作过程中出现的问题","categories":["web","Javascript"]},{"title":"Javascript的知识总结（13）","url":"/posts/35460/","content":"\n<div class=\"note success icon flat\"><p>BOM浏览器对象模型</p></div>\n\n## 思维导图\n\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/bom1.webp)\n\n## 什么是BOM\n\n1. 顶级对象是`window`\n2. window.name 是特殊的属性\n\n## 窗口加载事件\n\n1. 窗口加载事件 ` window.onload = function(){}`等页面加载完毕，具有唯一性，层叠性，使用addEventListener则没有限制\n2. `document.addEvenListener('DOMContentLoaded',function(){})`\n>区别：load事件是页面内容全部加载完毕，包括dom元素，图片，css等，DOMContentLoaded是DOM加载完毕就执行,不包括其他的图片等等\n\n1. `window.onresize()`只要窗口发生变化，像素点发生变化，就执行，响应式布局\n2. `window.innerWidth`可以检测屏幕的宽度\n3. `window.setTimeout(调用函数，延时时间)，window调用可以省略，只调用一次\n\n{% folding green, 查看实例 %}\n\n```js\n        setTimeout(function(){\n            console.log('时间到了');\n        },2000)\n        function calk(){\n            console.log('爆炸了');\n        }\n        var time1 = setTimeout(calk,3000);\n        var time2 = setTimeout('calk()',3000);\n```\n{% endfolding %}\n\n1. 回调函数callback   window.SetTimeout()\n2. 清除定时器  clearSetTimeout(定时器的名称)\n3. 定时器  `window.setInterval()`反复调用函数\n4. 清除重复的定时器`widow.clearInterval`\n\n{% folding green, 清除效果 %}\n```html\n    <span>1</span>\n    <li>2</li>\n    <script>\n        var span = document.querySelector('span');\n        var timer = function(){\n            console.log('真好');\n        }\n        var li = document.querySelector('li');\n        li.addEventListener('click',function(){\n            clearTimeout(times);\n        })\n        var times = setTimeout(timer,5000);\n    </script>\n```\n{% endfolding %}\n\n{% folding green, 案例网站运行时间 %}\n```html\n    <style>\n        .box {\n            width: 140px;\n            height: 30px;\n            margin: 100px auto;\n        }\n\n        .countdown {\n            width: 100%;\n            height: 100%;\n            display: inline-flex;\n        }\n\n        .countdown span {\n            flex: 25%;\n            margin-left: 5px;\n            background-color: #000;\n            color: #fff;\n            font-size: 14px;\n            font-weight: 550;\n            text-align: center;\n            line-height: 30px;\n            border-radius: 7px;\n        }\n\n        .countdown span:nth-child(1) {\n            margin-left: 0;\n        }\n    </style>\n</head>\n\n\n<body>\n    <div class=\"box\">\n        <div class=\"countdown\">\n            <span></span>\n            <span></span>\n            <span></span>\n            <span></span>\n        </div>\n    </div>\n    <script>\n        var count = document.querySelector('.countdown');\n        var inputdate = +new Date('2019-12-31 0:0:0')\n        countdown();\n        setInterval(countdown, 1000);\n        function countdown() {\n            var nowdate = +new Date();\n            var times = (nowdate - inputdate) / 1000;\n            var d = parseInt(times / 60 / 60 / 24);\n            count.children[0].innerHTML = d < 10 ? '0' + d : d;\n            var h = parseInt(times / 60 / 60 % 24);\n            count.children[1].innerHTML = h < 10 ? '0' + h : h;\n            var m = parseInt(times / 60 % 60);\n            count.children[2].innerHTML = m < 10 ? '0' + m : m;\n            var s = parseInt(times % 60);\n            count.children[3].innerHTML = s < 10 ? '0' + s : s;\n        }\n    </script>\n```\n{% endfolding %}\n\n{% folding green, 演示图例 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/countdowns.gif)\n{% endfolding %}\n\n{% folding green, 短信倒计时案例 %}\n```html\n    <input type=\"number\" name=\"\" id=\"\"><button>发送</button>\n    <script>\n        var btn = document.querySelector('button');\n        var timer = 60;\n        btn.addEventListener('click', function () {\n            btn.disabled = true;\n            var times = setInterval(function () {\n                if (timer == 0) {\n                    clearInterval(times);\n                    btn.disabled = false;\n                    btn.innerHTML = '发送'\n                    timer = 60;\n                } else {\n                    btn.innerHTML = '还剩下' + timer + 's'\n                    timer--;\n                }\n            }, 1000)\n        })\n    </script>\n```\n{% endfolding %}\n\n## this指向\n\n1. 方法调用中谁调用this指向谁\n2. 全局作用下的this指向window\n\n## 同步和异步\n\n1. 执行的顺序不同\n2. 同步任务都在主线程上\n3. 异步任务  是通过回调函数实现的\n4. 事件循环 event loop\n\n## loaction对象\n\n1. `https://www.xxxx.cn/index.html?name=andy&age=18#link`\n2. query 是以键值对的形式通过&符号分隔开\n3. location.href  获取url\n4. location.search 返回参数\n5. location.hash 返回片段 #\n6. location.pathname 返回路径\n7. location.port 返回端口号\n8. location.host 返回主机域名\n9. location.assign()和href一样，能记录浏览历史\n10. location.replace(),无法记录浏览历史\n11. location.reload()  如果+  true 页面可强制刷新\n\n- 使用location对象将一个页面的数据传送到另一个页面\n\n{% folding green, 查看实例 %}\n```js\nvar div = document.querySelector('div');\nconsole.log(location.search);\nvar a = location.search.substr(1);\nconsole.log(a);\nvar arr = a.split('=');\nconsole.log(arr);\ndiv.innerHTML = arr[1] + '博客欢迎你'\n```\n{% endfolding %}\n\n## navidator对象\n\n{% folding green, 查看答案 %}\n```js\nif((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) {\n    window.location.href = \"\";     //手机\n } else {\n    window.location.href = \"\";     //电脑\n }\n```\n{% endfolding %}\n\n## history对象\n\n1. history.back  后退\n2. history.forword  前进\n3. history.go(1/-1)  实现页面的前进后退\n\n\n\n\n\n\n\n","categories":["web","Javascript"]},{"title":"Javascript知识总结（12）","url":"/posts/49414/","content":"\n<div class=\"note primary icon flat\"><p>事件监听方式</p></div>\n\n## 注册事件\n\n1. 传统注册方式，使用on开头的，注册事件具有唯一性\n2. 方法监听方式 addEventListener()  /  attachEvent(),特点：同一个元素可以添加多种事件\n\n## 事件监听方式\n\n1. `addEventListener('事件类型',function(){})`，\n2. 里面的事件是字符型，不加`on`\n3. 同一个元素同一个事件可以添加多个侦听器（事件处理程序）\n\n<span class=\"inline-tag\" style=\"--Color:#881B12\">兼容性问题</span>\n\n1. attachEvent('事件类型',function(){})\n2. ie9以前支持\n\n## 删除事件\n\n1. 传统事件解绑方法\n\n{% folding green, 查看实例 %}\n\n```html\n    <script>\n        var divs =document.querySelectorAll('div');\n        divs[0].onclick = function(){\n            alert('nihao');\n            divs[0].onclick = null;\n        }\n    </script>\n```\n{% endfolding %}\n\n2. 第二种removeEventListener\n\n{% folding green, 查看答案 %}\n```js\n        divs[1].addEventListener('click',fn);\n        function fn(){\n            alert('nihao');\n            divs[1].removeEventListener('click',fn)\n        }\n```\n\n{% endfolding %}\n\n3. 第三种使用datch\n\n## Dom事件流\n\n1. 捕获阶段，当前目标阶段，冒泡阶段\n2. js代码中只能执行捕获或者冒泡其中的一个阶段\n3. onclick和attachEvent只能得到冒泡阶段\n4. addEventListener看第三个参数的设置默认为false，`true`表示在事件`捕获阶段`调用事件处理程序，`false`表示在事件`冒泡阶段`调用事件处理程序\n5. 传播类型：捕获从外到里，冒泡从里到外\n6. 有些事件没有冒泡onblur，onmouseenter，onmouseleave，onfocus\n\n## 事件对象\n\n1. 侦听函数  小括号里面的当形参来看\n2. 有兼容性问题，ie678通过window.event \n\n{% folding green, 查看答案 %}\n```js\n        var divs =document.querySelectorAll('div');\n        divs[0].onclick = function(e){\n            console.log(e);\n            e = e || Window.event;\n        }\n        \n        divs[1].addEventListener('click',fn);\n        function fn(e){\n            console.log(e);\n            e = e || Window.event;\n        }\n```\n{% endfolding %}\n\n## 常见事件对象的属性和方法\n\n<span class=\"inline-tag\" style=\"--Color:#881B12\">返回事件</span>\n\n1. `e.target` 返回的是触发事件的对象元素  event,兼容性问题`e.srcElement`\n2. `this`返回的是绑定事件的对象   (类似属性`currentTarget`,有兼容性问题问题)\n3. `e.type`调用事件类型，不带on\n\n<span class=\"inline-tag\" style=\"--Color:#1a9255\">阻止默认事件</span>\n\n1. `e.preventDefault()` 有兼容性问题\n2. 低版本 使用returnValue\n3. 可以使用return false，没有兼容性问题，特点 return后面的代码不执行，只限制于传统的注册方式\n\n<span class=\"inline-tag\" style=\"--Color:#4121c3\">阻止冒泡 </span>\n\n1. `stopPropagation()`，偶遇兼容性问题\n2. `e.canceBubble = true`  非标准的\n\n## 事件委托\n\n> 重点原理：不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点\n\n## 常见的鼠标事件\n\n1. `contextmenu`文本菜单\n2. `selectstart`选中文字\n\n{% folding green, 查看答案 %}\n```html\n    <ul>我是一段不愿意被复制的文字</ul>\n    <script>\n        var ul = document.querySelector('ul');\n        ul.addEventListener('contextmenu',function(e){\n            e.preventDefault();\n        })\n        ul.addEventListener('selectstart',function(e){\n            e.preventDefault();\n        })\n    </script>\n```\n{% endfolding %}\n\n### 鼠标事件对象\n\n<span class=\"inline-tag\" style=\"--Color:#881B12\">click</span>\n\n1. e.clientX/Y   鼠标在可视区\n2. e.pageX/Y  在页面文档\n3. e.screnX/Y  相对于屏幕\n\n<span class=\"inline-tag\" style=\"--Color:#881B12\">mousemove</span>\n\n1. 原理：获取鼠标的位置，设置元素的样式\n\n{% folding green, 查看答案 %}\n```html\n    <style>\n        img{\n            position: absolute;\n            width: 20px;\n        }\n    </style>\n    <img src=\"https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/0/jsdelivr.jpeg\" alt=\"\">\n    <script>\n        var imgc = document.querySelector('img')\n        document.addEventListener('mousemove',function(e){\n            var x = e.pageX;\n            var y = e.pageY;\n            imgc.style.left = x +'px';\n            imgc.style.top = y +'px';\n        })\n    </script>\n```\n{% endfolding %}\n\n## 常用的键盘事件\n\n1. `keyup`按键弹起时触发\n2. `keydown`按下时触发，能识别功能键，优先级高\n3. `keypress`被按下时触发（不识别功能键ctrl，shift，左右箭头）\n4. e.keyCode 得到相应键位的ASCII值，keyup和keydown事件不区分字母大小写，keypress区分大小写\n\n\n{% folding green, 输入快捷键获得焦点实例 %}\n```html\n    <input type=\"text\">\n    <script>\n        var input = document.querySelector('input');\n        document.addEventListener('keyup',function(e){\n            console.log(e.keyCode);\n            if(e.keyCode === 65){\n                input.focus();\n            }\n        })\n    </script>\n```\n{% endfolding %}\n\n{% folding green, 鼠标获取实例%}\n\n```html\n<style>\n    .box {\n        position: relative;\n        width: 150px;\n        margin: 6.25rem auto;\n    }\n\n    .con {\n        display: none;\n        position: absolute;\n        top: -25px;\n        margin: 0 0 5px 20px;\n        border-radius: 10px;\n        height: 20px;\n        width: 80px;\n        background-color: #537934;\n        color: #000;\n        font-size: 10px;\n        padding-left: 5px;\n        padding-top: 2px;\n    }\n\n    .con:after {\n        content: '';\n        position: absolute;\n        width: 0;\n        height: 0;\n        border-top: 5px solid #537934;\n        border-right: 10px solid transparent;\n        border-left: 10px solid transparent;\n        margin: 10px auto;\n        bottom: -15px;\n        left: 20px;\n    }\n\n    input {\n        outline: none;\n        border-radius: 5px;\n        width: 150px;\n        height: 20px;\n        padding-left: 4px;\n        border: 2px solid #ccc;\n        background-color: rgba(139, 187, 50, 0.424);\n    }\n</style>\n\n<body>\n    <div class=\"box\">\n        <div class=\"con\"></div>\n        <input type=\"text\" name=\"\" id=\"\" placeholder=\"请输入内容\">\n    </div>\n    <script>\n        // 获取光标\n        var inputs = document.querySelector('input');\n        document.addEventListener('keyup', function (e) {\n            if (e.keyCode === 65) {\n                inputs.focus();\n            }\n        })\n        // 第二步实现浮动框显示，在检测到con中出现文字时\n        var box = document.querySelector('.box');\n        inputs.addEventListener('keyup', function () {\n            if (inputs.value == '') {\n                box.children[0].style.display = 'none';\n            } else {\n                box.children[0].style.display = 'block';\n                box.children[0].innerHTML = inputs.value;\n            }\n\n        })\n        inputs.addEventListener('focus', function () {\n            if (inputs.value !== '') {\n                box.children[0].style.display = 'block';\n            }\n        })\n        inputs.addEventListener('blur', function () {\n            box.children[0].style.display = 'none'\n        })\n\n    </script>\n```\n{% endfolding %}\n","categories":["web","Javascript"]},{"title":"主页的搭建-building(JavaScript和CSS3)","url":"/posts/40078/","content":"\n<div class='tip success faa-horizontal animated'><p>使用JavaScript和CSS3搭建<p></div>\n\n## 主页地址\n\n>【[Main Page](https://mr90.top/)】\n\n## 主页介绍\n\n1. 本页面使用`rem`布局+`flex`布局\n2. 加入了昼夜模式，可自动切换（使用了JavaScript）\n3. 适配移动端，媒体查询\n4. 主页标题使用 CSS3中的动画，还有文字阴影搭配使用\n5. Tab栏,昼夜交替使用了`JavaScript排他思想`，设置自定义属性\n6. 主页加入【[牛年灯笼特效](https://u.mr90.top/posts/8914/)】 \n7. 加入鼠标样式，底部引入导航信息栏-仿`Rocketdock`\n8. 优化昼夜模式，加入切换昼夜模式提示框，使用JavaScript中的定时器和缓动动画函数+CSS3动画\n9. pc端底部增加留言板，触碰后显示留言板，使用JavaScript中的缓动动画函数\n10. 去除页面灯笼效果，页面加入jQuery插件,页面去除原生Tab栏使用jQuery框架，加入切换小圆点\n11. 页面顶部加入打字机效果，优化时光轴部分细节\n\n{% folding green, 查看图例 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/mainpadge31923.gif)\n{% endfolding %}\n\n\n## Tab栏介绍\n\n1. 第一屏\n- 使用了`JavaScript`中的`node`操作比如node的增删，大量使用节点\n{% folding green, 查看图例 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/tab1.gif)\n{% endfolding %}\n2. 第二屏 \n- 第二屏沿用第一屏node增删节点，使用BOM，定时器等等\n{% folding green, 查看图例 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/tab2dw.gif)\n{% endfolding %}\n3. 第三屏 待写\n4. 第四屏 待写\n5. 第五屏 待写\n\n## 仓库地址\n\n1. 我的仓库地址：【[Github](https://github.com/Rr210/javascript/)】\n2. 使用时请标明出处谢谢","categories":["技术·教程"]},{"title":"Javascript的知识整理(11)","url":"/posts/14314/","content":"\n<div class=\"tip socd font5 fas fa-bell faa-horizontal animated\"><p>自定义属性，节点操作</p><p></p></div>\n\n## Dom 树\n\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/dom.webp)\n\n## 思维导图\n\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/dom1.webp)\n\n## 自定义属性\n\n1. 在页面暂时保存数据而不是数据库\n2. 规定自定义属性以`data-`开头，自定义属性\n3. h5新增获取 `属性.dataset.(要获取的属性)`，必须以data开头\n4. 如果是list-index-name   使用新特性时获取采用驼峰命名法\n\n\n## 节点操作\n\n1. 兄弟关系和父子关系，层次关系（node）\n2. nodeType（节点类型），nodeName（节点名称），nodeValue（节点值）\n3. 元素节点nodeType=1，属性为2，文本，空格换行等等为3\n4. 父亲节点 `parentNode`找不到父节点返回为 `null`,返回的是最近的父元素\n5. 孩子节点`childNodes`得到的所有节点包括元素节点文本节点等等，一般不使用childNodes，使用非标准的`parentNode.children`可获取所有的子元素\n6. `firstchild/lastchild`获取的是第一个节点文本节点或者元素节点\n7. `firstElementChild/last`返回的是第一个子元素节点（兼容性问题）\n\n{% folding green, 查看实例 %}\n\n```html\n    <ul>\n        <li>1</li>\n        <li>2</li>\n        <li>3</li>\n        <li>4</li>\n        <li>5</li>\n        <li>6</li>\n        <li>7</li>\n        <li>8</li>\n    </ul>\n    <script>\n        var ul = document.querySelector('ul');\n        var lis = ul.querySelectorAll('li');\n        console.log(ul.children);\n        console.log(ul.firstElementChild);\n        console.log(ul.children[0]);\n        console.log(ul.children[ul.children.length - 1]);\n    </script>\n```\n{% endfolding %}\n\n## 兄弟节点\n\n1. `nextSibling`下一个兄弟节点，`nextElementSibling`\n2. 和父亲节点类似，`previousELementSibling`上一个元素节点\n\n## 添加节点\n\n1. `node.appendChild(child)`node父级 child是子级\n2. 创建元素节点 document.createElement('元素')\n3. node.insertBefore(child,指定元素)\n\n## 实例化操作\n\n1. 演示站点 【[第一屏](https://mr90.top)】\n2. 大量使用节点，比如节点的增加与删除等等\n\n## 删除节点\n\n1. 父元素.removeChild[索引号]\n2. `disabled`禁用按钮 \n3. 阻止链接跳转，`javascript:void(0);`或者` javascript:;`\n\n## 复制节点\n\n1. 括号为空或者里面时false 浅拷贝，只复制标签不复制内容\n2. 括号里面为true，深拷贝，复制标签及其里面的内容\n\n## 动态创建表格\n\n1. 使用双循环，类似于冒泡排序，一个循环控制行，一个循环控制列\n2. 使用for..in 遍历数组属性，属性值\n3. 巧妙使用删除节点实现整行或者整列删除\n\n{% folding green, 查看实例 %}\n\n```html\n<style>\n    * {\n        padding: 0;\n        margin: 0;\n    }\n    table{\n        border: 1px solid #888;\n        border-bottom: 0;\n        border-right: 0;\n        border-radius: 5px;\n        overflow: hidden;\n    }\n    th,\n    td {\n        border-right: 1px solid #888;\n        border-bottom: 1px solid #888;\n    }\n    thead{\n        background-color: #ccc;\n    }\n    tbody{\n        text-align: center;\n    }\n    table {\n        width: 400px;\n        margin: 12.5rem auto;\n    }\n</style>\n\n<body>\n    <table cellspacing=\"0\">\n        <thead>\n            <tr>\n                <th>name</th>\n                <th>subject</th>\n                <th>score</th>\n                <th>你好世界</th>\n            </tr>\n        </thead>\n        <tbody>\n        </tbody>\n    </table>\n    <script>\n        var dates = [{\n            name: 'G先生',\n            subject: 'java',\n            score: 100\n        },\n        {\n            name: 'Q先生',\n            subject: 'java',\n            score: 99\n        },\n        {\n            name: 'W先生',\n            subject: 'java',\n            score: 98\n        },\n        {\n            name: 'T先生',\n            subject: 'java',\n            score: 97\n        }];\n        console.log(dates.length);\n        var tbody = document.querySelector('tbody');\n        for(var i = 0;i<dates.length;i++){\n            var tr = document.createElement('tr');\n            tbody.appendChild(tr);\n            for(var k in dates[i]){\n                var td =document.createElement('td');\n                td.innerHTML = dates[i][k];\n                tr.appendChild(td);\n            }\n            var td = document.createElement('td');\n            td.innerHTML = '<a href=\"javascript:;\">删除</a>'\n            tr.appendChild(td);\n            // 获取要点击得孩子节点，删除父元素，就需要找上级的上级\n            tr.children[tr.children.length - 1].onclick = function(){\n                tbody.removeChild(this.parentNode);\n            }\n        }\n    </script>\n```\n\n{% endfolding %}\n\n## 创建元素\n\n1. document.write('')，如果页面文档流加载完毕，在调用后页面重绘效果不好\n2. innerHTML   创建多个元素时效率会低一些（采取拼接字符串），采取数组时效率最高\n- arr.push('')   在转换为arr.join('')字符串\n3. document.createElement('')  创建多个元素时效率较第二种高，使用数组转化时效率最高","categories":["web","Javascript"]},{"title":"JavaScript的知识整理（10）","url":"/posts/26656/","content":"<div class=\"tip ban font5 fas fa-ban faa-horizontal animated\"><p>表单,tab标签，自定义属性</p><p></p></div>\n\n## 表单实例\n\n{% folding green, 查看答案 %}\n\n```html\n<style>\n    * {\n        margin: 0;\n        padding: 0;\n    }\n    body{\n        font-size: 13px;\n    }\n    table{\n        text-align: center;\n        margin: 100px auto;\n        border-radius: 10px;\n        overflow: hidden;\n    }\n    thead{\n        background-color: #008dd0;\n    }\n</style>\n\n<body>\n    <table width=\"300px\" border=\"1\" cellspacing=\"0\">\n        <thead>\n            <tr>\n                <th><label for=\"all\">全选<input type=\"checkbox\" id=\"all\"></label></th>\n                <th>hello</th>\n                <th>world</th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td><input type=\"checkbox\"></td>\n                <td>你好世界</td>\n                <td>你好世界</td>\n            </tr>\n            <tr>\n                <td><input type=\"checkbox\"></td>\n                <td>你好世界</td>\n                <td>你好世界</td>\n            </tr>\n            <tr>\n                <td><input type=\"checkbox\"></td>\n                <td>你好世界</td>\n                <td>你好世界</td>\n            </tr>\n            <tr>\n                <td><input type=\"checkbox\"></td>\n                <td>你好世界</td>\n                <td>你好世界</td>\n            </tr>\n        </tbody>\n\n    </table>\n    <script>\n        var main = document.getElementById('all');\n        var input = document.querySelector('tbody').getElementsByTagName('input');\n        // 当点击全选按钮时，下方的选框同步\n        main.onclick = function () {\n            console.log(this.checked);\n            for (var i = 0; i <= input.length - 1; i++) {\n                input[i].checked = this.checked;\n            }\n        }\n        // 当去除下方选框，或者全部将input选框点击或取消时，全选按钮同步发生改变\n        for (var i = 0; i <= input.length - 1; i++) {\n            input[i].onclick = function () {\n                var flag = true;\n                for (var i = 0; i <= input.length - 1; i++) {\n                    if (!input[i].checked) {\n                        flag = false;\n                    }                   \n                } \n                main.checked = flag;\n            }\n        }\n\n    </script>\n```\n{% endfolding %}\n\n## 自定义属性\n\n1. 获取元素的属性\n2. element.属性/elemnet.getAttribute('属性')\n3. 自定义属性使用`get`获取\n4. 设置元素值`set`\n5. 可以修改`onclick`为鼠标触碰`onmouseover`\n\n{% folding green, 查看答案 %}\n\n```html\n    <div class=\"demo\" id=\"demo1\" index=\"temp\"></div>\n    <script>\n        var div = document.querySelector('div');\n        console.log(div.id);\n        console.log(div.getAttribute('id'));\n        console.log(div.getAttribute('index'));\n        // 设置div的属性值，有两种方法，标签.属性/setAttribute('属性名')\n        div.id = 'text1';\n        console.log(div.id);\n        div.className = 'text2';\n        console.log(div.className);\n        div.setAttribute('index',2);\n        // 获取属性值可以使用两种方式，一种是标签.属性/getAttribute('属性名')\n        console.log(div.getAttribute('index'));\n        div.setAttribute('index','footer')\n        console.log(div.getAttribute('index'));\n    </script>\n```\n\n{% endfolding %}\n\n## 移除属性\n\n>div.removeAtribute('index');\n\n## tab标签\n\n1. 使用排他思想\n2. 使用自定义属性Attribute('属性名'，'属性值')\n3. 使用自定义属性获取点击索引号\n\n\n{% folding green, 示例一 %}\n\n\n```html\n<style>\n    * {\n        margin: 0;\n        padding: 0;\n\n    }\n\n    ul {\n        list-style: none;\n    }\n\n    .tab {\n        width: 500px;\n        height: 300px;\n        margin: 200px auto;\n        border: 1px solid #888;\n        border-bottom: 0;\n        border-radius: 10px;\n        overflow: hidden;\n        box-shadow: 1px 1px 3px #888;\n    }\n\n    .tab ul {\n        display: inline-flex;\n        width: 100%;\n        align-items: center;\n        background-color: #ccc;\n        font-size: 13px;\n    }\n\n    .tab ul li {\n        text-align: center;\n        flex: 20%;\n        padding: 5px;\n        box-sizing: border-box;\n        border: 1px solid #888;\n        border-top: 0;\n        border-left: 0;\n        transition: all .6s;\n    }\n    .tab_con{\n        width: 100%;\n        height: 100%;\n    }\n    .item:nth-child(1){\n        background:-webkit-linear-gradient(left,#8b48486c,#a2aa5579,#3655b99a);\n    }\n    .item:nth-child(2){\n        background:-webkit-linear-gradient(left,#4f488b6c,#5599aa79,#b936829a);\n    }\n    .item:nth-child(3){\n        background:-webkit-linear-gradient(left,#8b58486c,#7655aa79,#9db9369a);\n    }\n    .item:nth-child(4){\n        background:-webkit-linear-gradient(left,#488b7a6c,#55aa9f79,#b9a1369a);\n    }\n    .item:nth-child(5){\n        background:-webkit-linear-gradient(left,#48498b6c,#5577aa79,#36b9ae9a);\n    }\n    .tab ul li:hover {\n        background-color: #12774d;\n        color: white;\n    }\n\n    .item {\n        display: none;\n        width: 100%;\n        height: 100%;\n    }\n</style>\n\n<body>\n    <div class=\"tab\">\n        <ul class=\"tab1\">\n            <li>你好世界</li>\n            <li>你好世界</li>\n            <li>你好世界</li>\n            <li>你好世界</li>\n            <li>你好世界</li>\n        </ul>\n        <div class=\"tab_con\">\n            <div class=\"item\" style=\"display:block\">Hello world1</div>\n            <div class=\"item\">Hello world2</div>\n            <div class=\"item\">Hello world3</div>\n            <div class=\"item\">Hello world4</div>\n            <div class=\"item\">Hello world5</div>\n        </div>\n    </div>\n    <script>\n        var lis = document.querySelector('.tab1').querySelectorAll('li');\n        var items = document.querySelector('.tab_con').querySelectorAll('.item');\n        for (var i = 0; i <= lis.length - 1; i++) {\n            lis[i].setAttribute('index', i);\n            lis[i].onclick = function () {\n                var index = this.getAttribute('index');\n                console.log(index);\n                for (var i = 0; i <= lis.length - 1; i++) {\n                    items[i].style.display = 'none';\n                } // 设置索引号\n                items[index].style.display = 'block';\n            }           \n        }\n    </script>\n```\n\n{% endfolding %}\n\n{% folding green, 查看样式图例 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/onclick.gif)\n{% endfolding %}\n\n{% folding green, 示例二 %}\n\n\n```html\n<style>\n    * {\n        margin: 0;\n        padding: 0;\n\n    }\n\n    ul {\n        list-style: none;\n    }\n\n    .tab {\n        width: 500px;\n        height: 300px;\n        margin: 200px auto;\n        border-top: 1px solid #888;\n        border-radius: 10px;\n        overflow: hidden;\n        box-shadow: 1px 1px 3px #888;\n    }\n\n    .tab ul {\n        display: inline-flex;\n        width: 100%;\n        align-items: center;\n        background-color: #ccc;\n        font-size: 13px;\n    }\n\n    .tab ul li {\n        text-align: center;\n        flex: 20%;\n        padding: 5px;\n        box-sizing: border-box;\n        border: 1px solid #888;\n        border-top: 0;\n        border-left: 0;\n        transition: all .6s;\n    }\n    .tab_con{\n        width: 100%;\n        height: 100%;\n    }\n    .item:nth-child(1){\n        background:-webkit-linear-gradient(left,#8b48486c,#a2aa5579,#3655b99a);\n    }\n    .item:nth-child(2){\n        background:-webkit-linear-gradient(left,#4f488b6c,#5599aa79,#b936829a);\n    }\n    .item:nth-child(3){\n        background:-webkit-linear-gradient(left,#8b58486c,#7655aa79,#9db9369a);\n    }\n    .item:nth-child(4){\n        background:-webkit-linear-gradient(left,#488b7a6c,#55aa9f79,#b9a1369a);\n    }\n    .item:nth-child(5){\n        background:-webkit-linear-gradient(left,#48498b6c,#5577aa79,#36b9ae9a);\n    }\n    .tab ul li:hover {\n        background-color: #12774d;\n        color: white;\n    }\n\n    .item {\n        display: none;\n        width: 100%;\n        height: 100%;\n    }\n</style>\n\n<body>\n    <div class=\"tab\">\n        <ul class=\"tab1\">\n            <li>你好世界</li>\n            <li>你好世界</li>\n            <li>你好世界</li>\n            <li>你好世界</li>\n            <li>你好世界</li>\n        </ul>\n        <div class=\"tab_con\">\n            <div class=\"item\" style=\"display:block\">Hello world1</div>\n            <div class=\"item\">Hello world2</div>\n            <div class=\"item\">Hello world3</div>\n            <div class=\"item\">Hello world4</div>\n            <div class=\"item\">Hello world5</div>\n        </div>\n    </div>\n    <script>\n        var lis = document.querySelector('.tab1').querySelectorAll('li');\n        var items = document.querySelector('.tab_con').querySelectorAll('.item');\n        for (var i = 0; i <= lis.length - 1; i++) {\n            lis[i].setAttribute('index', i);\n            lis[i].onmouseover = function () {\n                var index = this.getAttribute('index');\n                console.log(index);\n                for (var i = 0; i <= lis.length - 1; i++) {\n                    items[i].style.display = 'none';\n                } // 设置索引号\n                items[index].style.display = 'block';\n            }           \n        }\n    </script>\n```\n{% endfolding %}\n\n{% folding green, 查看样式图例 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/tab.gif)\n{% endfolding %}","categories":["web","Javascript"]},{"title":"Javascript的知识整理（9）","url":"/posts/23942/","content":"\n<div class=\"tip wtgo font5 fas fa-bolt faa-horizontal animated\"><p></p><p>querySelector的使用，兼容性较好，排他思想</p></div>\n\n## 通过类名获取\n\n1. `document.getElementsByClassName('类名')`根据类名获得某些元素的集合\n2. `document.querySelector('.box')`返回`指定选择器`的`第一个`元素对象\n3. `document.querySelectorAll('选择器')`返回指定选择器的所有元素对象\n\n## 获取特殊元素\n\n1. 获取`body`元素  `document.body`\n2. 获取`html`元素 `document.documentElement`\n\n## 事件基础\n\n1. 被JavaScript检测到的行为，响应机制\n2. 事件源，时间类型，时间处理程序\n3. 事件源  按钮对象\n4. 事件类型  比如onclick\n5. 事件处理程序 通过一个函数赋值的方式完成\t\n\n{% folding green, 查看实例 %}\n```html\n    <button id=\"btn\">你好</button>\n        <script>\n            var btn = document.getElementById('btn');\n            btn.onclick = function(){\n                alert('世界')\n            }\n        </script>\n<div>你好世界</div>\n        <script>\n            var dir = document.querySelector('div');\n            dir.onclick = function(){\n                console.log('我被选中了');\n            }\n</script>\n```\n{% endfolding %}\n\n## 操作元素\n\n1. 改变页面元素的内容  `元素.innerText`，不识别标签，非标准，去除空格和换行\n2. `元素.innerHtml` 可识别标签，可获取标签和空格（形式）\n3. 这两个操作元素可获取元素里面的内容\n\n{% folding green, 查看实例 %}\n\n```html\n<style>\np{\n            width: 200px;\n            height: 50px;\n            line-height: 50px;\n            background-color: #7a1d8d;\n        }\n        div {\n            width: 100px;\n            height: 40px;\n            list-style: 40px;\n            background-color: #8a4444;\n        }\n    </style>\n    <button>\n        显示当前系统时间\n    </button>\n    <div>某个时间</div>\n    <script>\n        var btn = document.querySelector('button');\n        var div = document.querySelector('div');\n        var p = document.querySelector('p')\n        btn.onclick = function() {\n            div.innerText = date();\n        }\n        function date() {\n            var date = new Date();\n            var day = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];\n            return '今天是' + day[date.getDay()];\n        }\n        p.innerText = date();\n    </script>\n```\n{% endfolding %}\n\n## 通过修改标签属性\n\n1. 比如：`img.src`\n\n{% folding green, 查看实例 %}\n\n```html\n<style>\n        img{\n            width: 200px;\n        }\n    </style>\n    <button class=\"ni\">你好</button>\n    <button class=\"ss\">世界</button>\n    <img src=\"https://cdn.jsdelivr.net/gh/zykjofficial/zykjimg/anime/anime0.png\" alt=\"\">\n    <script>\n        var ni = document.querySelector('.ni');\n        var ss = document.querySelector('.ss');\n        var img = document.querySelector('img');\n        ni.onclick = function(){\n            img.src = 'https://cdn.jsdelivr.net/gh/Fuukei/WebP_API/PC/web-illust_68883968_20180804_203521.webp'\n        }\n        ss.onclick = function(){\n            img.src = 'https://cdn.jsdelivr.net/gh/zykjofficial/zykjimg/anime/anime0.png'\n        }\n</script>\n```\n{% endfolding %}\n\n2. 分时案例，显示不同的问候语\n\n{% folding green, 查看实例 %}\n```html\n<style>\n    img{\n        width: 300px;\n    }\n</style>\n<body>\n    <img src=\"https://cdn.jsdelivr.net/gh/zykjofficial/zykjimg/anime/anime0.png\" alt=\"\">\n    <div>当前的时间为</div>\n    <script>\n        var img = document.querySelector('img');\n        var div = document.querySelector('div');\n        var date = new Date();\n        var h = date.getHours();\n        if (h < 12){\n            img.src = 'https://cdn.jsdelivr.net/gh/zykjofficial/zykjimg/anime/anime0.png'\n            div.innerHTML = '现在是上午，好好写代码'\n        }else if(h<18){\n            img.src = 'https://cdn.jsdelivr.net/gh/Fuukei/WebP_API/PC/web-illust_68883968_20180804_203521.webp'\n            div.innerHTML = '现在是傍晚，好好写代码'\n        }else{\n            img.src = 'https://cdn.jsdelivr.net/gh/Fuukei/WebP_API/PC/web-illust_65203608_20171003_092952.webp'\n            div.innerHTML = '现在是晚上，好好写代码'\n        }\n    </script>\n```\n{% endfolding %}\n\n## 修改表单属性\n\n1. 通过修改表单元素的属性，比如：表单元素按钮中，按钮禁用的两种方法\n2. `属性名(this).disabled = true`\n\n{% folding green, 查看答案 %}\n```html\n        <button>按钮</button>\n        <input type=\"text\" value=\"输入内容\">\n        <script>\n            var btn = document.querySelector('button');\n            var input = document.querySelector('input');\n            btn.onclick = function(){\n                input.value = '你好世界';\n                btn.disabled = true;\n                // 禁用按钮 this.disabled = true  \n                // this是指时间函数的调用者\n            }\n        </script>\n```\n{% endfolding %}\n\n3. 密码显示与隐藏案例\n\n{% folding green, 查看实例 %}\n\n```html\n<style>\n    input {\n        outline: none;\n        border-radius: 5px;\n        border: 1px solid #888;\n        width: 100%;\n    }\n\n\n    div {\n        position: relative;\n        width: 200px;\n    }\n\n    i {\n        position: absolute;\n        right: 0px;\n        top: 5px\n    }\n</style>\n\n<body>\n    <div>\n        <input type=\"text\" placeholder=\"请输入密码\"><i class=\"fa fa-battery-2\"></i>\n    </div>\n    <script>\n        var input = document.querySelector('input');\n        var i = document.querySelector('i');\n        i.onclick = function () {\n            if (input.type == 'text') {\n                input.type = 'password';\n            } else {\n                input.type = 'text';\n            }\n        }\n</script>\n```\n{% endfolding %}\n\n## 通过js修改样式\n\n1. `元素.style`里面的属性采用驼峰命名法,行内样式，权重较高\n2. `元素.className`类名样式属性\n3. 利用样式的显示和隐藏 `box.style.display: 'none'`\n4. 精灵图 对于有规律的，可以使用for循环\n\n## 操作元素\n\n1. onfocus/onblur，获得焦点，失去焦点\n2. 元素.className类名样式属性，更改元素的样式，适合样式较多\n3. 可以使用多类名选择器保留原来的样式\n\n{% folding green, 查看实例 %}\n\n```html\n<style>\n    .last {\n        width: 300px;\n        height: 200px;\n        font-size: 12px;\n        font-weight: 600;\n        color: antiquewhite;\n        background-color: blueviolet;\n    }\n\n    .chage {\n        width: 200px;\n        height: 300px;\n        font-size: 12px;\n        font-weight: 600;\n        color: #172ca7;\n        background-color: #19b8d471;\n    }\n</style>\n\n<body>\n    <input type=\"text\" placeholder=\"你好世界\">\n    <div class=\"last\">\n        你好世界\n    </div>\n    <script>\n        var div = document.querySelector('div');\n        var flag = 0;\n        div.onclick = function () {\n            if (flag == 0) {\n                div.className = 'chage';\n                flag = 1;\n            } else {\n                div.className = 'last';\n                flag = 0;\n            }\n        }\n    </script>\n</body>\n```\n\n{% endfolding %}\n\n1. 使用获取焦点和失去焦点的案例\n\n<span class=\"inline-tag\" style=\"--Color:#452cb5\">方法一</span>\n{% folding green, 查看答案 %}\n\n```html\n<style>\n    input {\n        width: 300px;\n        border-radius: 5px;\n        outline: none;\n        border: 1px solid #888;\n    }\n    .itab{\n        position: relative;\n        display: inline-block;\n        width: 100px;\n        height: 20px;\n        line-height: 20px;\n    }\n    .fa-exclamation-circle {\n        position: absolute;\n        display: none;\n        left: 0;\n        top:0;\n        font-size: 12px;\n        color: #0099ff;\n    }\n\n    .fa-times-circle {\n        position:absolute;\n        display: none;\n        left: 0;\n        top:12px;\n        font-size: 12px;\n        color: red;\n    }\n\n    i p {\n        display: inline-block;\n        font-size: 12px;\n        color: #888;\n    }\n</style>\n\n<body>\n    <input type=\"text\" name=\"\" id=\"\" placeholder=\"请输入密码\">\n    <div class=\"itab\">\n    <i class=\"fa fa-exclamation-circle\">\n        <p>6-16位字符</p>\n    </i>\n    <span class=\"fa fa-times-circle\">密码较短</span></div>\n    <script>\n        var input = document.querySelector('input');\n        var i = document.querySelector('i');\n        var span = document.querySelector('span')\n        input.onfocus = function(){\n            i.style.display = 'block';\n            span.style.display = 'none'\n        }\n        input.onblur = function(){\n            i.style.display = 'none';\n            span.style.display = 'block'\n        }\n    </script>\n```\n{% endfolding %}\n\n<span class=\"inline-tag\" style=\"--Color:#c3e88d\">方法二</span>\n\n{% folding green, 查看答案 %}\n\n```html\n<style>\n    input {\n        width: 300px;\n        border-radius: 5px;\n        outline: none;\n        border: 1px solid #888;\n    }\n\n\n    .fa-exclamation-circle {\n        color: #0099ff;\n        font-size: 12px;\n    }\n\n    .fa-times-circle {\n        color: red;\n        font-size: 12px;\n    }\n\n    .fa-check-circle {\n        color: green;\n        font-size: 12px;\n    }\n</style>\n\n<body>\n    <input type=\"password\" name=\"\" id=\"\" placeholder=\"请输入密码\" value=\"\">\n    <i class=\"fa\"></i>\n    <!-- <span class=\"fa fa-times-circle\">fa fa-check-circle密码较短</span></div> -->\n    <script>\n        var input = document.querySelector('input');\n        var i = document.querySelector('i');\n        input.onfocus = function () {\n            i.className = 'fa fa-exclamation-circle';\n            i.innerHTML = '请输入1-16位字符的密码';\n        }\n        input.onblur = function () {\n            if (input.value.length < 6 || input.value.length > 16) {\n                i.className = 'fa fa-times-circle';\n                i.innerHTML = '您输入的密码不符合要求，请输入1-16位字符'\n            }\n            else {\n                i.className = 'fa fa-check-circle';\n                i.innerHTML = '您输入的密码正确！！'\n            }\n        }\n    </script>\n\n</body>\n```\n{% endfolding %}\n\n## 排他思想\n\n1. 原理：所有元素清除样式，给所有元素设置样式\n\n{% folding green, 经典案例 %}\n\n\n```html\n    <button>按钮1</button>\n    <button>按钮2</button>\n    <button>按钮3</button>\n    <button>按钮4</button>\n    <button>按钮5</button>\n    <script>\n        var btns = document.getElementsByTagName('button');\n        for(var i = 0;i<= btns.length - 1;i++){\n            btns[i].onclick = function(){\n                for(i = 0;i<btns.length;i++){\n                    btns[i].style.backgroundColor = '';\n                }\n                this.style.backgroundColor = 'pink';\n            }\n        }\n    </script>\n```\n{% endfolding %}\n\n## 鼠标经过离开\n\n1. `onmouseover`鼠标经过\n2. `onmouseout`鼠标离开","categories":["web","Javascript"]},{"title":"JavaScript的知识整理（8）","url":"/posts/57816/","content":"\n<div class='tip font5 fas fa-atom faa-horizontal animated'><p>简单类型与复杂类型，webAPIs，DOM<p></div>\n\n## 简单数据类型\n\n1. 值类型，String,number,null,....undefined,boolean\n2. null返回的是`空的Object`  typeof\n\n## 复杂数据类型\n\n1. Object,Array,Date，通过new关键词生成的\n2. 堆：存放复杂数据类型，首先将变量名存放到简单数据类型，然后将数据存放到堆里面\n3. 栈：存放简单数据类型，存放的是简单数据类型的值，里面直接开辟一个空间\n\n## 简单数据类型传参\n\n1. 函数的形参可以看作一个变量\n2. 将变量在栈空间里保存的堆地址复制给了形参，形参和实参其实是同一个堆地址\n\n## webAPIs\n\n1. DOM和BOM是webAPIs所独有的部分\n2. API 预先定义的函数，webAPIs是很多方法\n\n\n## DOM\n\n1. 文档对象模型，是编程接口，可以修改网页内容格式样式\n2. 文档 `document`，`element`元素，`node`节点(标签，属性，文本，标签)\n\n## 获取元素\n\n1. 根据ID获取, `document.getEelementById(id)`\n2. `console.dir`返回的是标签和属性名\n\n## 根据标签名获取\n\n1. `getELementByTagName('字符串')`返回的是获取过来元素对象的集合，以伪数组的形式存储的\n2. 通过`for`遍历的方式将里面的元素打印出来\n3. 如果页面中只有一个元素，返回的还是伪数组形式，没有元素返回的是元素为空的空数组、\n4. 指定父元素`element.getElementsByTagName('字符串标签');在获取某个元素，获取的时候不包括父元素自己，必须指定标签对象\n\n{% folding green, 查看实例 %}\n\n```html\n    <div id=\"time\">\n        <li>77</li>\n        <li>77</li>\n        <li>77</li>\n        <li>77</li>\n        <li>77</li>\n        <li>77</li>\n        <li>77</li>\n    </div>\n    <ol id=\"ol\">\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n    </ol>\n    <script>\n        var ol = document.getElementById('ol');\n        console.log(ol.getElementsByTagName('li'));\n        var ol1 = ol.getElementsByTagName('li')\n        for(var i = 0; i<=ol1.length - 1; i++){\n            console.log(ol1[i]);\n        }\n    </script>\n```\n\n{% endfolding %}","categories":["web","Javascript"]},{"title":"自定义邮箱模板，邮箱回复，卡片模式","url":"/posts/52972/","content":"\n\n## 1.仓库介绍\n\n>此仓库为邮箱回复模板，卡片形式\n>使用请保留作者信息，谢谢⭐\n>仓库地址：【[email](https://github.com/Rr210/emailformwork)】\n\n- 我的博客地址：【[Harry](https://u.mr90.top)】\n\n## 2.演示图例\n\n{% folding green, 自定义通知邮件模板 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/9dhaada.png)\n{% endfolding %}\n\n{% folding green, 自定义博主通知邮件主题 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/9daihdadjadw.png)\n{% endfolding %}\n\n## 3.模板介绍\n\n1. `index1.html`为自定义通知邮件模板\n2. `index.html`为自定义博主通知邮件主题\n3. `textarea`文件中自定义回复是以textarea标签写的，兼容性较差\n\n## 4.模板使用\n\n1. 此邮箱模块试用于【[twikoo](https://twikoo.js.org/)】等等\n2. 修改`变量`可适配其他的评论框架\n\n## 5.版权\n\n- 使用 [GPL V2.0](https://github.com/Rr210/emailformwork/blob/master/LICENSE) 协议开源。\n\n\n","categories":["技术·教程"]},{"title":"JavaScript的知识整理（7）","url":"/posts/34224/","content":"\n\n<div class='tip error faa-horizontal animated'><p>数组转换,字符串，数组转换，字符串转换<p></div>\n\n## 字符串\n\n1. 数组名.toString();将数组转化为字符串\n2. 数组名.join(分隔符),将数组使用分隔符分开\n\n### 字符串的不可变性\n\n>字符串不可变性不要大量拼接字符串\n\n## 基础包装类型\n\n1. 把简单数据类型包装成了复杂数据类型\n2. 把临时变量的值给str\n3. 销毁这个临时变量\n\n## 字符串对象\n\n> 数组名.indexOf('查找的字符', [起始的位置]);从起始位置开始查找\n\n1. 查找字符串中某个元素出现的位置及其字数\n2. 原理：先查找第一个元素出现的位置\n3. 只要indexOf返回的结果不是-1就往后继续往后查找\n4. 因为indexOf只能查找到第一个，所以后面的查找，一定是当前索引号加1\n\n{% folding green, 查看答案 %}\n\n```js\n\n    var str = 'abiosabsabsaebasxabsab';\n    var index = str.indexOf('a');\n    var num = 0;\n    while (index != -1){\n        console.log(index);\n        index = str.indexOf('a', index +1);\n        num++;\n    }\n    console.log('出现的次数为'+num);\n```\n\n{% endfolding %}\n\n## 根据位置返回字符\n\n1. 字符名.charAt(索引值)；可以根据位置返回字符\n2. 字符名.charCodeAt(索引号)；返回的使相应索引号字符的ASCII码值\n3. 字符名[索引值]，指定位置\n\n- 判断一个字符串‘dadadacasawfefsxDugkgdkada'中出现次数最多的字符，并提交其次数\n\n{% folding green, 查看答案 %}\n\n```js\n    var str = 'dadsdadjihoihbaadhhzahizjcanadasj';\n    var o = {};\n    for (var i = 0; i <= str.length; i++) {\n        var chars = str.charAt(i);\n        if (chars in o) {\n            o[chars]++;\n        }\n        else {\n            o[chars] = 1;\n        }\n    }\n    console.log(o);\n    var max = 0;\n    var ch = '';\n    for (var k in o){\n        if(o[k]>max){\n            max = o[k];\n            ch = k;\n        }   \n    }\n    console.log('输出字符最多的次数为：'+max+'次');\n    console.log('输出次数最多的字符为：'+ch);\n```\n\n{% endfolding %}\n\n## 字符串的操作方法\n\n1. 字符名.cancat('字符串')，实现字符串的相加\n2. 字符名.substr(strat索引号,区字符的长度)\n3. 替换字符 字符名.replace('被替换的字符'，'替换为的字符')；\n4. 字符转换为数组 \n\n<span class=\"inline-tag\" style=\"--Color:#35847c\">使用while循环</span>\n\n{% folding green, 查看实例 %}\n\n```js\n    var str = 'dawdsadwasdaadadadw';\n    while (str.indexOf('d') != -1) {\n        str = str.replace('d', '*')\n    }\n    console.log(str);\n```\n\n{% endfolding %}\n\n<span class=\"inline-tag\" style=\"--Color:#ce3412\">使用for循环</span>\n\n{% folding green, 查看实例 %}\n\n```js\n    var str = 'dawdsadwasdaadadadw';\n    for (var i = 0; i <= str.length; i++) {\n        if(str.indexOf('d') != -1){\n            str = str.replace('d', '*')\n        }\n    }\n    console.log(str);\n```\n\n{% endfolding %}\n\n## 字符转换为数组\n\n1. 字符名.split(',')；可以使用不同的分隔符分开\n2. join()数组转换为字符块\n3. toUpperCase，toLowerCase()  大写小写\n\n\n{% folding green, 查看实例 %}\n\n```js\n var str = 'abaasdffggghjkkfssss3444343'\n    // console.log(str.length);\n    // var i = prompt('请输入要取出的字符索引号：');\n    // var s = prompt('请输入要查询的字符：');\n    // alert('使用类似返回数组的方法返回字符为：'+str[i]+'\\n使用另一种charAt()返回字符为：'+str.charAt(i));\n    // if(str.indexOf(s) != -1){\n    //     alert('您输入字符存在')\n    // }\n    // else{\n    //     alert('您输入的字符不存在')\n    // }\n    // for(var i = 0; i<=str.length;i++){  \n    //     str = str.replace('g','22');\n    //     str = str.replace('ss', 'b');\n    // }\n    // alert(str);\n    // var str1 = str.substr(3, 3)\n    // alert(str1)\n    var o = {};\n    for (var i = 0; i <= str.length; i++) {\n        var chars = str.charAt(i);\n        if (chars in o) {\n            o[chars]++;\n        }\n        else {\n            o[chars] = 1;\n        }\n    }\n    console.log(o);\n    var max = 0;\n    var ch = '';\n    for (var k in o){\n        if(o[k]>max){\n            max = o[k];\n            ch = k;\n        }   \n    }\n    console.log('输出字符最多的次数为：'+max+'次');\n    console.log('输出次数最多的字符为：'+ch);\n```\n\n{% endfolding %}","categories":["web","Javascript"]},{"title":"JavaScript的知识整理（6）","url":"/posts/17777/","content":"\n\n<div class='tip warning faa-horizontal animated'><p>Date函数，数组对象，数组索引，数组添加删除，数组排序，**数组去重**<p></div>\n\n## 函数Date\n\n1. 注意月份要+1，可以使用数组进行选择中文日期格式\n\n{% folding green, 实例演示 %}\n\n```js\n    var date = new Date();\n    function getTimer() {\n        var time = new Date();\n        var h = time.getHours();\n        h = h < 10 ? '0' + h : h;\n        var m = time.getMinutes();\n        m = m < 10 ? '0' + m : m;\n        var s = time.getSeconds();\n        s = s < 10 ? '0' + s : s;\n        return h + ':' + m + ':' + s\n    }\n    console.log(getTimer());\n```\n\n{% endfolding %}\n\n2. 获取毫秒数(时间戳)\n- valueOf()\n- getTime()\n- +new Date()\n- Date.now()\n\n{% folding green, 查看实例 %}\n\n```js\n    function countDown(time) {\n        var nowdate = +new Date();\n        var inputdate = +new Date(time);\n        var times = (nowdate - inputdate) / 1000;\n        var d = parseInt(times / 60 / 60 / 24);\n        d = d < 10 ? '0' + d : d;\n        var h = parseInt(times / 60 / 60 % 24);\n        h = h < 10 ? '0' + h : h;\n        var m = parseInt(times / 60 % 60);\n        m = m < 10 ? '0' + m : m;\n        var s = parseInt(times % 60);\n        s = s < 10 ? '0' + s : s;\n        return d + '天' + h + '时' + m + '分' + s + '秒';\n    }\n    console.log(countDown('2021-2-10 19:00:20'));\n```\n\n{% endfolding %}\n\n## 数组对象\n\n1. 字面量方式`var arr = [1,2,3];`\n2. 通过`new Array()`\n- var arr1 = new Array(2), 表示数组的长度为2，里面有两个空的数组元素\n\n3. 检测是否为数组`if (数组名 instanceof Array{}`\n- Array.isArray(检测数组名)；//返回逻辑值\n\n\n## 添加删除数组\n\n1. `数组名.push()`,在数组末尾，可以可数组追加新的元素,push完之后返回的结果时新数组的长度\n2. `数组名.unshift()`在数组的开头添加数组元素,完之后返回的结果时新数组的长度\n3. `数组名.pop()`可以删除数组的最后一个元素，执行完返回所删除的元素\n4. `数组名.shift()`删除数组元素的第一个\n\n{% folding green, 筛选数组实例 %}\n\n```js\n    var newarr = [];\n    function arr1(arr) {\n        for (var i = 0; i < arr.length - 1; i++) {\n            if (arr[i] > 2000) {\n                newarr.push(arr[i]);\n            }\n        }\n        return newarr;\n    }\n    arr1([2131, 312412, 412321, 321, 21])\n    console.log(newarr);\n```\n\n{% endfolding %}\n\n## 数组排序\n\n1. `数组名.reverse()`使数组翻转\n2. `数组名.sort()`使数组排序 ，针对个位数\n\n\n{% folding green, 查看sort %}\n\n```js\n    var arr1 = [1, 31, 124, 1, 233, 63, 212]\n    arr1.sort(function (a, b) {\n        // return a - b;\n        return b - a;\n    })\n    console.log(arr1);\n```\n\n{% endfolding %}\n\n## 数组索引\n\n1. `数组名.indexOf(索引的数组)`,返回满足第一个条件的索引号，找不到返回-1\n2. `数组名.lastindexOf(索引的数组)`从后面进行索引\n\n## 数组去重*\n\n1. 原理：把数组中不重复的元素放到新的数组中\n2. 遍历旧的数组，拿着旧的数组元素去查询新数组，如果新的数组不存在就添加进去，存在就不添加\n3. 使用indexOf()函数 如果新的数组返回的值为-1，将旧数组中的元素加入，否则不加\n4. 使用for循环和push()函数\n\n{% folding green, 查看答案 %}\n\n```js\n    function unique(arr) {\n        var newarr = [ ];\n        for (var i = 0; i <= arr.length - 1; i++) {\n            if(newarr.indexOf(arr[i]) === -1){\n                newarr.push(arr[i]);\n            }\n        }\n        return newarr;\n    }\n    var demo = unique(['a', 'a', 'd', 'd', 's', 'r', 'c', 'c'])\n    console.log(demo);\n```\n\n{% endfolding %}\n\n","categories":["web","Javascript"]},{"title":"JavaScript的知识整理（5）","url":"/posts/19930/","content":"\n<div class=\"tip ban font5 fas fa-ban faa-horizontal animated\"><p>构造函数，遍历对象，内置对象</p><p></p></div>\n\n## 构造函数\n\n1. 将对象里面相同的属性和方法抽象出来封装到函数里面\n2. 构造函数首字母要大写\n3. 构造函数必须使用new，只要调用new就创建了一个对象\n\n{% folding green, 查看答案 %}\n\n```js\n    function Star(uname) {\n        this.name = uname;\n        this.sing = function(sang){\n            console.log(sang);\n        }\n    }\n    var ldh = new Star('ldh')\n    console.log(typeof ldh);\n    console.log(ldh.name);\n    ldh.sing('你好') \n```\n{% endfolding %}\n\n## 遍历对象\n\n1. `for..in`格式`for(变量in 对象){}`\n\n{% folding green, 查看答案 %}\n\n```js\n    var momo = {\n        age: 18,\n        name: '你好'\n    }\n    for (var k in momo) { /*k变量 输出得到的是属性名*/\n        console.log(k);\n        console.log(momo[k]);\n    }\n```\n{% endfolding %}\n\n2. 创建一个电脑对象,有颜色,有重量,有品牌,有型号,可以看电影,可以听音乐,可以打游戏,可以敲代码\n\n<span class=\"inline-tag\" style=\"--Color:#068E98\">使用系统自带的构造函数创建对象</span>\n\n{% folding green, 查看答案 %}\n\n```js\n// 创建对象\nvar computer = new Object();\n// 为对象添加属性\n    computer.color = '灰色';\n    computer.weight = '2kg';\n    computer.brand = 'lenovo';\n    computer.type = 'xiaoxin';\n// 为对象添加方法\n    computer.movie = function(){\n        console.log('看电影');\n    }\n    computer.music = function(){\n        console.log('听音乐');\n    }\n    computer.play = function(){\n        console.log('玩游戏');\n    }\n    computer.Kcode = function(){\n        console.log('敲代码');\n    }\n//调用对象属性\n    console.log('我的颜色是'+computer.color );\n    console.log('我的重量是'+computer.weight);\n    console.log('我的品牌是'+computer.brand);\n    console.log('我的类型是'+computer.type);\n//调用对象方法\n    computer.movie();\n    computer.music();\n    computer.play();\n    computer.Kcode();\n```\n\n{% endfolding %}\n\n<span class=\"inline-tag\" style=\"--Color:#065598\">自定义构造函数创建对象</span>\n\n{% folding green, 查看答案 %}\n\n```js\n    function Computer(color, weight, brand, type) {\n        this.color = color;\n        this.weight = weight;\n        this.brand = brand;\n        this.type = type;\n        var re = ('这台' + this.color + ',重量为' + this.weight + '的' + this.type)\n        this.movie = function () {\n            console.log(re + '可以看电影');\n        },\n            this.game = function () {\n                console.log(re+ '可以打游戏');\n            },\n            this.Kcode = function () {\n                console.log(re+ '可以敲代码');\n            }\n    }\n    var com = new Computer('灰色', '2kg', 'lenovo', '小新');\n    com.movie();\n    com.game();\n    com.Kcode();\n\n```\n\n{% endfolding %}\n\n<span class=\"inline-tag\" style=\"--Color:#985A06\">使用字面量形式创建对象</span>\n\n{% folding green, 查看答案 %}\n\n```js\n    var computer2 = {\n        color: '灰色',\n        weight: '2kg',\n        brand: 'lenovo',\n        type: '小新',\n        movie: function () {\n            console.log('这台' + this.color + ',重量为' + this.weight + '的' + this.type + '电脑可以看电影');\n        },\n        game: function () {\n            console.log('这台' + this.color + ',重量为' + this.weight + '的' + this.type + '可以打游戏');\n        },\n        write: function () {\n            console.log('这台' + this.color + ',重量为' + this.weight + '的' + this.type + '可以敲代码');\n        }\n    }\n    // 使用for..in便利对象和方法\n    for (var k in computer2) {\n        console.log(computer2[k]);\n    }\n    // 调用方法\n    computer2.movie();\n    computer2.game();\n    computer2.write();\n```\n{% endfolding %}\n\n## 回顾练习\n\n1. 写一个函数,实现反转任意数组。\n\n{% folding green, 查看答案 %}\n\n```js\n\nfunction reverse(arr){\n    var newArr = [];\n    for(var i = arr.length - 1; i >= 0; i--){\n        newArr[newArr.length] = arr[i];\n    }\n    return newArr;\n}\nvar arr1 = reverse([1,2,31,412,3124])\nconsole.log(arr1)\n/*如果使用arguments的话后面的赋值不需要加`[]`*/\n```\n\n{% endfolding %}\n\n2. 写一个函数,实现对数组的排序。\n\n{% folding green, 查看答案 %}\n\n```js\n    function sort(num){\n        for(var i = 0; i<=num.length -1; i++){\n            for(var j=0;j<=num.length -i-1;j++){\n                if(num[j]>num[j+1]){\n                var temp = num[j];\n                num[j] = num[j+1];\n                num[j+1]=temp;\n                }\n            }\n        }\n        return num;\n    }\n     var num1 = new sort([1,32141,212,23,12,21])\n     console.log(num1);\n```\n\n{% endfolding %}\n\n## 内置对象\n\n1. Math,Date,Array,String\n2. 数学属性  【[属性地址](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math)】\n3. 不是构造函数，直接使用\n4. 绝对值` Math.abs()`\n\n### 三个取整方法\n\n1. Math.floor()向下取整\n2. Math.ceil()向上取整\n3. Math.round()四舍五入\n\n### 随机数\n\n1. Math.random()\n2. 随机点名\n\n{% folding green, 查看答案 %}\n\n```js\n    function getRandom(min, max) {\n        return Math.floor(Math.random() * (max - min)) + min;\n    }\n    var arr = ['dasd', 'dasxaw', 'dasaxfa', '正读', '真弟弟'];\n    console.log(arr[getRandom(0, arr.length - 1)]);\n```\n{% endfolding %}\n\n3. 猜数字游戏\n\n{% folding green, 查看答案 %}\n\n```js\n    function getRandom(min, max) {\n        return Math.floor(Math.random() * (max - min)) + min;\n    }\n    var random = getRandom(1, 50);\n    while (true) {\n        for (var i = 1; i <= 10; i++) {\n            var num = prompt('你来猜，请输入一个1-50的数字');\n            if (num > random) {\n                alert('提示：您猜大了！！' + '\\n' + '您还有' + (10 - i) + '次机会');\n            } else if (num < random) {\n                alert('提示：你猜小了！！' + '\\n' + '您还有' + (10 - i) + '次机会')\n            } else if (num == random) {\n                alert('恭喜你猜对了');\n                break;\n            }\n        } break;\n    }\n```\n\n{% endfolding %}\n\n### 日期对象\n\n1. 日期对象是一个构造函数 `var date = new Date()`;\n2. 数字写法`,`字符串写法`2021-1-1 0:0:0`\n\n{% folding green, 查看答案 %}\n\n```js\nvar date = new Date();\nconsole.log(date);\nconsole.log(date.getFullYear());\nconsole.log(date.getMonth() + 1);\nconsole.log(date.getDate());\nconsole.log(date.getDay());\n```\n{% endfolding %}\n\n","categories":["web","Javascript"]},{"title":"JavaScript的知识整理(4)","url":"/posts/39928/","content":"\n\n## arguments的作用\n\n1. 具有数字的length属性\n2. 按照索引的方式进行存储的\n3. 他没有真正数组的一些方法pop()push()等等\n4. 里面村粗了所有传递过来的实参,伪数组\n5. 只有函数才有arguments对象\n\n## arguments的使用\n\n1. 利用函数求任意个数的最大值\n\n{% folding green, 查看答案 %}\n\n\n```js\n    function getMax(){\n        var max = arguments[0];\n        for(var i = 1; i <= arguments.length; i++){\n            if (arguments[i] > max){\n                max = arguments[i];\n            }\n        }\n        return max;\n    }\n    console.log(getMax(1,2,31,231,3,21,412,12));\n```\n\n{% endfolding %}\n\n2. 翻转数组\n\n{% folding green, 查看答案 %}\n\n```js\n    function reverse(arr){\n        var newArr = [];\n        for(var i = arr.length - 1; i >= 0; i--){\n            newArr[newArr.length] = arr[i];\n        }\n        return newArr;\n    }\n    var arr1 = reverse([1,2,31,412,3124])\n    console.log(arr1)\n```\n\n{% endfolding %}\n\n3. 冒泡排序\n\n{% folding green, 查看答案 %}\n\n```js\n function sort(arr){\n     for(var i = 0; i < arr.length -1; i++){\n         for(var j = 0; j <= arr.length - i - 1; j++){\n             if (arr[j]>arr[j+1]){\n                 var temp = arr[j];\n                 arr[j] = arr[j+1];\n                 arr[j+1] = temp;\n             }\n         }\n     }\n     return arr;\n }\nvar arr1 = sort([2,121,411,2312,51,312,12,31,3,12,3,12412]);\nconsole.log(arr1);\n```\n{% endfolding %}\n\n4. 闰年函数封装\n\n{% folding green, 查看答案 %}\n\n```js\n  function isRunYear(year){\n      var flag = false;\n      if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0){\n          flag = true;\n      }\n      return flag;\n  }\n  console.log(isRunYear(2000));\n  console.log(isRunYear(1999));\n```\n{% endfolding %}\n\n4. 判断年份的2月份天数,函数封装\n\n{% folding green, 查看答案 %}\n\n```js\n function backDay(){\n    var year = prompt('请输入年份');\n    if (isRunYear()){\n        alert('您输入的年份'+year+'年'+'是闰年，2月份有29天')\n    }else{\n        alert('您输入的年份'+year+'年'+'是平年2月份有28天')\n    }\n }\n backDay();\n function isRunYear(year){\n      var flag = false;\n      if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0){\n          flag = true;\n      }\n      return flag;\n  }\n```\n\n{% endfolding %}\n\n\n## 函数声明方式\n\n1. 利用函数关键字自定义函数(命名函数)`function fn(){}`\n2. 函数表达式I(匿名函数)`var fn = function(){}`\n- 函数表达式里面存的是函数\n- 函数表达式也可以进行传递参数\n\n\n## 作用域\n\n1. 代码名字变量在某个范围内起作用和效果目的是为了提高程序的可靠性\n2. 更重要的是`减少命名冲突`\n3. 全局作用域,局部作用域\n4. 全局变量,在全局作用下的变量 在全局下都可以使用,`如果在函数内部不声明直接使用`属于全局变量,全局变量比较占内存资源\n5. 局部作用 在局部作用域下的变量,只能在函数内部输出,函数形参也可以看做局部变量\n6. 块级作用域 `if{} for{}`\n\n<span class=\"inline-tag grey\">全局作用域</span>\n\n>整个script,或者在一个单独的文件\n\n<span class=\"inline-tag grey\">局部作用域</span>\n\n>在函数内部起效果\n\n\n## 作用域链\n\n1. `内部函数`访问`外部函数`的变量,采取的是`链式查找`的方式来决定取值\n2. 就近原则\n\n## 预解析\n\n1. js引擎运行: 预解析 代码执行\n2. 把所有的var和funtion提升到当前作用域的最前面\n3. 从上到下执行\n4. 预解析 分为变量预解析,函数预解析\n5. 变量提升: 不提升赋值\n6. 函数提升: 不调用函数\n7. 函数表达式,调用必须写在函数表达式下面\n\n{% folding green, 域解析经典案例 %}\n\n```js\n    f1();\n    console.log('c'+c);\n    console.log('b'+b);\n    console.log('a'+a);\n    function f1() {\n        var a = b = c = 9;  /*相当于var a = 9; b=9; c=9;b和c未定义,为全局变量,a为局部变量,外面无法调用*/\n        console.log('a'+a);\n        console.log('b'+b);\n        console.log('c'+c);\n    }\n```\n{% endfolding %}\n\n## 对象\n\n1. 一组无序的相关属性和方法,属性十五的特征,方法事物的行为\n2. 创建对象,利用字面量` var obj = {}`键值对\n3. 方法冒号后面跟的是一个匿名函数\n4. 调用属性的方法` 对象名.属性名`  `对象名['属性名']`\n5. 调用对象的方法 `对象名.函数名`\n\n## 变量,属性,函数,方法的区别\n\n1. 变量 单独声明并赋值, 使用的时候直接写变量名,单独存在\n2. 属性 在对象里面的不需要声明,使用的时候必须是 对象.属性\n\n### 函数和方法\n\n1. 都是实现某种功能\n2. 函数是单独声明,并且 调用的 函数名() 单独存在的\n3. 方法 在对象里面调用的时候 对象.方法()\n\n## 创建对象\n\n1. 创建对象,利用字面量` var obj = {}`键值对\n2. 利用new Object创建对象`var obj = new Object();`\n3. 利用函数方法重复相同的代码 构造函数,把相同的属性和方法抽取出来封装到函数中\n4. 语法格式\n- 构造函数的\n\n{% folding green, 查看答案 %}\n```\nfunction 构造函数名(){\n\tthis.属性 = 值;\n\tthis.方法 = function(){}\n}\n```\n{% endfolding %}\n\n1. 写公共的属性,构造函数名字首字母要大写\n2. 我们构造函数不需要return,就可以返回结果,使用形参和实参,`new`生成对象\n3. 属性和方法前必须添加`this`\n4. 利用构造函数创建对象的过程称为`对象的实例化`\n\nnew\n\n1. 在内存中创建了一个新的空对象\n2. 让this指向这个新的对象\n3. 执行构造函数里面的代码,给这个新对象添加属性和方法\n4. 返回这个新对象,构造函数里面不需要return\n\n## 遍历对象\n\n1. for..in  `for(变量 in 对象){}`,一般使用k/key\n2. for..in语句用于对对象的属性进行循环操作","categories":["web","Javascript"]},{"title":"JavaScript的知识整理（3）","url":"/posts/50650/","content":"\n<div class=\"tip ban font5 fas fa-ban faa-horizontal animated\"><p>JavaScript函数,return语句的使用</p><p></p></div>\n\n## 函数\n\n1. 先声明函数在调用函数\n2. 函数的封装\n3. 可以利用函数的参数实现函数重复不同的代码\n- 在声明函数的小括号里面是形参，在函数调用的小括号里面是实参\n- 形参相当于变量\n- 参数的作用：在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去\n- 多个参数用`,`隔开\n- 形参是不用声明的变量\n- 如果实参的个数多于形参的个数不影响\n- 如果小于，变量不声明没有值为`undefined`\n\n## return语句\n\n1. 终止作用，只能返回一个值\n2. 返回多个值可以使用数组的方式\n3. 如果函数没有return返回undefined\n\n\n### 函数练习\n\n4. 利用函数求任意一个数值中的最大值\n\n{% folding green, 查看答案 %}\n\n```js\n   function getArray(arr){\n       var max = arr[0];\n       for(var i = 1; i < arr.length; i++){\n           if(arr[i] > max){\n               max = arr[i];\n           }\n       }\n       return max;\n    }\n    var re = getArray([12,341,433,314,1,3,4,1,312,1,4212]);\n    console.log(re);\n```\n\n{% endfolding %}\n\n5. 写一个函数,用户输入任意两个数字的任意算术运算(简单的计算器小功能) . 并能弹出运算后的结果。\n\n{% folding green, 查看答案 %}\n\n```js\n function getRe(num1, ope, num2){\n    var re1 = parseFloat(num1);\n    var re2 = parseFloat(num2);\n        switch(ope){\n            case '+':\n                return re1 + re2 ;\n                break;\n            case '-':\n                return re1 - re2;\n                break;\n            case '*':\n                return re1 * re2;\n                break;\n            case '/':\n                return re1 / re2;\n                break;\n            default:\n                return '您输入的符号有误，请重新输入';\n                break;\n        }\n    }\n    num1 = prompt('请输入要运算的第一个数字：');\n    num2 = prompt('请输入要运算的第二个数字：');\n    ope = prompt('请输入运算符（+，-，*，/）：');\n    alert('您输入的字符为：'+num1+ope+num2+'\\n'+'您的运算结果为：'+getRe(num1, ope, num2))\n```\n\n{% endfolding %}\n\n6. 写一个函数，用户输入任意两个数字的最大值，并能出弹运算后的结果。\n\n{% folding green, 查看答案 %}\n\n```js\n    function getCompare(num1, num2) {\n\n        if (parseFloat(num1) > parseFloat(num2)) {\n            var max = num1;\n        }\n        else {\n            max = num2;\n        }\n        return max;\n    }\n    num1 = prompt('请输入您要比较的第一个数字：');\n    num2 = prompt('请输入您要比较的第二个数字：');\n    alert('您要比较的两个字符为'+num1+','+num2+'\\n'+'最大值为：'+getCompare(num1, num2));\n```\n\n{% endfolding %}\n\n7. 写一个函数,用户输入任意三个不同数字的最大值,并能弹出运算后的结果。\n\n\n{% folding green, 查看答案 %}\n\n```js\n    function getCompare(num1, num2, num3) {\n        if (parseFloat(num1) > parseFloat(num2)) {\n            if (parseFloat(num1) > parseFloat(num3)) {\n                var max = num1;\n            } else {\n                max = num3;\n            }\n        }\n        else {\n            if (parseFloat(num2) > parseFloat(num3)) {\n                max = num2;\n            }\n            else {\n                max = num3;\n            }\n        }\n        return max;\n    }\n    num1 = prompt('请输入您要比较的第一个数字：');\n    num2 = prompt('请输入您要比较的第二个数字：');\n    num3 = prompt('请输入您要比较的第三个数字：');\n    alert('您要比较的三个字符为' + num1 + ',' + num2 + ',' + num3 + '\\n' + '最大值为：' + getCompare(num1, num2, num3));\n```\n\n{% endfolding %}\n\n8. 写一个函数,用户输入一个数判断是否是素数,并返弹出回值(又叫质数,只能被1和自身整数的数)\n\n<span class=\"inline-tag blue\">方法一</span>\n\n{% folding green, 查看答案 %}\n\n```js\n    function getPnum(pnum){\n        var n = 0;\n        /*i = 2，可以省略n变量*/\n        for(var i = 1; i <= parseFloat(pnum) / 2; i++){\n            if (pnum % i == 0){\n                n++;\n            }\n        }\n        if(n > 1){\n            return '您输入的数不是素数';\n        }\n        else{\n            return '您输入的数是素数';\n        }\n    }\n    pnum = prompt('请输入一个数字：');\n    alert(getPnum(pnum)+'\\n'+'您输入的数为'+pnum)\n```\n\n{% endfolding %}\n\n<span class=\"inline-tag\" style=\"--Color:#1d9384\">方法二</span>\n\n{% folding green, 查看答案 %}\n\n```js\n  function isPrime(num) {\n            for (var i = 2; i < num; i++) {\n                if (num % i == 0) {\n                    return num + '不是质数'\n                }\n            }\n            return num + '是质数'\n        }\nalert(isPrime(prompt('请输入一个数')));\n```\n\n{% endfolding %}","categories":["web","Javascript"]},{"title":"JavaScript知识整理（2）","url":"/posts/22781/","content":"\n\n<div class='tip error faa-horizontal animated'><p>循环案例，for/while/dowhile，数组的基础知识<p></div>\n\n## 循环\n\n1. 断点调试souce\n2. for循环重复执行不同代码\n3. for循环重复执行相同代码\n4. 重复执行某些操作\n\n## 简单例题\n\n<span class=\"inline-tag green\">for</span>   <span class=\"inline-tag red\">while</span>  <span class=\"inline-tag blue\">do while</span>\n\n1. 求1-100之间所有数的平均数\n\n{% folding green, 查看答案 %}\n\n```js\n   var sum = 0;\n   for(var i = 1;i<=100;i++){\n       sum = sum + i;       \n   }\n   var average = sum / 100;\n   console.log('1-100所有数的平均数为：'+avr);\n```\n```js\n    var sum =0;\n    var i = 1;\n    while(i <= 100){\n        sum += i;\n        i++;\n    }\n    alert('1-100的和为'+sum)\n```\n```js\n    var sum = 0;\n    var i = 1;\n    do{\n        sum += i;\n        i++;\n    }\n    while(i <= 100);\n    alert(sum)\n```\n\n{% endfolding %}\n\n2. 求1-100之间所有偶数和奇数的和\n\n{% folding green, 查看答案 %}\n\n```js\n    var even = 0;\n    var odd = 0;\n    for(var i =1; i <= 100; i++){\n        if (i % 2 == 0){\n            even = even + i;\n        }else{\n            odd = odd + i;\n        }\n    }\n    console.log('1-100所有偶数的和'+even);\n    console.log('1-100所有奇数的和'+odd);\n\n```\n\n{% endfolding %}\n\n3. 求1-100之间所有能被3整除的数字的和\n\n{% folding green, 查看答案 %}\n\n```js\n    var sum = 0;\n    for(var i = 1; i <= 100; i++){\n        if(i % 3 == 0){\n            sum += i;\n        }\n    }\n    console.log('1-100内能被3整除所有数的和：'+sum);\n```\n\n{% endfolding %}\n\n4. 学生成绩案例\n\n{% folding green, 查看答案 %}\n\n```js\n    var people = prompt('请输入班级的人数：');\n    var grade = 0;\n    var sum = 0;\n    for(var i = 1; i <= people; i++){\n        grade = prompt('请输入第'+i+'个同学的成绩');\n        sum += parseFloat(grade);\n    }\n    var average = sum / people;\n    alert('班级学生的总成绩为：'+sum);\n    alert('班级学生的平均成绩为：'+average);\n\n```\n\n{% endfolding %}\n\n<span class=\"inline-tag green\">双重for循环</span>\n4. 打印n行n列的⭐\n\n{% folding green, 查看答案 %}\n\n```js\n    var str = '';\n    var num = prompt('请输入要显示的⭐的行/列数：');\n    for(var i = 1; i <= num; i++){\n        for(var j = 1; j <= num; j++){\n            str += '⭐'\n        }\n        str += '\\n'\n    }\n    alert(str)\n\n```\n\n{% endfolding %}\n\n5. 打印n行n列每行依次减少一个的⭐（下三角）\n\n{% folding green, 查看答案 %}\n\n```js\n    var str = '';\n    var num = prompt('请输入要显示的⭐的行/列数：');\n    for(var i = 1; i <= num; i++){\n        for(var j = 1; j <= num - i + 1; j++){\n            str += '⭐'\n        }\n        str += '\\n'\n    }\n    alert(str)\n\n```\n\n{% endfolding %}\n\n6. 打印n行n列每行依次减少一个的⭐（上三角）\n\n{% folding green, 查看答案 %}\n\n```js\n    var row = prompt('请输入要输入的行/列数：');\n    var str = '';\n    for(i = 1; i <= row; i++){\n        for(j = 1; j<= i; j++){\n            str = str + '⭐';\n            //str += j + 'X' + i + '=' + i*j;\n        }\n        str += '\\n';\n    }\n    alert(str);\n```\n\n{% endfolding %}\n\n7. 求1-100之间，除了能被7整除之外的整数和\n\n{% folding green, 查看答案 %}\n\n```js\n    var sum = 0;\n    for(var i = 1; i <= 100; i++){\n        if(i % 7 == 0){\n            continue;\n        }\n        sum += i;\n    }\n    alert('1-100除了能被7整除的所数的和：'+sum)\n```\n\n\n\n{% endfolding %}\n\n8. 求1-100的累加值，但要求跳过所有的个数为3的数\n\n{% folding green, 查看答案 %}\n\n```js\n    var sum = 0;\n    for (var i = 1; i <= 100; i++){\n        if (i % 10 == 3){\n            continue;\n        }\n        sum += i;\n    }\n    alert('求1-100的累加值，但要求跳过所有的个数为3的数为：'+sum)\n```\n\n{% endfolding %}\n\n9. 银行存取钱js案例\n\n{% folding green, 查看答案 %}\n\n\n```js\n    while(true){\n    var cash = 100;\n    var content1 = prompt('请输入您要的操作(输入数字即可):\\n1.存钱\\n2.取钱\\n3.显示余额\\n4.退出');\n    switch(content1){\n        case '1':\n            var store = prompt('请输入存入的金额');\n            cash += parseFloat(store);\n            alert('您当前的金额为：' + cash + '元');\n            break;\n        case '2':\n            var fetch1 = prompt('请输入要取出的金额：');\n            while(parseFloat(fetch1) > cash){\n                fetch1 = prompt('您当前的余额为'+cash+'元，无法取出请您重新输入取出金额');\n                continue;\n            }\n            cash = cash - parseFloat(fetch1);\n            alert('您当前的金额为：' + cash + '元');\n            break;\n        case '3':\n            alert('您当前的金额为：' + cash + '元');\n            break;\n        case '4':\n            alert('您已退出');\n            break;\n        default:\n            alert('您输入的指令错误请重新输入');\n            break;\n    }\n}\n```\n\n```js\nvar money = 100;\n        while (true) {\n            var num = prompt('请输入您要进行的操作:' + '\\n' + '1.存钱' + '\\n' + '2.取钱' + '\\n' + '3.显示余额' + '\\n' + '4.退出');\n            if (num == '1') {\n                var add = parseFloat(prompt('输入存的钱数：'));\n                money += add;\n                alert('你现在的钱数是：' + money)\n            } else if (num == 2) {\n                var sub = parseFloat(prompt('输入取的钱数：'));\n                money -= sub;\n                alert('你现在的钱数是：' + money)\n            } else if (num == 3) {\n                alert('你现在的钱数是：' + money)\n            } else {\n                alert('正在退出...')\n                break\n            }\n        }\n```\n\n{% endfolding %}\n\n\n## 数组\n\n1. 利用new创建数组 `new Array()`\n2. 利用数组字面量创建数组`[]`\n\n### 数组的索引\n\n1. 索引号从0开始\n2. 数组名[索引]\n3. 数组长度，数组名.length(动态监测数组元素的个数)\n\n<span class=\"inline-tag\" style=\"--Color:#1d9384\">数组</span>\n\n1. 一组数求最大值/最小值，数组\n\n{% folding green, 查看答案 %}\n\n```js\n    var num = [1, 2, 2, 12, 312, 3124, 213,321];\n    var max = num[0];\n    var min = num[0];\n    for (var i = 1; i < num.length; i++){\n        if (num[i] > max){\n            max = num[i];\n        }else if(num[i] < min){\n            min = num[i];\n        }\n    }\n    alert('最大值为：'+max+'\\n'+'最小值为：'+min);\n```\n\n{% endfolding %}\n\n2. 筛选数组\n\n{% folding green, 查看答案 %}\n\n```js\n    var num = [1, 2, 2, 12, 312, 3124, 213,321];\n    var newArr = [];\n    var j = 0;\n    for (var i = 0; i < num.length; i++){\n        if (num[i] > 10){\n            newArr[j] = num[i];\n            j++;\n        }\n    }console.log(newArr);\n```\n{% endfolding %}\n\n3. 删除指定的数组元素\n\n{% folding green, 查看答案 %}\n\n```js\n    var num = [1, 2, 2, 12, 312, 3124, 213,321];\n    var newArr = [];\n    for (var i = 0; i < num.length; i++){\n        if (num[i] != 2){\n            newArr[newArr.length] = num[i];\n        }\n    }console.log(newArr);\n```\n\n{% endfolding %}\n\n4. 数值前后转换案例\n\n{% folding green, 查看答案 %}\n\n```js\n    var num = [1, 2, 2, 12, 312, 3124, 213,321];\n    var newArr = [];\n    for (var i = num.length - 1; i >= 0; i--){     \n            newArr[newArr.length] = num[i];\n    }\n    console.log(newArr);\n```\n{% endfolding %}\n\n5. 冒泡排序\n\n{% folding green, 查看答案 %}\n\n```js\n    var num = [1, 2, 12, 312, 3124, 213, 321];\n    var temp = 0;\n    for (var i = 0; i <= num.length - 1; i++){\n        for(var j = 0; j <= num.length - i - 1; j++){\n            if(num[j] < num[j + 1]){\n                temp = num[j];\n                num[j] = num [j + 1];\n                num[j + 1] = temp;\n            }\n        }\n    }console.log(num);\n\n```\n\n{% endfolding %}","categories":["web","Javascript"]},{"title":"JavaScript知识整理（1）","url":"/posts/49565/","content":"\n<div class=\"snote success faa-horizontal animated\"><p>C语言知识回顾</p></div>\n\n## Javascript基础\n\n- 是一种运行在客户端上的脚本语言（高级编程类语言） 解释形语言\n- js推荐使用单引号\n\n1. ECMAScript\n>规定了js的基础语法和基础核心知识\n2. DOM- 文档对象模型\n3. BOM-浏览器对象模型\n\n## Js输入输出语句\n\n1. prompt('输入框');\n2. alert('输出框')\n3. console.log('控制台')\n\n## Js变量\n\n1. 变量是用于存放数据的容器\n2. 本质:变量是程序在内存中申请的一块用来存放数据的空间\n\n### 变量的使用\n\n1. 声明变量\n2. 一个变量被重新赋值后,它原有的值就会被覆盖，变量值以最后一次赋的值为准\n3. 声明多个变量一个var,用逗号隔开\n4. **特殊情况**\n- 只声明不赋值，结果是 undefined\n- 不声明不赋值，报错\n- 不声明直接赋值，可以使用，`不提倡`，会变成全局变量\n5. 只允许 `$`和`_`符号，尽量使用驼峰命名法\n\n## 数据类型\n\n1. js的变量数据类型是只有程序在运行过程中，根据等号右边的值来确定的\n2. js是动态语言，变量的数据类型是可以变化的\n\n### 数字型Number\n\n1. 数字型进制 ，八进制0~7，八进制前写0\n2. 16进制 0~9 a~f 数字前加0x表示16进制\n3. Number.MAX.VALUE/MIN,最大值最小值\n4. Infinity无穷大  -Infinity无穷小\n5. NAN表示非数字，true/false\n\n### 字符串 String\n\n1. 在使用内嵌引号时，要符合外单内双，或者外双内单\n2. 转义符`\\n`换行  tab `\\t`\n3. 字符串的拼接 `+` 引引加加\n\n### 布尔 Bollean\n\n1. undefined + 1 = NAN\n2. null 是值为空\n\n## typeof检测数据类型\n\n1. console.log(typeof 变量)\n2. object 对象\n3. prompt所取的值是字符串\n\n### 字符串转换\n\n<span class=\"inline-tag blue\">转换字符型</span>\n\n1. toString()\n2. 强制转换String(num)\n3. 加号拼接字符串\n\n<span class=\"inline-tag blue\">转换数字型</span>\n\n1. parseInt(变量/'字符')\n2. 可以使用parseInt去掉单位,数字开头\n3. parseFloat()可转化小数\n4. Number()强制转换\n5. 利用算数 `-`  `*`  `/` 隐式转换\n\n## 运算符\n\n1. 算数运算符\n- 浮点数有精度问题\n2. 递增和递减运算符\n3. 比较运算符\n-  '=='会把字符串的转化为数字型\n-  '==='全等不转化\n3. 逻辑运算符\n- 逻辑中断（短路运算）\n4. 赋值运算符\n\n## 流程控制\n\n1. 顺序，分支，结构\n2. 分支if条件\n\n{% folding green, 查看if条件代码 %}\n\n```js\n    <script>\n        main();\n        function main(){        \n        var like = prompt('你喜欢我吗?');\n        if (like == '喜欢'){\n            alert(\"我也喜欢你\")\n        }            \n        else{\n            prompt('你确定吗?')\n            alert('再给你一次机会，希望你不要不识抬举')\n            main();\n        }           \n        }\n    </script>\n```\n\n{% endfolding %}\n\n3. 三元表达式  `条件 ？ ：`\n4. swith(){case n: \\n; break;}  全等\n\n\n## 循环\n\n> for(初始化变量，判断条件，操作表达式)","categories":["web","Javascript"]},{"title":"CSS3知识回顾（13）+(git commit)规范写法","url":"/posts/20691/","content":"\n<div class=\"tip important font5 fas fa-home faa-horizontal animated\"><p>包括git commit -m \"git message\"规范化使用等等，还有CSS3响应式笔记,Bootstrap基础</p><p></p></div>\n\n\n## git指令\n\n1. git --version 查看git版本\n2. git diff 比较文件的不同，及暂存区（staging area）和工作区(workspace)的差异\n\n### git commit的规范化\n\n>格式：`<type>(<scope>):<subjext>`\n\n{% folding green, type类别说明 %}\n\ntype(必须)\n```\nfeat：新功能（feature）。\nfix/to：修复bug，可以是QA发现的BUG，也可以是研发自己发现的BUG。\nfix：产生diff并自动修复此问题。适合于一次提交直接修复问题\nto：只产生diff不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix\ndocs：文档（documentation）。\nstyle：格式（不影响代码运行的变动）。\nrefactor：重构（即不是新增功能，也不是修改bug的代码变动）。\nperf：优化相关，比如提升性能、体验。\ntest：增加测试。\nchore：构建过程或辅助工具的变动。\nrevert：回滚到上一个版本。\nmerge：代码合并。\nsync：同步主线或分支的Bug。\n```\n\n{% endfolding%}\n\n{% folding green, scope类别说明 %}\n\nscope(可选)\n\n```\nscope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。\n例如在Angular，可以是location，browser，compile，compile，rootScope， ngHref，ngClick，ngView等。如果你的修改影响了不止一个scope，你可以使用*代替。\n```\n\n{% endfolding %}\n\n## 查看信息\n\n{% folding green, 查看信息 %}\n\n1. #显示有变更的文件\n```\ngit status\n```\n\n2. #显示当前分支的版本历史\n```\ngit log\n```\n\n3. #显示commit历史，以及每次commit发生变更的文件\n```\ngit log --stat\n```\n\n4. #搜索提交历史，根据关键词\n```\ngit log -S [keyword]\n```\n\n5. #显示某个commit之后的所有变动，每个commit占据一行\n```\ngit log [tag] HEAD --pretty=format:%s\n```\n\n6. #显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n```\ngit log [tag] HEAD --grep feature\n```\n\n7. #显示某个文件的版本历史，包括文件改名\n```\ngit log --follow [file]\ngit whatchanged [file]\n```\n8. #显示指定文件相关的每一次diff\n```\ngit log -p [file]\n```\n\n9. #显示过去5次提交\n```\ngit log -5 --pretty --oneline\n```\n\n10. #显示所有提交过的用户，按提交次数排序\n```\ngit shortlog -sn\n```\n\n11. #显示指定文件是什么人在什么时间修改过\n```\ngit blame [file]\n```\n\n12. #显示暂存区和工作区的差异\n```\ngit diff\n```\n\n13. #显示暂存区和上一个commit的差异\n```\ngit diff --cached [file]\n```\n\n14. #显示工作区与当前分支最新commit之间的差异\n```\ngit diff HEAD\n```\n\n15. #显示两次提交之间的差异\n```\ngit diff [first-branch]...[second-branch]\n```\n\n16. #显示今天你写了多少行代码\n```\ngit diff --shortstat \"@{0 day ago}\"\n```\n\n17. #显示某次提交的元数据和内容变化\n```\ngit show [commit]\n```\n\n18. #显示某次提交发生变化的文件\n```\ngit show --name-only [commit]\n```\n\n19. #显示某次提交时，某个文件的内容\n```\ngit show [commit]:[filename]\n```\n\n20. #显示当前分支的最近几次提交\n```\ngit reflog\n```\n\n{% endfolding %}\n\n## 响应式布局\n\n1. 布局之前需要一个布局容器\n2. 从小到大\n\n## Bootstrap前端框架\n\n- 使用【[Bootstrap](https://www.bootcss.com/)】框架\n\n### 栅格系统（grip system）\n\n1. 将容器分为12等分，container\n2. 在使用row/column时`col-lg-n`  n相加等于12\n\n{% folding green, 查看属性  %}\n\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/39973dgagdghah.webp)\n\n{% endfolding %}\n\n3. 列嵌套加一个行row消除内边距\n4. 列偏移offset-(12-n)\n5. 列排序 push，pull\n\n### 响应式工具\n\n1. hidden-xs,hidden-sm,hidden-md,hidden-lg\n2. visible显示","categories":["web","css"]},{"title":"给你的博客顶部添加灯笼特效，牛气冲天","url":"/posts/8914/","content":"\n<div class=\"tip socd font5 fas fa-bell faa-horizontal animated\"><p>给你的博客顶部添加灯笼特效，CSS3</p><p></p></div>\n\n## 查看效果\n\n![](https://7.dusays.com/2021/02/03/21a146a79535d.gif)\n\n- 演示站点： [点击这里](https://rbozo.gitee.io/lantern/)\n\n## 自定义内容\n\n1. 可自定义灯笼`字体`\n```css\n/* 修改灯笼的字体 */\n.d-box .d1::after{\n    content: '牛年吉祥';}\n.d-box1 .d1::after{\n    content: '万事顺利';\n}\n```\n2. 可自定义灯笼`大小,位置`\t\n```css\n.d-box{\n    position: fixed;\n    width: 330px;\n    /* 自定义灯笼的位置 */\n    right: 0;\n    top: 0;\n    /* 自定义灯笼大小 */\n    transform: scale(0.8);\n}\n.d-box1{\n    position: fixed;\n    width: 330px;\n    /* 自定义灯笼的位置 */\n    left: 0;\n    top: 0;\n    /* 自定义灯笼大小 */\n    transform: scale(0.8);\n}\n```\n3. 适配移动端，可设置`隐藏`，或者显示一个/调节`灯笼的大小`，`默认一个`\n4. 可自定义灯笼的`阴影颜色,大小`\n\n## Butterfly主题使用方法\n\n1. 打开主题文件夹找到`\\themes\\butterfly\\layout\\includes\\header\\nav.pug`\n\n{% folding green, 加入以下代码 %}\n\n```\n.dengl\n   .d-box\n     .d1\n       span\n       span\n         p\n       ul\n         li\n         li \n         li\n           span\n         li \n         li \n     .d2\n       span\n       span\n         p\n       ul\n         li\n         li \n         li\n           span\n         li \n         li \n   .d-box1\n     .d1\n       span\n       span\n         p\n       ul\n         li\n         li \n         li\n           span\n         li \n         li \n     .d2\n       span\n       span\n         p\n       ul\n         li\n         li \n         li\n           span\n         li \n         li   \n```\n{% endfolding %}\n\n2. 引入`css`和`js`引入到页面或者直接去我的git仓库下载修改，已上传\n\n- 在`header`标签里面加入`<div class=\"dengl\"></div>`\n\n```html\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/gh/Rr210/Lantern@3.3/dl.css\">\n<script src=\"https://cdn.jsdelivr.net/gh/Rr210/Lantern@3.3/dl.js\"></script>\n```\n## 其他框架使用方法\n\n1. 将`baby`内的源码引入到`header`标签或者其他标签下即可,源码在下方git中\n2. 可能会出现兼容性问题，请【[留言](https://u.mr90.top/other/message/)】反馈谢谢\n\n## 源码如下\n\n- 已上传到Github【 [点击这里](https://github.com/Rr210/Lantern) 】\n- 码云Gitee【[点击这里](https://gitee.com/rbozo/Lantern)】","categories":["技术·教程"]},{"title":"使用PicGo+github+gitee制作图床","url":"/posts/45222/","content":"\n<div class='tip warning faa-horizontal animated'><p>国内好用的图床有好多，比如：七牛云，又拍云，公益图床，路过图床，SM.MS图床，聚合图床，腾讯云和阿里云oss，ImgURL</p></div>\n\n## 图床使用\n\n1. 我自己使用过的图床感觉比较好的，可长期发展的图床，就是Github图床还有国内的GitHub--码云gitee，当然其他图床也有他们的优势，比如又拍云和七牛云每个月都有免费的空间流量额度(缺点就是要有备案的域名)\n2. 当然腾讯云oss和阿里云oss作图床是更好的选择(土豪专属),虽然有免费的额度，但是如果是长期发展的不合适，额度规则是时刻变化的\n\n## 准备工作\n\n1. 首先安装好PicGo软件，快速上传图片并获取图片 URL 链接的工具【[下载地址](https://github.com/Molunerfinn/PicGo/releases)】\n2. GitHub或者gitee账号\n\n## Github图床\n\n1. 创建一个`公开`的GitHub仓库，然后点击右上角头像Settings里面找到`Developer settings`创建一个私人令牌`Personal access tokens`\n2. 新建一个私人令牌点击权限repo，记住生成的令牌token\n\n{% folding green, 查看图例 %}\n\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/1/9dasdhhausd.jpeg)\n\n{% endfolding %}\n\n## 配置PicGo\n\n1. PicGo的图床设置，Github设置--设定仓库名等等\n\n{% folding green, 查看图例 %}\n\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/9dasdhhausd.jpeg)\n\n{% endfolding %}\n\n{% folding green, 查看属性设置 %}\n\n|Github设置|设定内容|\n|:--:|:--:|\n|仓库名|用户名+仓库名|\n|设定分支名|master|\n|设定Token|私人令牌生成的Token|\n|指定存储路径|自定义|\n|*设定自定义域名|`https://cdn.jsdelivr.net/gh/仓库名@master`|\n\n{% endfolding %}\n\n2. 如何上传失败一般是token值的问题重新生成，填入即可\n\n## gitee配置\n\n- 看这个教程就可以【[gitee图床配置](https://cloud.tencent.com/developer/article/1622395)】\n\n","categories":["技术·教程"]},{"title":"CSS3知识回顾（12）","url":"/posts/20633/","content":"\n## rem布局\n\n1. `em`是父元素的大小,字符\n- 相对与`父元素`的字体大小\n2. `rem`的基准是相对于`html`的字体大小\n- 优势：可以通过修改html里面的文字大小来改变页面中的元素的大小来整体控制页面\n\n## 媒体查询\n\n1. 可以针对不同的屏幕的尺寸设置不同的样式\n\n```\n@media mediatype and|not|only(media feature){}\n```\n2. 媒体类型\n- all\n- print\n- scree(用于电脑屏幕，平板，手机)\n3. 关键字\n- and\n- not\n- only\n3. 媒体特性\n- max-width/min\n- `从小到大`写代码更简洁，使用层叠性\n4. 媒体查询+rem实现元素的动态变化\n5. 媒体查询引入资源link\n\n## less\n\n1. css的扩展语言，Sass,less,Stylus\n2. less变量\n- @color(变量名区分大小写)\n3. less编译 easy less\n4. less嵌套子元素的样式直接写道父元素里面就好了\n- 伪元素要加`&`\n5. 使用less运算方便计算（有空格隔开）\n- 运算过程中两个都有单位以第一个为准\n6. import在样式文件中相导入\n\n## rem适配方案\n\n1. 实现页面元素的自适应，实现等比缩放的适配\n2. rem适配方案`flexible.js`\n3. flexible.js在宽度超出750px后使用媒体查询，强制修改宽度为75px\n\n","categories":["web","css"]},{"title":"auto.js的学习笔记","url":"/posts/b562470d/","content":"\n<div class=\"tip wtgo font5 fas fa-bolt faa-horizontal animated\"><p>前段时间自己写了一个auto.js企业微信的打卡js,感觉auto.js特别有意思就想着学习学习，话不多说开干</p><p></p></div>\n\n## auto.js是什么\n\n>Auto.js使用JavaScript作为脚本语言，目前使用Rhino 1.7.7.2作为脚本引擎，支持ES5与部分ES6特性。\n\n## 学习笔记\n\n<span class=\"inline-tag grey\">简单整理</span>\n\n### 寻找控件\n\n{% folding green, 文本定位 %}\n\n```\nvar a=text(\"文本为所要定位的\").findOne();\nlog(a)//反馈到控制台consoles\na.click();//可单击控件位置\nsleep()//暂时休眠时间\n```\n{% endfolding %}\n\n1. findOne():表示基于某个条件找到一个符合条件的控件\n2. findOnce():只执行一次\n\n{% folding green, 文本框定位 %}\n\n```\nvar 文本框=className(\"EditText\").findOne();\nlog(文本框)//反馈到控制台consoles\n文本框.setText(\"设置定位到文本框的文字\")\n文本框.click();//可单击控件位置\nsleep()//暂时休眠时间\n```\n{% endfolding %}\n\n1. setText([i, ]text)\n2. input([i,]text)\n3. 例子`input(0,\"文本\")表示为第0个文本框输入的文字为\"\"`\n4. setClip和getClip 一个为设置剪切板的内容一个为返回\n\n{% folding green, 动态申请权限 %}\n\n1. //动态申请安卓的权限。例如：\n2. //请求GPS权限//access_fine_location GPS权限//record_audio 录音权限\n\n```\nruntime.requestPermissions([\"access_fine_location\"]);\n```\n\n{% endfolding %}","categories":["学习笔记","auto.js"]},{"title":"CSS知识回顾（11）","url":"/posts/38635/","content":"\n<div class=\"tip important font5 fas fa-home faa-horizontal animated\"><p>CSS移动端的知识回顾</p><p></p></div>\n\n## 常见布局\n\n1. 流式布局（百分比布局）--重点宽度\n- 加最大值或者最小值控制max-width/min-width\n\n```\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no,maximum-scale=1.0,minimum-scale=1.0\">\n\n```\n- 二倍精灵图\n1. 将精灵图缩放为原来的一半\n2. 在测算距离\n3. 在缩放代码里面的精灵图大小`background-size:缩放为原来的一半用px`\n\n\n2. *flex布局\n\n<span class=\"inline-tag green\">flex布局</span>\n\n- 原理：给父级添加flex属性来控制子盒子\n- 弹性布局，任何一个容器都可以指定fiex布局\n- 当为父元素设为flex后，`float,clear,vertical-align`属性将失效\n- flex容器，孩子为flex项目（flex item）\n\n#### flex父级属性\n\n1. `flex-diection`:设置`主轴`的方向\n- 默认主轴水平向右`row`,侧轴是水平向下的y轴\n- 翻转`row-reverse`\n- `column`主轴变为y轴\n2. `justify-content`设置`主轴`上的子元素排列方式`flex-start/flex-end/center`\n- `sapce-around`平分剩余的空间，`space-between`先两边贴边再分配剩余的空间\n- `space-evenly`将元素平均分配\n3. `flex-wrap`设置子元素是否换行，默认是`不换行`的(nowrap)wrap\n4. `align-items`设置侧轴上的子元素的排列方式（`单行`）`flex-start/flex-end/center/stretch`\n5. `align-content`出现子项换行的情况，设置侧轴上的子元素的排列方式（`多行`）,`在单行下是没有效果的`\n- flex-start\n- flex-end\n- space-between\n- space-around\n- stretch\n6. flex-flow:flex-direction，flex-wrap\n\n#### flex子项属性\n\n1. flex子项目占的份数 `flex=number`默认为0从剩余空间分配份数\n2. `align-self`控制某个子项在侧轴上的的排列方式\n3. `order`数值`越小越靠前`，默认为0\n\n## 背景渐变\n\n1. 背景线性渐变\nbackground:-webkit-linear-gradient(left,red,blue)\n{% folding green, 查看例子%}\n\n```\nbackground: -webkit-gradient(linear,left top,right top,from(#34c2aa),to(#6cd557));\nbackground: linear-gradient(to right,#34c2aa,#6cd557);\n```\n{% endfolding %}","categories":["web","css"]},{"title":"使用auto.js实现定时企业微信健康打卡","url":"/posts/24e42e9f/","content":"\n<div class=\"tip wtgo font5 fas fa-bolt faa-horizontal animated\"><p>基于auto.js，Auto.js是一款自动化软件，根据脚本内容便可以自动地执行相关的操作，并且手机无需root，Auto.js的脚本需要使用JavaScript编写</p><p></p></div>\n\n## 了解auto.js\n\n1. 使用以下代码必须了解auto.js的工作流程\n2. 可以看[官方使用文档](https://hyb1996.github.io/AutoJs-Docs/#/?id=%e7%bb%bc%e8%bf%b0)\n3. 或者去我[GitHub项目](https://github.com/Rr210/dingding)学习，代码以开源\n4. 我已经将使用代码放到下方，直接复制到auto,js即可使用\n\n## 钉钉群健康打卡\n\n{% folding green, 查看代码 %}\n\n1. 有两种方法，都已放到GitHub\n2. 低调使用\n\n```\ndevice.wakeUp() //唤醒屏幕\nsleep(1000);\n\"auto\";\n/**\n * 同时模拟一个个手势：\n * 从(300, 1400)到(300, 400)\n * 每一个的时长都为350毫秒\n */\ngestures([290, [300, 1400], [300, 400]]);\nfunction tim(){\n    home()\n    app.launchPackage(\"com.alibaba.android.rimet\");//正在执行中找应用\n    back()\n    back()\n    sleep(3000)\n    while(!click(\"程序测试\"));\n    sleep(2000)\n    while(!click(\"群签到\"));\n    sleep(2000)\n    while(!input(0,\"健康\"));\n    sleep(1000)\n    while(!input(1,\"36.3\"));\n    sleep(2000)\n    click(\"家庭住址\")\n    sleep(1500)\n    click(\"是\")\n    sleep(2000)\n    click(\"是否接触过病例\")\n    sleep(1500)\n    click(\"否\")\n    sleep(2000)\n    click(392,1901,688,1967);//页面内签到太多，因此采用定位按钮\n    sleep(1000)\n}\ntim()\n```\n{% endfolding %}\n\n## 企业微信每日健康打卡\n\n1. 早上的打卡代码（由于早晚打卡的机制不同所以分开写），配合闹钟使用\n\n{% folding green, 查看上午打卡代码 %}\n\n```\n//设定号系统闹钟，并将指令打开，用闹钟来代替唤醒屏幕，因为有时候auto.js会失效\nsleep(2000)\nclick(\"关闭\")//闹钟唤醒后2秒关闭\nsleep(1500)//1.5秒后执行下个项目\nmain_1()\nfunction main_1() {\n    device.wakeUp();\n    sleep(1000)\n    gesture(1000, [500, 1200], [500, 100], [500, 0])\n    sleep(1000)\n    var unlock = \"xxxxxx\"//解锁密码的功能\n    var secrets = unlock.length\n    toast(secrets)\n    for (var i = 0; i <= secrets; i = i + 1) {\n        click(unlock[i]);\n        log(unlock[i])//反馈数据到console控制台\n        sleep(1000)\n    }\n}\nfunction main(){\n    home()\n    launchApp(\"企业微信\")//这里老是失效\n    // app.launchPackage(\"com.tencent.wework\");//正在执行中找应用\n    back()\n    back()\n    while(!click(\"工作台\"));\n    sleep(500)\n    while(!click(\"健康天天报\"));\n    sleep(800)\n    while(!click(\"健康上报\"));\n    sleep(2000)\n    click(\"确认\")\n    sleep(3000)\n    while(!click(\"签到\",2));\n    sleep(300)\n    while(!input(0,\"36.3\"));\n    while(!click(\"正常\"));\n    click(\"无\",1)\n    click(\"无\",3)\n    click(\"无\",5)\n    click(\"无\",7)\n    click(\"无\",9)\n    click(\"为疫情防控，\")\n    click(\"上述信息是我本人填写\")\n    sleep(2000)\n    while(!click(\"否\"))\n    sleep(3000)\n    while(!input(3,\"放假在家\"));//填写备注信息可省略\n    sleep(3000)\n    var 提交=text(\"提交\").findOne();\n    log(\"提交-->\"+提交);\n    提交.click();\n    sleep(2000);\n}\nsleep(2000)\nmain()\n\nvar a=text(\"确定\")\na.click();\nsleep(1000)\nback()\n```\n{% endfolding %}\n\n1. 晚上的打卡代码（由于早晚打卡的机制不同所以分开写）\n\n{% folding green, 查看晚上打卡代码 %}\n\n```\n//设定号系统闹钟，并将指令打开，用闹钟来代替唤醒屏幕，因为有时候auto.js会失效\n\nsleep(2000)\nclick(\"关闭\")//闹钟唤醒后2秒关闭\nsleep(1500)//1.5秒后执行下个项目\n\nfunction main_1() {\n    device.wakeUp();\n    sleep(1000)\n    gesture(1000, [500, 1200], [500, 100], [500, 0])\n    sleep(1000)\n    var unlock = \"xxxxxx\"//解锁密码的功能\n    var secrets = unlock.length\n    toast(secrets)\n    for (var i = 0; i <= secrets; i = i + 1) {\n        click(unlock[i]);\n        log(unlock[i])\n        sleep(1000)\n    }\n}\nmain_1()\nfunction main(){\n    home()\n    launchApp(\"企业微信\")\n    // app.launchPackage(\"com.tencent.wework\");//正在执行中找应用\n    while(!click(\"工作台\"));\n    sleep(500)\n    while(!click(\"健康天天报\"));\n    sleep(800)\n    while(!click(\"健康上报\"));\n    sleep(2000)\n    click(\"确认\")\n    sleep(3000)\n    while(!click(\"签到\",2));\n    sleep(3000)\n    click(\"为疫情防控，\")\n    sleep(2000)\n    click(\"上述信息是我本人填写\")\n    sleep(3000)\n    var 提交=text(\"提交\").findOne();\n    log(\"提交-->\"+提交);\n    提交.click();\n    sleep(2000);\n}\nmain()\nvar a=text(\"确定\")\na.click();\nsleep(1000)\nback()\n\n```\n{% endfolding %}\n\n## 加入解锁js\n\n\n{% folding green, 查看代码 %}\n\n```\n\nfunction main() {\n    device.wakeUp();\n    sleep(1000)\n    gesture(1000, [500, 1200], [500, 100], [500, 0])\n    sleep(1000)\n    var unlock = \"xxxxxx\"//解锁密码的功能\n    var secrets = unlock.length\n    toast(secrets)\n    for (var i = 0; i <= secrets; i = i + 1) {\n        click(unlock[i]);\n        log(unlock[i])\n        sleep(1000)\n    }\n}\nmain()\n```\n\n{% endfolding %}","categories":["技术·教程"]},{"title":"CSS3知识回顾（10）","url":"/posts/59545/","content":"\n\n<div class=\"tip key font5 fas fa-key faa-horizontal animated\"><p>CSS3转换透视旋转</p><p></p></div>\n\n## CSS3思维导图\n\n\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/4/css3xmind.jpg)\n\n\n## 3D转换\n\n1. x右面为正，左边为负\n2. y下面为正，上面为负\n3. z外面为正，里面为负\n4. transform:translate3d(x,y,z),且xyz都不能省略\n\n### 透视perspective\n\n>透视（视距）写到被观察元素的父盒子上\n\n### 3D旋转\n\n1. 可以沿着xyz分别旋转，加透视效果更明显\n2. 使用左手定则判断方向\n3. transform:rotate3d(x,y,z,ndeg)\n4. 3d呈现transform-style:flat/preserve-3d,代码写给父级，影响的时子盒子\n\n{% folding green, 查看案例代码%}\n\n1. 有3d翻转效果和旋转木马效果\n\n```\n* {\n    padding: 0;\n    margin: 0;\n}\n\nbody {\n    -webkit-transform: translate3d(0, 0, 0) ;\n    transform: translate3d(0, 0, 0);\n    /* perspective:1200px; */\n    \n    }\n\n.box {\n    position: relative;\n    width: 200px;\n    height: 200px;\n    margin: 100px auto;\n    transform-style: preserve-3d;\n    transition: all 2s;\n}\n\n.box:hover {\n    transform: rotateY(-180deg);\n}\n\n/* .box:hover .back {\n    transform: rotateY(180deg);\n}  */\n\n .front,.back {\n    border-radius: 50%;\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    font-size: 40px;\n    text-align: center;\n    line-height: 200px;\n}\n\n.front {\n    background-color: #9b6ab5;\n    z-index: 1;\n}\n\n.back {\n    background-color: #ce485c;\n    transform: rotateY(180deg);\n}\n\n.box2 {\n    position: relative;\n    height: 35px;\n    width: 100px;\n    margin: 100px auto;\n    transform-style: preserve-3d;\n    transition: all .6s;\n}\n.box2:hover{\n    transform: rotateX(90deg);\n}\n\n.box2 ul li {\n    list-style: none;\n    height: 35px;\n    width: 100px;\n}\n\n.b1, .b2 {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    top: 0;\n    left: 0;\n    border-radius: 6px;\n    text-align: center;\n    line-height: 35px;\n}\n\n.b1 {\n    background-color: #5757ff;\n    z-index: 1;\n    transform: translateZ(17.5px);\n}\n\n.b2 {\n    background-color: #268354;\n    transform:translateY(17.5px) rotateX(-90deg);\n}\n\nsection{\n    width: 156px;\n    height: 502px;\n    position: relative;\n    margin: 50px auto;\n    transform-style: preserve-3d;\n    animation: rotate 5s linear infinite;\n}\n@keyframes rotate{\n    0%{\n        transform: rotateY(0);\n    }\n    100%{\n        transform: rotateY(360deg);\n    }\n}\nsection img{\n    position: absolute;\n    display: block;\n    margin: 0 auto;\n    width: 100%;\n    top: 0;\n    left: 0;\n}\nsection img:nth-child(1){\n    transform: translateZ(300px);\n}\nsection img:nth-child(2){\n    transform: rotateY(60deg)translateZ(300px) ;\n}\nsection img:nth-child(3){\n    transform:rotateY(120deg) translateZ(300px) ;\n}\nsection img:nth-child(4){\n    transform:rotateY(180deg) translateZ(300px)  ;\n}\nsection img:nth-child(5){\n    transform: rotateY(240deg) translateZ(300px);\n}\nsection img:nth-child(6){\n    transform:rotateY(300deg) translateZ(300px);\n}\n\n\n```\n{% endfolding %}\n\n## CSS移动端\n\n1. meta视口标签\n2. `neme=\"viewport\" content=\"width=device-width,user-scalable=no,initial-scale=1\"`\n\n## background\n\n1. `bgs`可以跟像素单位或百分比，\n2. background-size:cover/contain（等比拉伸）\n\n## 特殊样式\n\n1. 盒子模型`box-sizing;border-box,-webkit-box-sizing:border-box`\n2. 点击高亮清除`-webkit-tap-highlight-color:transparent`\n3. 清除移动端ios按钮样式`-webkit-appearance:none`\n4. 禁用长按页面时的弹出菜单` img,a{-webkit-touch-callout;none}`\n","categories":["web","css"]},{"title":"CSS3知识回顾（9）","url":"/posts/48a2f11c/","content":"\n<div class=\"note warning icon flat faa-horizontal animated\"><p>CSS32d,旋转等</p></div>\n\n## CSS3 2D转换\n\n<span class=\"inline-tag yellow\">translate</span>\n\n1. translate 移动，`transform:translate(x,y)`\n2. translateX/Y   右/下移动\n3. translate不会影响其他的元素\n4. 如果里面的参数是`%`移动的而距离是`盒子的宽度`或者`自身元素`的`%`\n5. translate对`行内元素`是无效的\n\n<span class=\"inline-tag blue\">rotate</span>\n\n1. rotate(ndeg),旋转\n2. 三角案例也可以试用\n\n### transform-origin \n\n1. 转变的起点 \n2. `transform-origin:x y ` xy 50%时为中心点\n3. 可以使用方位名词\n\n{% folding green, 居中代码 %}\n\n```\ntop:50%;\nleft:50%\ntransform:translate(-50%,-50%)\n```\n\n{% endfolding %}\n\n### scale(x,y)\n\n1. 元素的缩放（数字不跟单位）\n2. 可以分别缩放，可以等比缩放，缩小`<`1\n3. 优势不会影响其他的盒子，可以设置转化的中心点\n\n## 2D综合写法\n\n1. 综合编写的时候，顺序有要求\n2. 同时有位移和旋转的，最好先写位移\n\n## 动画\n\n1. 定义动画`@keyframes `\n2. 调用动画`animation-name`\n3. 调用时间`animation-duration`\n\n### 动画序列\n\n1. `from`和`to`等价于`0%`和`100%`\n2. keyframe里面的百分比必须是整数\n3. 百分比按照时间来划分\n\n### 动画属性\n\n1. `animation-name`动画名称\n2. `animation-duration`动画时间\n3. `animation-delay`动画开始时间延迟\n4. `animation-iteration-count`重复次数，infinite无限次，默认为1\n5. `animation-direction` alternate  逆播放\n6. `animation-play-state`规定动画运行状态，running，和paused,可以搭配hover使用\n7. `animation-fill-mode`规定动画结束后的状态，保持forwards回到起始backwarks\n8. `animation-timing-funtion`规定动画的速度曲线，默认·ease· `linear`匀速\n\n- 简写：动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画起始或者结束的状态\n\n### 速度曲线细节\n\n1. `linear`匀速\n2. `ease`默认，从低速开始加快结束变慢\n3. `ease-in`动画以低速开始\n4. `ease-out` 以低速结束\n5. `ease-in-out`综合\n6. `step()`分步进行\n\n## 小熊案例\n\n1. 使用了动画效果animation\n2. 使用精灵图，用step来定义熊的移动\n\n{% folding green, 查看代码 %}\n\n```\n.bear-bg{\n    position: relative;\n    margin:500px auto;\n    width: 100%;\n    height: 100px;\n    background-color: #9ea5a7;\n}\n.bear-bg .bear{\n    position: absolute;\n    width: 200px;\n    height: 100px;\n    background: url(bear.png) no-repeat;\n    background-color: #9ea5a7;\n    animation: bear .6s steps(8) infinite,bear-move 2s forwards;\n}\n@keyframes bear{\n    0%{\n    }\n    100%{\n        background-position: -1600px 0;\n    }\n}\n@keyframes bear-move{\n    0%{\n        left: 0%;\n    }\n    100%{\n        left: 50%;\n        transform: translate(-50%);\n        /* margin-left: -100px; */\n    }\n}\n```\n\n{% endfolding %}\n\n{% folding green, 查看演示图例 %}\n\n![](https://7.dusays.com/2021/01/30/40e1aed061fbd.gif)\n\n{% endfolding %}","categories":["web","css"]},{"title":"利用钉钉群机器人实现定时发送群消息","url":"/posts/59985/","content":"\n<div class=\"snote link blue fa-atom faa-horizontal animated\"><p>利用钉钉群自定义机器人实现钉钉群内仿签到功能，缺点无后台统计记录，实现方法有多种借助云服务器或者GitHub action来实现定时通知功能，消息形式多样化文本，卡片等等</p></div>\n\n## 思维导图\n\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/dasdawddscxx.jpeg)\n\n- 此项目已上传到[Github](https://github.com/Rr210/dingding)开源\n\n## 准备工作\n\n1. 准备一个钉钉群并加入群自定义钉钉机器人\n2. 设置钉钉机器人方法看[钉钉官方文档](https://ding-doc.dingtalk.com/document/app/custom-robot-access)即可\n3. 云服务器或者本地电脑，都没有的话，注册使用GitHub实现（使用方法二）\n\n## 方法一\n\n<span class=\"inline-tag yellow\">云服务器实现定时发送钉钉群消息</span>\n\n### 云服务器\n\n1. 使用云服务器(宝塔) （me菜鸟专属）\n2. 还可以使用云函数（这里我就不写了，感兴趣可以自己去研究研究）我懒~_~\n3. 打开宝塔 找到计划任务将代码填入即可\n4. 代码看[钉钉官方文档](https://ding-doc.dingtalk.com/document/app/custom-robot-access)或者去我[GitHub项目](https://github.com/Rr210/dingding/tree/master/curl)复制\n5. 可以使用`宝塔webhook`测试代码是否执行，宝塔自带\n\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/wdasaWdA.jpeg)\n\n### 定时任务\n\n1. 第一种是使用宝塔的计划任务，直接定时即可\n2. 第二种是使用[Liunx系统的Crontab定时任务](https://www.runoob.com/w3cnote/linux-crontab-tasks.html)\n\n### 仿群签到\n\n>由于学校开始了钉钉群的健康打卡统计，我是属于那种比较懒的，老是错过签到，懂得都懂嘿嘿，所以突发奇想搞了一个仿签到，也就是利用钉钉自带的机器人实现群消息通知，改了改源码，变成自己的签到通知，缺点就是无法实现钉钉后台的统计，但是这难不倒我，已经有了新的方法[看这看这](/posts/24e42e9f/)\n\n{% folding green, 查看钉钉仿签到代码 %}\n\n```\n#!/bin/bash\ncurl 'https://oapi.dingtalk.com/robot/send?access_token=xxxxxx' \\\n   -H 'Content-Type: application/json' \\\n   -d '{\n     \"msgtype\": \"markdown\",\n     \"markdown\": {\n         \"title\":\"xxx的签到机器人\",\n         \"text\": \"##### 签到 (xxx的签到机器人) \\n #### xxx在xx省xx市xx市签到 \\n> ##### 签到时间：**19:00** \\n> ##### 备注：**健康** \\n> ##### 体温：**36.5** \\n> ##### 家庭住址与现住址是否一样：**是** \\n> ##### 是否接触过病例患者：**否** \\n> ![screenshot](https://cdn.mr90.top/demo/wxpagecover/0/%E4%B8%8B%E8%BD%BD.jpg)\\n> ###### 19点发布 [Harry](https://u.mr90.top) \\n\"\n     },\n      \"at\": {\n          \"atMobiles\": [\n              \"\"\n          ],\n          \"isAtAll\": true\n      }\n }'\n```\n\n{% endfolding %}\n\n{% folding green, 查看演示效果 %}\n![]https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/dawfasdaadda.jpeg)\n{% endfolding %}\n\n- 如果创建的是python文件，可以点击查看代码[.py](https://github.com/Rr210/dingding/tree/master/Python)\n\n## 方法二\n\n<span class=\"inline-tag green\">Github实现定时发送钉钉群消息</span>\n\n### 使用GitHub\n\n1. 使用`GitHub action`定时运行`.py`文件来实现钉钉机器人定时发送群消息\n2. 创建一个GitHub仓库，新建一个要执行的.py文件名称自定,比如(run.py)\n\n{% folding green, 查看GitHub.py代码 %}\n\n- 这里可以去我的GitHub仓库查看.py文件复制即可\n- 这里我还是以群仿签到代码为例，markdown形式的\n- 代码如下\n\n```python\nimport time\nimport hmac\nimport hashlib\nimport base64\nimport urllib.parse\n\ntimestamp = str(round(time.time() * 1000))\nsecret = '这里是密码//可以使用变量secrets.GITHUB_SECTET,自己定义'\nsecret_enc = secret.encode('utf-8')\nstring_to_sign = '{}\\n{}'.format(timestamp, secret)\nstring_to_sign_enc = string_to_sign.encode('utf-8')\nhmac_code = hmac.new(secret_enc, string_to_sign_enc, digestmod=hashlib.sha256).digest()\nsign = urllib.parse.quote_plus(base64.b64encode(hmac_code))\n#print(timestamp)\n#print(sign)\n\nimport requests,json\n\n#导入依赖库\nheaders={'Content-Type': 'application/json'}   #定义数据类型\n#截至到&timestamp之前\nwebhook = '这里是钉钉机器人的webhook地址,也可以使用变量[GITHUB_url]自己定义具有保密性&timestamp='+timestamp+\"&sign=\"+sign\n#定义要发送的数据\n#\"at\": {\"atMobiles\": \"['\"+ mobile + \"']\"\ndata = {\n    #定义内容\n\"msgtype\": \"markdown\",\n     \"markdown\": {\n         \"title\":\"xxx的签到机器人\",\n         \"text\": \"##### 签到 (xxx的签到机器人) \\n #### xxx在xx省xx市xx市签到 \\n> ##### 签到时间：**19:00** \\n> ##### 备注：**健康** \\n> ##### 体温：**36.5** \\n> ##### 家庭住址与现住址是否一样：**是** \\n> ##### 是否接触过病例患者：**否** \\n> ![screenshot](xxxxxxx)\\n> ###### 19点发布 [Harry](https://u.mr90.top) \\n\"\n     }\n      }   \nres = requests.post(webhook, data=json.dumps(data), headers=headers)   #发送post请求\n\nprint(res.text)\n```\n- 演示效果同上就不展示了\n{% endfolding %}\n\n### 实现定时效果\n\n1. 在本地git仓库创建`.github\\workflows\\xxx.yml`文件,加入以下代码\n2. 或者直接点击创建的GitHub项目的`Action`\n\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/dawsdasdjrks.jpeg)\n\n{% folding green, 查看.yml代码配置 %}\n\n```yml\n  \n# This workflow will install Python dependencies, run tests and lint with a single version of Python\n# For more information see 想了解更多可以点这里看官方文档: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions\n\n# name随便定义自拟\nname: Dingding\n\non:\n#这里是使用定时任务，可百度指令，如有需要将`#`去掉即可\n  #schedule:\n    #- cron: \"0 0/2 * * *\"\n#这里是如果有人点击你仓库的star 就会执行一次，测试用，不用的时候#掉就可以，以免造成不必要的资源浪费\n  watch:\n    types: [started]\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    if: github.event.repository.owner.id == github.event.sender.id  # 自己点的 start\n    steps:\n    - uses: actions/checkout@v2\n    - name: Set up Python 3.8\n      uses: actions/setup-python@v2\n      with:\n        python-version: 3.8\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install requests lxml\n        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi\n    - name: Run misson\n    #这里放路径，就是仓库的文件路径 格式： python 文件路径\n      run: |\n        python Python/actioncard.py\n```\n\n{% endfolding %}\n\n\n\n## 分享项目\n\n- 分享一下我的【[GitHub项目](https://github.com/Rr210/dingding)】\n- 喜欢的点个`star`","categories":["技术·教程"]},{"title":"CSS3和HTML5知识回顾（8）","url":"/posts/58058/","content":"\n<div class=\"tip ffa font5 fas fa-cogs faa-horizontal animated\"><p>回顾html5和css3新增的标签内容</p><p></p></div>\n\n\n## css初始化\n\n{% folding green, 查看初始化代码 %}\n\n```\n* {\n    margin: 0;\n    padding: 0\n}\n\nem, i {\n    font-style: normal\n}\n\nli {\n    list-style: none\n}\n\nimg {\n    border: 0;\n    vertical-align: middle\n}\n\nbutton {\n    cursor: pointer\n}\n\na {\n    color: #666;\n    text-decoration: none\n}\n\na:hover {\n    color: #c81623\n}\n\nbutton, input {\n    font-family: Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, \"\\5B8B\\4F53\", sans-serif\n}\n\nbody {\n    -webkit-font-smoothing: antialiased;\n    background-color: #fff;\n    font: 12px/1.5 Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, \"\\5B8B\\4F53\", sans-serif;\n    color: #666\n}\n\n.hide, .none {\n    display: none\n}\n\n.clearfix:after {\n    visibility: hidden;\n    clear: both;\n    display: block;\n    content: \".\";\n    height: 0\n}\n\n.clearfix {\n    *zoom: 1\n}\n```\n{% endfolding %}\n\n## HTML5\n\n1. header,nav,article,aside,senction(定义某个区域),footer\n2. audio，video视频和音频\n\n{% folding green, 查看代码 %}\n\n```\n<video width=\"320\" height=\"240\" controls>\n  <source src=\"movie.mp4\" type=\"video/mp4\">\n  <source src=\"movie.ogg\" type=\"video/ogg\">\n  您的浏览器不支持 HTML5 video 标签。\n</video>\n```\n\n{% endfolding %}\n\n### input属性\n\n1. 新增很多属性值，测试时候加入form标签\n2. 表单属性\n- `required`内容不能为空,\n- `placeholder`显示提示信息 input::placeholder可改变颜色属性\n- autofocus:自动聚焦\n- autocomplete:on/off，显示出之前输入过的内容\n- multiple可以提交多个文件\n\n## CSS3新选择器\n\n<span class=\"inline-tag red\">CSS3新特性</span>\n\n### 属性选择器\n\n1. 利用属性选择器可以不用借助类或者id选择器使用`[]`\n2. **利用属性=值选择**,比如：`input[type=text]{}`\n3. 利用属性都相同，属性值开头都相同，比如：`div[class^=icon]`结尾`div[class$=data]\n4. 权重等于10，类，属性，伪类，都是10\n\n### 结构伪类选择器\n\n1. 结构类似，可使用first和last将子元素选择出来，比如 ul li:last-child\n2. 选择第n个元素，使用nth() 比如：ul li:nth-child(n){}\n- 选择n个元素可使用`even`和`odd`选择，偶数和奇数\n- ul li:nth(n){},表示选择所有的孩子，从0开始\n- 2n可选择所有的偶数和even相同，2n+1同理\n- n+2从第二个开始，n始终都是`从0开始的`\n- -n+5前五个\n3. nth-of-type和nth-chid的区别\n- nth-child会将所有的子元素排列，of-ttype将指定的选择出来\n- nth-child将所有的孩子排序，原理，先去找第几个孩子，在与父元素比较\n- nth-of-type先于子元素匹配在进行排序选择\n\n### 伪元素选择器\n\n1. ::before和::after，不会生成新的标签\n2. 权重为1和标签选择器一样\n3. before和after必须有content属性\n4. 常用于字体图标\n5. 使用hover时要注意:hover::before中间不能空格严格按照顺序\n6. 伪元素也可清除浮动\n\n{% folding green,  查看代码 %}\n\n```\n.clearfix:after{\ncontent:'';\ndisplay:block;\nheight:0;\nclear:both;\nvisibility:hidden;\n}\n```\n\n```\n.clearfix:before,.clearfix:after{\ndisplay:block;\ncontent:'';\n}\n.clearfix:after{\nclear:both;\n}\n.cleafix{\n*zoom:1;\n}\n```\n\n{% endfolding %}\n\n### 盒子模型\n\n1. 解决盒子变化问题\n- 默认的box-sizing:content-box\n- `box-sizing: border-box`使用后不会增大盒子padding和border\n\n### css滤镜（filter)\n\n1. filter: blur()   blur是一个模糊处理函数，小括号的数值越大越模糊\n\n### CSS3calc函数\n\n1. 使子盒子比父盒子小npx\n- 同步变化比如`width: calc(100% - 30px)`\n2. 可进行加减乘除\n\n### CSS3过渡 transition\n\n1. transition:要过度的属性，时间，运动曲线，何时开始\n2. 谁做过渡给谁加，使用多个属性用`,`隔开，多个属性变化加`all`\n3. ease和何时开始可以省略\n\n#### 小米商城logo的实际运用\n\n1. 思路：使用双伪元素来实现，before设置显示，after设置隐藏，hover分别进行改变，但是这种方法无法实现过渡的效果（这是第一次的想法代码如下）\n\n{% folding grren, 查看代码 %}\n\n```\n.logo {\n    width: 100px;\n    height: 100px;\n    margin: 100px auto;\n    position: relative;\n    background-color: rgb(240, 77, 13);\n}\n\n.milogo {\n    height: 100%;\n    width: 100%;\n    margin: 0 auto;\n    position: absolute;\n}\n.milogo::after,.milogo::before{\n    content: '';\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    top: 27%;\n    left: 25%;\n    transition: all .2s;\n}\n.milogo::before {\n    display: block;\n    background: url(https://s02.mifile.cn/assets/static/image/mi-logo.png) no-repeat;\n}\n\n.milogo::after {\n    display: none;\n    background: url(https://s02.mifile.cn/assets/static/image/mi-home.png) no-repeat;\n}\n.milogo:hover::before{\n    display: none;\n}\n.milogo:hover::after {\n    display: block;\n}\n```\n\n{% endfolding %}\n\n1. 思路二就是使用定位，然后改变after的位置就能实现过渡,去除直接隐藏和显示，巧妙使用定位实现logo的切换\n\n{% folding green, 查看代码 %}\n\n```\n.logo {\n    width: 100px;\n    height: 100px;\n    margin: 100px auto;\n    position: relative;\n    border-radius: 5px;\n    background-color: rgb(240, 77, 13);\n    overflow: hidden;\n    box-shadow: 1px 2px 3px #888;\n}\n\n.milogo {\n    height: 100%;\n    width: 100%;\n    margin: 0 auto;\n    position: absolute;\n}\n.milogo::after,.milogo::before{\n    content: '';\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    top: 27%;\n    transition: all .4s;\n}\n.milogo::before {\n    left:27%;\n    background: url(https://s02.mifile.cn/assets/static/image/mi-logo.png) no-repeat;\n}\n\n.milogo::after {\n    left: -50px;\n    background: url(https://s02.mifile.cn/assets/static/image/mi-home.png) no-repeat;\n}\n.milogo:hover::before{\n    left: -50px;\n}\n.milogo:hover::after {\n    left: 25px;\n}\n```\n\n{% endfolding %}\n\n{% folding green, 查看演示图片 %}\n\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/xioamilogo.gif)\n{% endfolding %}","categories":["web","css"]},{"title":"Hexo-butterfly实现Github+Coding+云服务器一键部署","url":"/posts/27946547/","content":"\n<div class=\"tip important font5 fas fa-home faa-horizontal animated\"><p>👀Hexo-butterfly实现Github+Coding+云服务器一键部署</p><p>本文主要是实现Coding的一键部署，点击下方链接可查看之前的GitHub和云服务器的一键部署教程</p></div>\n\n- [GitHub和云服务器的一键部署教程](/posts/1bb4b0cb.html)\n\n## 思维导图\n\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/coding.jpeg)\n\n## coding部署教程\n\n1. 访问[Coding官网](https://coding.net/)注册登录，登录后创建好项目，注意登录时可以使用腾讯云的账号扫码登录，切记要记好创建的用户名。\n2. 注册好之后点击右上角头像找到个人账户设置，个人设置绑定好手机号等等\n3. 创建`DevOps`项目\n4. 个人账户设置绑定`SSH公钥`\n5. 修改本地的hexo的_config.yml文件的`deploy`设置\n\n## 绑定账户\n\n1. 保证账户的安全，绑定好这些信息\n2. 帮助后面验证部署信息使用\n\n{% folding green, 查看图例 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/coding_1.jpeg)\n{% endfolding %}\n\n## 创建项目\n\n1. 点击创建项目-DecOps\n\n{% folding green, 查看图例 %}\n\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/coding_!.jpeg)\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/coding_%23.jpeg)\n\n{% endfolding %}\n## 建立项目仓库\n\n1. 创建项目仓库时要选择`公开`\n\n{% folding green, 查看图例 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/coding_2.jpeg)\n{% endfolding %}\n\n2. 进去仓库找到仓库链接，一会部署时会用到\n\n## 创建静态页面\n\n1. 点击持续部署——>静态页面-->新建网站\n2. 选择刚刚创建的仓库\n3. 网站类型选择静态网站\n4. 节点选择香港，国内的节点在使用自定义域名时需要备案\n\n{% folding green, 查看图例 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/coding_DAW.jpeg)\n{% endfolding %}\n\n## 自定义域名\n\n1. 创建好静态网站后，点击部署成功的项目\n2. 选择自定义域名\n\n{% folding green, 查看图例 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/coding&.jpeg)\n{% endfolding %}\n\n## 创建SSH公钥\n\n1. 进入个人账户设置建立SSH公钥，填入在GitHub在本地的`id_rsa.pub`公钥即可可公用\n\n{% folding green, 查看图例 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/coding_!!.jpeg)\n{% endfolding %}\n\n## 修改本地\n\n1. 修改本地的hexo根目录下的_config.yml的`deply`设置\n\n{% folding green, 查看图例 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/wdaw.jpeg)\n{% endfolding %}\n\n2. 此链接是你创建的项目仓库地址\n\n{% folding green, 查看图例 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/coding_!wd.jpeg)\n{% endfolding %}\n\n## 本地执行\n\n1. 修改配置好本地hexo后，尝试测试一下\n2. `hexo d`或者`gulp build`\n3. `注`执行过程中会出现验coding的账户信息，填入账号和密码即可，下次部署就不需要填写了\n\n\n\n","categories":["技术·教程","Coding"]},{"title":"Css三角形的画法-多种形式","url":"/posts/b49453d4/","content":"\n<div class=\"tip socd font5 fas fa-bell faa-horizontal animated\"><p>灵活使用css画图，熟练使用代码</p><p></p></div>\n\n## css三角形的画法\n\n<span class=\"inline-tag blue\">三角形画法</span>\n\n### 左上角直角三角形\n\n{% folding green, 查看代码 %}\n\n```\n.box-up{\n    height: 0px;\n    width: 0px;\n    border-top:50px solid #517983;\n    border-right: 50px solid transparent;\n    margin: 10px auto;\n}\n```\n\n1. 扩展 - 改变top/right的值，使三角形的边发生改变\n2. 右上角，左下角，右下角同理\n\n\n{% endfolding %}\n\n## 使用css三角形画平行四边形\n\n{% folding green, 查看代码 %}\n\n- 有多种画法，巧妙使用浮动，定位\n```\n.box-p{\n    width: 200px;\n    height: 100px;\n    margin: 50px auto;\n    background-color: #888;  \n    position:relative;  \n}\n.box-p i{\n    position: absolute;\n    width: 0;\n    height: 0;\n    left: -50px;\n    border-bottom: 100px solid #888;\n    border-left: 50px solid transparent;   \n}\n.box-p span{\n    position: absolute;\n    width: 0;\n    height: 0;\n    right: 0;\n    border-bottom: 100px solid #fff;\n    border-left: 50px solid #888;  \n}\n```\n\n- 第二种简单的画法\n\n```\n     width: 150px;\n     height: 100px;\n     margin-left:20px;\n     -webkit-transform: skew(20deg);\n     -moz-transform: skew(20deg);     \n     -o-transform: skew(20deg);\n     background: red;\n```\n{% endfolding %}\n\n## 使用三角形画六边形有多种画法\n\n1. 第一种我使用了定位的画法，思路两个三角形\n\n{% folding green, 查看代码 %}\n\n1. 画法，由上下俩个三角形组成\n```\n.star-six2 {\n    width: 300px;\n    height: 300px;\n    margin: 10px auto;\n    position: relative;\n}\n\n.star-six2 p {\n    position: absolute;\n    width: 0;\n    height: 0;\n    border-top: 80px solid red;\n    border-right: 50px solid transparent;\n    border-left: 50px solid transparent;\n}\n\n.star-six2 span {\n    position: absolute;\n    width: 0;\n    height: 0;\n    border-bottom: 80px solid red;\n    border-right: 50px solid transparent;\n    border-left: 50px solid transparent;\n    top: -25px;\n}\n```\n\n2. 第二种使用伪元素法构造\n\n```\n.star-six {\n    width: 0;\n    height: 0;\n    border-left: 50px solid transparent;\n    border-right: 50px solid transparent;\n    border-bottom: 100px solid red;\n    position: relative;\n    margin: 50px auto;\n}\n\n.star-six:after {\n    width: 0;\n    height: 0;\n    border-left: 50px solid transparent;\n    border-right: 50px solid transparent;\n    border-top: 100px solid red;\n    position: absolute;\n    content: \"\";\n    top: 30px;\n    left: -50px;\n}\n\n```\n{% endfolding %}\n\n## 使用css画八卦图\n\n{% folding green, 查看代码 %}\n\n\n1. 思路：正方形+两个长方形+两个正方形组成\n2. 思路二：一个大的正方形（或者两个长方形）+两个正方形（使用border-radius增大他们的外边距\n\n```\n.bagua {\n    position: relative;\n    height: 200px;\n    width: 200px;\n    margin: 50px auto;\n    background-color: #000000;\n    border-radius: 100px;\n    border: 1px solid #000;\n}\n\n.bagua p {\n    position: absolute;\n    height: 100px;\n    width: 200px;\n    background-color: #fff;\n    border-radius: 100px 100px 0 0;\n}\n\n.bagua .a {\n    position: absolute;\n    top: 50px;\n    width: 100px;\n    height: 50px;\n    background-color: #000;\n    border-radius: 50px 50px 0 0;\n}\n\n.bagua .b {\n    position: absolute;\n    top: 50px;\n    width: 100px;\n    height: 50px;\n    background-color: #fff;\n    border-radius: 0 0 50px 50px;\n    right: 0;\n    top: 100px\n}\n\n.bagua .c {\n    position: absolute;\n    width: 20px;\n    height: 20px;\n    top: 90px;\n    left: 40px;\n    background-color: #fff;\n    border-radius: 10px;\n}\n\n.bagua .d {\n    position: absolute;\n    width: 20px;\n    height: 20px;\n    right: 40px;\n    top: 90px;\n    background-color: #000;\n    border-radius: 10px;\n}\n```\n\n2. 使用伪元素画法\n\n```\n.bagua2 {\n    width: 96px;\n    height: 48px;\n    background: #eee;\n    border-color: red;\n    border-style: solid;\n    border-width: 2px 2px 50px 2px;\n    border-radius: 100%;\n    position: relative;\n}\n\n.bagua2:before {\n    content: \"\";\n    position: absolute;\n    top:50%;\n    left: 0;\n    background: #eee;\n    border: 18px solid red;\n    border-radius: 100%;\n    width: 12px;\n    height: 12px;\n}\n\n.bagua2:after {\n    content: \"\";\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    background: red;\n    border: 18px solid #eee;\n    border-radius: 100%;\n    width: 12px;\n    height: 12px;\n}\n```\n{% endfolding %}\n\n{% folding green, 查看效果 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/star.webp)\n{% endfolding %}","categories":["web","css"]},{"title":"Css知识回顾（7）","url":"/posts/ee08f2a6/","content":"\n<div class=\"tip ref font5 fas fa-sync faa-horizontal animated\"><p>css知识回顾，定位，精灵图，文本省略等等</p><p></p></div>\n\n## css定位\n\n1. 为什么需要定位-因为标准流和浮动流无法快速实现\n2. 定位的组成：定位模式+边偏移\n3. 边偏移使用top,buttom,right,left属性移动\n4. 静态定位：position：static（很少使用）\n5. 相对定位：position：relative(位置保留)\n6. 绝对定位：position：absolute（先对于父元素）父元素无定位或者没有父级以浏览器为标准，以最近的有定位父元素对齐`（不在占有位置）`\n7. `子绝父相`\n8. 巧妙使用`>`\n\n## 固定定位\n\n1. position：fixed（不占有位置）\n2. 以可视化的窗口为参照点，使用算法固定在版心的位置\n3. 先定义浏览器的一半，left/right：50%，在使用margin-left：版心的一半\n\n## 粘性定位\n\n1. `postion：sticky；top:0`占有原来的位置（浏览器可视区）\n\n## 定位叠放次序\n\n1. z-index数值越大盒子越靠上\n2. 层叠性，属性都相同时候\n3. 只有定位的盒子才有z-index属性\n\n## 绝对定位盒子局中\n\n1. `margin：0 auto;`加了绝对定位的盒子无法适用\n2. 与定义版心位置的方法类似margin为负值\n3. 相对定位不脱流不影响\n\n## 定位的特殊特性\n\n1. 行内元素添加绝对或者固定定位，可以直接设置w和h\n2. 块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小使内容的大小\n\n## 浮动和定位\n\n1. 浮动想让文字环绕，只会压住下面标准流的盒子，不会压住盒子中的文字（图片\n2. 定位会压住下面标准流的所有内容。绝对定位，固定定位\n\n## 元素的显示和隐藏\n\n1. display：none;隐藏对象(经常使用)\n2. display：block;显示对象\n3. display不在占有原来的位置\n4. visibility：hidden;(隐藏之后继续保留原来的位置)\n5. overflows：hidden；隐藏溢出，比如：浮动溢出（父元素无高度的时候），overflows：scroll\n6. 有定位的盒子慎用隐藏元素\n\n## 精灵图\n\n>background-position:x y;  xy的正方向为向右向下，所以一般都是负值\n\n1. 取消表单轮廓`outline：none`\n2. 防止拖拽文本，`textarea{resize:none}`\n\n## vertical-align属性\n\n1. 行内元素和行内块元素，可以使图片和文字对齐\n2. verticla-align: middle;图片和文字垂直局中\n3. 解决图片底部有空格-加vertical-align属性（转化为块级元素）\n\n\n## 文本省略号\n\n<span class=\"inline-tag blue\">单行</span>\n\n1. 单行省略号，强制一行显示`white-space:nowrap`\n2. 隐藏溢出`overflow:hidden`\n3. 省略号代替`text-overflow:ellipsis`\n\n<span class=\"inline-tag grey\">多行</span>\n\n1. 第一种方法兼容性有问题\n\n{% folding green, 查看多行使用的代码 %}\n\n```\noverflow:hidden;\ntext-overflow:ellipsis;\ndisplay：-webkit-box；\n-webkit-line-clamp:2;\n-webkit-box-orient:vertical;\n```\n\n{% endfolding %}\n\n## margin负值的使用\n\n1. 去除边框的时候可使用\n2. 如果li有定位加z-index提高定位，如果没有定位，添加相对定位即可","categories":["web","css"]},{"title":"Css知识回顾(6)","url":"/posts/daac08a0/","content":"\n<div class=\"tip ffa font5 fas fa-cogs faa-horizontal animated\"><p>一些常见的问题，浮动，塌陷等等</p><p></p></div>\n\n## 常见的元素\n\n{% folding green, 查看元素 %}\n\n1. 块级元素:(div、p、h1~h6、ul、ol、dl、li、dd、table、hr、blockquote、address、table、menu、pre，HTML5新增的header、section、aside、footer等）\n2. 行内元素:(span、img、a、lable、input、abbr（缩写）、em（强调）、big、cite（引用）、i（斜体）、q（短引用）、textarea、select、small、sub、sup，strong、u（下划线）、button（默认display：inline-block））\n3. 行内块级元素\n常用的行内块级元素：`<img> <input>`\n\n{% endfolding %}\n\n## 圆角的使用\n\n1. 圆形的使用设置一个正方形radius要为边的一半\n2. 圆角矩形radius等于height\n3. 可以设置四个角度的弧度 top-left,top-right,buttom-right,buttom-left\n\n## 阴影的使用\n\n1. `box-shadow`：x,y,模糊距离，大小，颜色,（默认阴影，inset为内阴影）\n2. 万物皆可hover\n\n## 浮动使用\n\n1. 标准流，浮动和定位共同组成网页\n2. 浮动的特性\n\n{% folding green, 查看特性 %}\n\n1. 脱离标准流，浮动的盒子不会在保留原先的位置\n2. 浮动的盒子一行显示\n3. 添加浮动效果后盒子具有行内块元素的特性\n4. 浮动的盒子只会影响后面的盒子\n5. 浮动的高度问题-清除浮动\n6. 浮动的盒子不会有外边距塌陷的问题\n\n{% endfolding %}\n\n{% folding green, 清除浮动 %}\n\n1. 本质：清除脱离标准流\n2. 策略：闭合浮动\n3. 方法- 额外标签法：`clear：both` 块级元素\n4. 方法-添加父级元素：overflows:hidden\n5. 方法-after伪元素是额外元素的升级版，给父元素添加\n\n```\n.clearfix:after {\ncontent: \"\";\ndisplay: block;\nheight: 0;\nclear: both;\nvisibility: hidden;\n}\n.clearfix{\n*zoom:1;\n}\n```\n\n\n6. 双伪元素清楚法-前后混合双打\n\n```\n.clearfix:before,.clearfix:after {\ncontent: \"\";\ndisplay: table;\n}\n.clearfix:after{\nclear:both;\n}\n.cleafix{\n*zoom:1;\n}\n```\n\n{% endfolding %}\n\n## 问题总结\n\n1. 为什么要清除浮动？\n\n{% folding green, 查看答案 %}\n\n1. 父级没高度\n2. 子盒子不浮动了\n3. 影响下面的布局了，我们就应该清除浮动了\n\n{% endfolding %}\n\n2. 书写顺序\n\n{% folding green, 查看答案 %}\n\n- 建议遵循以下顺序:\n1. 布局定位属性: display / position/ float / clear / visibility/ overflow (建议display第-个写,毕竟关系到模式)\n2. 自身属性: width/ height/ margin/ padding / border / background\n3. 文本属性: color/ font / text-decoration/ text- align/ vertical-align/ white- space / break- word\n4. 其他属性( CSS3) : content / cursor / border-radius 1 box -shadow / text- shadow/ background;linear-gradient...\n\n{% endfolding %}\n\n3. 设置好input,button属性后，点击显示外边框`outline-style:none`可以消除","categories":["web","css"]},{"title":"Css基础知识回顾(5)","url":"/posts/66dd52fc/","content":"\n<div class=\"tip wtgo font5 fas fa-bolt faa-horizontal animated\"><p>css基础知识回顾，查漏补缺</p><p></p></div>\n\n## 行高特性\n\n1. `line-height=height`可以实现垂直局中\n2. `line-height>height` 文字偏下\n3. `line-height<height` 文字偏上\n4. `font`行高可以跟单位也可以不跟,如果不跟，则是是的倍数\n\n## 背景\n\n1. background-repeat: repeat,no-repeat,repeat-x,repeat-y\n2. background-position: x y   (方位名词与顺序无关)\n\n{% folding green, 查看注意事项 %}\n- 精确单位，和混合单位\n- background-attachment: scroll |fixed\n- 背景复合属性  背景颜色，背景图片地址，背景平铺，背景图像滚动，背景位置\n- 半透明 rgba(0,0,0, 0.3)\n- 精灵图减少服务器的加载图片次数\n\n{% endfolding %}\n\n## css特性\n\n1. 层叠性，就近原则，后来居上\n2. 继承性inherit，  text-， line- ，color可继承\n3. 优先级 `继承通配符*< 元素<类选择器，伪类<id<行内样式<!important`\n4. 继承的权重为0\n5. 复合选择器有权重的叠加\n\n## 盒子模型\n\n<span class=\"inline-tag blue\">边框</span>  <span class=\"inline-tag green\">边距</span>\n\n### 边框border\n\n1. 复合写法 border: 边框宽度，样式，颜色  没有顺序 solid\n2. 细线边框 `border-collapse:collapse`合并细线\n\n### 内边距padding\n\n1. padding会影响盒子的大小\n2. 指定高度height不指定宽度 padding不会撑开宽度的盒子\n\n### 外边距margin\n\n1. 和padding类似\n\n2. 外边距合并，塌陷问题\n\n{% folding green, 解决方法 %}\n\n1. 可以为父元素定义上边框\n2. 可以刻父元素定义上内边距\n3. 可以为父元素添加overflow:hidden\n\n{% endfolding %}\n3. 使用通配符解决浏览器的默认的内外边距·`* {padding:0;margin:0}`\n\n## 圆角边框\n\n> border-radius 根据圆半径的大小变化\n","categories":["web","css"]},{"title":"Css学习笔记(4)","url":"/posts/2b1a96d5/","content":"\n<div class=\"tip socd font5 fas fa-bell faa-horizontal animated\"><p>Css学习整理</p><p></p></div>\n\n\n\n## font复合属性\n\n1. font: font-style,font-weight,font-size/line/height,font-family\n2. font-size和font-family两个属性不能省略\n\n## 文本属性\n\n> text-decoration 文本修饰 text-indent 文本缩进\n\n## 选择器\n\n### 后代选择器\n\n>元素1 元素2 { 声明 },元素2是元素1的孩子,也可以是孙子,也可以类选择器和后代选择器混合双打\n\n### 子选择器\n\n> 元素1>元素2{ 声明 }，就近原则\n\n### 并集选择器\n\n> 用`,`隔开，格式竖着写，最后一个不加逗号\n\n### 伪类选择器\n\n1. `:`伪类选择器\n2. 链接伪类选择器：`a:link`  未访问过的链接，`a:visited` 点击后的效果， `a:hover` 经过的时候的效果，`a:action` 活动的效果，按照顺序\n3. focus伪类选择器  `input:focus { }`\n\n## 元素\n\n1. 文字标签内不能放块元素\n2. 链接里面不能放链接，a标签里面可以放块元素\n3. 行内块元素 img,input,td\n4. 行内元素不能直接设置高度\n5. 块级元素转化行级元素 `display: inline`,行级元素转化为块级元素`display:block`","categories":["web","css"]},{"title":"Css学习笔记(3)","url":"/posts/55788fd6/","content":"<div class='tip warning faa-horizontal animated'><p>Css学习整理，记录容易忘掉的一些内容</p><p>本次内容包括Css字体，css链接，css列表,css表格等</div>\n\n## css字体\n\n- font-variant:把段落设置为小型的大写字母字体\n- 属性有`small-caps`，normal，inherit\n- 16px=1em\n\n## css链接\n\n|a|标签的状态|\n|:--:|:--:|\n|a:link | 普通的，未被点击的链接时候的状态|\n|a:visited |用户已经访问的链接|\n|a:hover| 鼠标指针位于链接的上方|\n|a:active| 链接被点击的时刻|\n\n- 顺序要求\n1. `a:hover` 必须跟在` a:link` 和` a:visited`后面\n2. `a:active` 必须跟在` a:hover`后面\n3. `a:link-a:visited-a:hover-active`\n\n>链接属性可改变链接hover时的字体大小，颜色背景，可以消除下划线text-decoration:none,还可以加入方框类型display:block\n\n## css列表\n\n1. `list-style-type:circle`空心圈无序 `<ul style=\"list-style-type:circle\">无序空心圈</ul>`\n2. `square``<ul style=\"list-style-type:square\">实心黑圈</ul>`\n3. `upper-roman``<ol style=\"list-style-type:upper-roman\">有序</ol>`\n4. `lower-alpha` 有序字母\n5. `ul`无序  `ol`有序\n6. 列表还可以使用图片表示`list-style-image:url('图片链接')`可定义图片的大小类型等等\n7. `list-style-position`属性有inside和outside\n8. `list-style`按顺序设置list-style-type和list-style-position和list-style-image\n\n{% tabs list, -1 %}\n<!-- tab css可能的值 -->\n|值|\t描述|\n|:--:|:--:|\n|none|\t无标记。|\n|disc|\t默认。标记是实心圆。|\n|circle|\t标记是空心圆。|\n|square\t|标记是实心方块。|\n|decimal|\t标记是数字。|\n|decimal-leading-zero|\t0开头的数字标记。(01, 02, 03, 等。)|\n|lower-roman|\t小写罗马数字(i, ii, iii, iv, v, 等。)|\n|upper-roman|\t大写罗马数字(I, II, III, IV, V, 等。)|\n|lower-alpha|\t小写英文字母The marker is lower-alpha (a, b, c, d, e, 等。)|\n|upper-alpha\t|大写英文字母The marker is upper-alpha (A, B, C, D, E, 等。)|\n|lower-greek\t|小写希腊字母(alpha, beta, gamma, 等。)|\n|lower-latin\t|小写拉丁字母(a, b, c, d, e, 等。)|\n|upper-latin|\t大写拉丁字母(A, B, C, D, E, 等。)|\n|hebrew|\t传统的希伯来编号方式|\n|armenian|\t传统的亚美尼亚编号方式|\n|georgian\t|传统的乔治亚编号方式(an, ban, gan, 等。)|\n|cjk-ideographic|\t简单的表意数字|\n|hiragana\t|标记是：a, i, u, e, o, ka, ki, 等。（日文片假名）|\n|katakana|\t标记是：A, I, U, E, O, KA, KI, 等。（日文片假名）|\n|hiragana-iroha\t|标记是：i, ro, ha, ni, ho, he, to, 等。（日文片假名）|\n|katakana-iroha\t|标记是：I, RO, HA, NI, HO, HE, TO, 等。（日文片假名）|\n<!-- endtab -->\n{% endtabs %}\n\n## css表格\n\n1. 表格定义的属性`table`,`th(表头)`,`td(表值)` ，`tr`换行\n\n{% folding green,css表格代码 %}\n```html\n<style>\ntable{\nborder-collapse: collapse;\n}\ntable,td,th{\nborder: 2px solid black;\n}\n</style>\n<table>\n<tr>\n<th>1</th>\n</tr>\n<tr>\n<td>2</td>\n</tr>\n</table>\n```\n{% endfolding %}\n\n## css轮廓\n\n{% folding green,轮廓 %}\n|属性|说明|值|\n|:--:|:--:|:--:|\n|outline|\t在一个声明中设置所有的轮廓属性|\toutline-color, outline-style ,outline-width, inherit\t|\n|outline-color|\t设置轮廓的颜色\t|color-name,hex-number,rgb-number,invert,inherit\t|\n|outline-style|\t设置轮廓的样式\t|none,dotted,dashed,solid,double,groove,ridge,inset,outset,inherit\t|\n|outline-width\t|设置轮廓的宽度\t|thin,medium,thick,length,inherit|\n{% endfolding %}\n\n\n{% folding green, out-style属性 %}\n|值|描述|\n|:--:|:--:|\n|none|\t默认。定义无轮廓。|\n|dotted|\t定义点状的轮廓。|\n|dashed\t|定义虚线轮廓。|\n|solid\t|定义实线轮廓。|\n|double|\t定义双线轮廓。双线的宽度等同于 outline-width 的值。|\n|groove\t|定义 3D 凹槽轮廓。此效果取决于 outline-color 值。|\n|ridge|\t定义 3D 凸槽轮廓。此效果取决于 outline-color 值。|\n|inset\t|定义 3D 凹边轮廓。此效果取决于 outline-color 值。|\n|outset\t|定义 3D 凸边轮廓。此效果取决于 outline-color 值。|\n|inherit|\t规定应该从父元素继承轮廓样式的设置。|\n\n来源：[菜鸟教程](https://www.runoob.com/try/try.php?filename=trycss_outline-style)\n{% endfolding %}","categories":["web","css"]},{"title":"Css学习笔记(2)","url":"/posts/4c63be97/","content":"\n<div class=\"tip wtgo font5 fas fa-bolt faa-horizontal animated\"><p>🔔css学习内容</p><p>css样式-背景，文本，链接等等</p></div>\n\n## css创建\n\n- 插入样式表的方法有三种:\n\n1. 外部样式表(External style sheet)\n2. 内部样式表(Internal style sheet)\n3. 内联样式(Inline style)\n\n- CSS 优先规则：\n\n>内联样式 > id 选择器 > 类选择器 = 伪类选择器 = 属性选择器 > 标签选择器 = 伪元素选择器\n\n## css背景\n- 关键字\n{% tabs bg  %}\n<!-- tab background-repeat -->\n\n|值|描述|\n|:--:|:--:|\n|repeat|\t默认。背景图像将在垂直方向和水平方向重复。|\n|repeat-x|\t背景图像将在水平方向重复。|\n|repeat-y|\t背景图像将在垂直方向重复。|\n|no-repeat\t|背景图像将仅显示一次。|\n|inherit\t|规定应该从父元素继承 background-repeat 属性的设置。|\n<!-- endtab -->\n<!-- tab background-position -->\n\n|单一关键字|\t等价的关键字|\n|----|:--:|\n|center|\tcenter center|\n|top\t|top center 或 center top|\n|bottom|\tbottom center 或 center bottom|\n|right|\tright center 或 center right|\n|left|\tleft center 或 center left|\n<!-- endtab -->\n{% endtabs %}\n\n- 百分比值\n\n```css\nbady{\nbackground-position: 50% 50%;\n}\n//background-position 的默认值是 0% 0%，在功能上相当于 top left。\n```\n- 长度值\n\n```\nbackground-position: 50px 100px;\n//在左上角向右50像素和向下100像素的位置\n```\n- 背景关联(attachment)\n\n```\n background-attachment:fixed\n```\n\n|值|\t描述|\n|----|:--:|\n|scroll\t|默认值。背景图像会随着页面其余部分的滚动而移动。|\n|fixed\t|当页面的其余部分滚动时，背景图像不会移动。|\n|inherit|规定应该从父元素继承 background-attachment 属性的设置。|\n\n## css文本\n\n- 缩进：`text-indent`  百分比%/像素大小px/inherit/\n\n- 水平对齐：`text-align\n\n| 值   | 描述 |\n| :--: | :--: |\n|left|把文本排列到左边。默认值：由浏览器决定。|\n|right|把文本排列到右边。|\n|center|把文本排列到中间。|\n|justify|实现两端对齐文本效果。|\n|inherit|\t规定应该从父元素继承 text-align 属性的值。|\n\n- 字母间距：letter-spacing\n- 字间距： word-spacing\n- 区别就是第一个是字符或者字母间的间距，第二个则是字或单词的间距\n\n2. 字符转换 text-transform\n- text-transform 属性控制文本的大小写。\n```css\nh1 {text-transform:uppercase}//全是大写字母\nh2 {text-transform:capitalize}//定义每个单词首字母大写\np {text-transform:lowercase}//定义全是小写字母\n```\n\n3. 文本装饰 text-decoration\n\n```css\nnone //默认文本样式\t\nunderline //下划线\noverline //上划线\nline-through //中部划线\nblink //文本闪烁\n```\n\n4. 空白空间属性：whiteSpace\n\n\n|值|\t描述|\n|:--:|:--:|\n|normal\t|默认。空白会被浏览器忽略。|\n|pre|\t`空白会被浏览器保留。其行为方式类似 HTML 中的 <pre> 标签。`|\n|nowrap|`文本不会换行，文本会在在同一行上继续，直到遇到 <br> 标签为止。`|\n|pre-wrap|\t保留空白符序列，但是正常地进行换行。|\n|pre-line\t|合并空白符序列，但是保留换行符。|\n|inherit\t|规定应该从父元素继承 white-space 属性的值。|\n\n5.  文本方向directon\n\n- `rtl`  和` ltr`","categories":["web","css"]},{"title":"Css学习笔记(1)","url":"/posts/e5a21adb/","content":"<div class=\"tip ref font5 fas fa-sync faa-horizontal animated\"><p>踏上学习前端的旅途！！</p><p>第一站：css</p></div>\n\n## 什么是css\n\n层叠样式表 (Cascading Style Sheets，缩写为 CSS），是一种 样式表 语言，用来描述 HTML 或 XML（包括如 SVG、MathML、XHTML 之类的 XML 分支语言）文档的呈现。CSS 描述了在屏幕、纸质、音频等其它媒体上的元素应该如何被渲染的问题。\n\n## 思维导图\n\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/cssstudy.jpeg)\n\n## css语法\n1. css基础语法\n- 选择器+声明（属性+值）\n注：多个属性值之间加`;`\n2. css高级语法\n- 选择器可分组，用`,`即可\n- 继承及问题\n>设置body元素，通过 CSS 继承，子元素将继承最高级元素所拥有的属性\n\n## css派生选择器\n\n```css\np strong {\n font-size:12px;\n}\n```\n- 符合 `p strong`规则的才会受影响`<p><strong>字体</p></strong>`\n\n## css ID选择器\n\n- Id 选择器以`“#”`来定义\n`注意`：id属性只能在每个HTML文档中出现一次，id 就是唯一标识, id 的作用就是唯一标识元素, id 在html 中出现多次也不会报错, 但是使用 javascript 访问id 时就会有问题了\n\n## css 类选择器\n\n- 在css文件中，类选择器以一个点显示\n`注意`：类名的第一个字符不能使用数字！它无法在 Mozilla 或 Firefox 中起作用。\n\n和 id 一样，class 也可被用作派生选择器`p.temp{}`  `<p  class=\"temp\">`\n\n## 属性选择器\n\n- css属性选择器用`[]`来表示","categories":["web","css"]},{"title":"2021年新的起点","url":"/posts/b5c4b741/","content":"<div class=\"tip key font5 fas fa-key faa-horizontal animated\"><p>看完这篇文章深有感触。</p><p>尽早的做自己的人生规划，多些努力，少些怨天尤人，机会都是靠自己争取的，加油吧！！！</p></div>\n\n## 关于焦虑\n\n我们之所以会觉得焦虑，无非是因为现在的自己和想象中的自己，很有距离。”而我们离想象中的自己越来越远，很大程度上都是因为我们在一点点地辜负自己。\n\n关于焦虑，我发现我们或多或少地都陷入了一个怪圈，这个怪圈叫：我们看似忙碌，实则焦虑。看起来每天熬夜，却只是拿着手机点了无数个赞；我们总是心血来潮想学习，于是买了很多单词书，再也没有翻开过；我们总是备受刺激想健身，于是找了很多攻略，再也没有动过；我们总是信誓旦旦要读书，于是买了很多书，再也没有打开过。 我们总是花很多时间在社交网络上，把认为有用的东西另存为，直到你的硬盘存满了资料，你还是没有看过。 我们忙碌，可我们却没有真的去了解那些自己精挑细选留下的内容。我们花时间收集，却忘了最重要的其实是花时间去消化。\n\n一本书买了不看也不过是印着字的纸而已；单词书买了不背充其量就是26个字母的排列组合；下载的演讲公开课不听也只是一堆无用的影像，可能你只是随手下载了，就再也没有去看过。于是有一天你发现，堆积的东西已经看不完了。 你看着一个个公开课、一本本单词书，无从下手从而越发焦虑。拖延和等待，是世界上最容易压垮一个人斗志的东西。\n\n那么怎么打败焦虑？打败焦虑的最好办法，就是去做那些让你焦虑的事情。\n\n行动这件事，从来不需要等到什么好天气什么好状态，此时此刻就是永远，此时此刻就是一切。\n\n## 关于梦想和奋斗\n\n我一直坚信，英雄，永远是孤独的，只有小喽啰才扎堆。“二八定律”永远适合在地球的每一个角落：百分之二十的人，占有百分之八十的资产；百分之八十的人，为百分之二十的人服务。\n\n做到优秀还不够，一定要卓越，一定要无可替代才是最重要的。既然优秀不够，就让自己无可替代吧。而无可替代的方式有两种：一是做别人不愿意做的事情；二是把别人都能做好的事情做卓越。这样的人，才是这个社会真正需要的。这条路很远，有很多人都在竞争，而我还会继续让自己强大起来，每天进步一点儿，做别人不愿意做的领域，把别人都能做的领域做绝，才能无可替代。\n\n这世上，真的有人过着你想要的生活，这生活，你也能过，你只需要一点点决心、一点点勇敢、一点点希望和一点点的相信。\n\n没有什么路是白走的，没有什么事情是白做的，这些看似无意义的事情，都是成长的基石。在我们的生命中的每个插曲都有着自己该有的意义，所以不要抱怨为什么不早点儿做，更不要后悔要是做了什么就好了。你有后悔、抱怨的时间，不如整装待发前进起来。有时候只有走错了路，才逐渐明白自己要的未来；只有交错了朋友，才逐渐知道什么是患难见真情；只有爱错过人，才逐渐懂得真爱是什么。\n\n## 关于金钱\n\n你是否想过，一些过于节省的生活，其实就是浪费：你每天都在争论那几角钱，浪费了精力和时间去读书学习；把隔夜的剩菜热了吃，吃坏肚子去医院花更多钱；你省钱不去体检，检查出大病后不得不住院花费更多。你以为你在省钱，却不知道，真正省钱的方式，是去赚钱，是让自己变得更强大，而不是为了几角钱花自己最宝贵的时间去永无休止地争论。\n\n## 关于人际\n\n吸引力法则，你是什么样的人，就会吸引什么样的人。\n\n关于恋爱，找一个能让你进步的人，很重要；找一个能让彼此进步的人，更重要。\n\n关于同事，谁说过能成为朋友的？真正的朋友，是没有利益交集，是能为对方去做一些事的，是能为对方放弃一些利益的人。最好的办法，就是不得罪每个同事，也更别和任何同事掏心地做朋友。\n\n## 关于爱情\n\n真正的感情，是要两个人能聊到一起的；最好的情侣，是能用灵魂平等地交流，是能用心去温暖彼此的两个人。\n\n很多分手的原因，都是互相没有把话讲明白。男的以为女的不愿意见到自己；而女的怕见得频繁感情降温了。双方都想维持住这段感情，却互相都不了解，话没有讲明白，甚至有些话觉得没必要讲明白，感情也就逐渐淡了。误解越深，矛盾也就浮出水面。要知道，结婚前，所有人都在做选择题；结婚后，所有人都在做判断题。\n\n多少感情，不是败给了现实，而是败给了交流。\n\n珍惜年轻时恋人的最好方式其实就是交流，就是把心打开，让对方看到，让他明白，这颗心，依然留着对方的爱。\n\n生命中任何走来的人，只要她曾经让自己变得更优秀，你就没有爱错人。人生本来就孤独，任何陪过自己走完一段寂寞时光的人，都应该用心感激。\n\n感谢那些擦肩而过的人，因为时光证明了他们不是对的人，更重要的是，上天会为你安排一个更适合的，就在不久的将来。\n\n## 关于亲情\n\n离开亲人的分别，是为了更好地团聚。\n\n一个人行走在这个世界上，都是孤独的。父母不会陪你一辈子，幸福的是，中国的父母，会在你成年之后依旧陪伴你很长一段时间。可是，想要在这个世界更好地走，光让人搀扶着你是不够的，你总要一个人孤单地走完一些路，去一些陌生的地方，见一些没有见过的人，吃一些从未吃过的苦。这一切，不是你自己作死，只是为了让自己的羽翼丰满，能更好地陪伴那些不想离开的人。\n\n## 关于读书和学习\n\n所谓学习方法，其实没有什么固定的节奏，适合自己的，才是最好的；有效果的，才是最好的。有时候由于太纠结如何走，竟然连第一步都没有迈出去。这世界上，有多少人，为了第一步能走得潇洒霸气，却一辈子没有迈出第一步。\n\n在每次学习的时候，你是否问过自己，今天要达到什么目标，要走到哪里。没有目的的旅行只能叫漫游，没有目标的学习只是叫看起来很努力。形式什么的，根本没必要纠结，适合自己就好。\n\n读书只能增加自己的见识和文化积淀，是不能让你暴富的，但至少能让你拥有一个体面的生活和一份得体的收入。\n\n（1）在看一本书的时候，问问自己，你想要从中得到什么，然后带着问题去翻阅目录和文字。\n\n（2）如果一本书读了三分之一了还不知道在讲什么，放手吧。\n\n（3）一本书不要超过一周读完，否则太长时间容易读了前面忘记后面，无效阅读。\n\n（4）.读完一本书后，如果觉得是好作品，第二遍才是真正的阅读。\n\n## 勇敢去追求梦想\n\n这世上，除了自己，没有人能决定你的命运。你才是自己生活和青春的主宰者。感谢你，勇敢地做了自己。\n\n其实真正的高手是“特立独行的猪”，并不是去逃避这个世界；是知道这个世界的规则，但有能力游离于这个体系之外，有智慧地区别自己想要的和不得不做的。他们不阿谀奉承，更不愿意被世界改变；他们会做自己不愿意做的，只是为了以后更好地去做自己愿意做的；他们像浪迹天涯的游子一样，但也知道这个社会的规则。\n\n我的总结是，做这样的人，你需要有这样几个特征：一是拥有一技之长，让自己无论去哪儿都能赚到钱；二是不去搞政治，这玩意太复杂；三是明白自己想要的生活，坚定地去追。\n\n关于梦想，我一直不相信努力就能成功的鬼话，因为这个世界很诡异，时势才造英雄。有时候一个很努力的人，毁掉他的，是这个社会。但是，不代表我们就应该自暴自弃，人总要坚强地为自己的理想奋斗过，只要你还记得当年的梦想，那么你就没有变老。\n\n- 来源：简书\n- 作者：[芊芊细语123](https://www.jianshu.com/p/aaa96f279f8f)\n\n\n## 选择\n\n## 计划\n\n## 努力\n\n## 未来\n\n\n","categories":["随笔"]},{"title":"hexo-butterfly底部信息的修改","url":"/posts/83507599/","content":"## 底部美化\n\n1. 加入css，打开主题文件夹，找到`function.styl`文件路径`\\themes\\butterfly\\source\\css\\_global`\n2. 将以下代码加入即可，或者直接加入一个css文件自己链接\n```css\n/*底部信息*/\n\n.github-badge {\n    margin-left: 5px;\n    display: inline-block;\n    border-radius: 4px;\n    text-shadow: none;\n    color: #fff;\n    line-height: 15px;\n    background-color: #abbac3;\n    margin-bottom: 5px;\n    font-size: 12px;\n}\n\n.github-badge .badge-subject {\n    display: inline-block;\n    background-color: #4d4d4d;\n    padding: 4px 4px 4px 6px;\n    border-top-left-radius: 4px;\n    border-bottom-left-radius: 4px;\n}\n\n.github-badge .badge-value {\n    display: inline-block;\n    padding: 4px 6px 4px 4px;\n    border-top-right-radius: 4px;\n    border-bottom-right-radius: 4px;\n}\n\n.github-badge .bg-blue {\n    background: linear-gradient(to right, #3a6186, #89253e);\n}\n\n.github-badge .bg-brightgreen {\n    background: linear-gradient(to right, #fc5c7d, #6a82fb);\n}\n\n.github-badge .bg-orange {\n    background: linear-gradient(to right, #f0c27b, #4b1248);\n}\n\n.github-badge .bg-gradient {\n    background: linear-gradient(to right, #3ca5f6, #a86af9);\n}\n\n.github-badge .bg-blueviolet {\n    background: linear-gradient(to right, #654ea3, #eaafc8);\n}\n\n.github-badge .bg-DNS {\n  background: linear-gradient(to right, #aa4b6b, #6b6b83, #3b8d99);\n}\n```\n\n## 修改_config.butterfly.yml\n\n1. 将以下代码修改信息，并加入到footer`custom_text`中\n```html\n<div class=\"github-badge\">\n  <a\n    style=\"color: #fff\"\n    rel=\"external nofollow noopener noreferrer\"\n    href=\"https://hexo.io/\"\n    target=\"_blank\"\n    title=\"由 Hexo 强力驱动\"\n    data-pjax-state=\"\"\n    ><span class=\"badge-subject\"><i class=\"fab fa-superpowers\"></i>Powered</span\n    ><span class=\"badge-value bg-blue\">Hexo</span></a\n  >\n</div>\n<div class=\"github-badge\">\n  <a\n    style=\"color: #fff\"\n    rel=\"external nofollow noopener noreferrer\"\n    href=\"https://cn.aliyun.com/\"\n    target=\"_blank\"\n    title=\"阿里云提供域名相关服务\"\n    data-pjax-state=\"\"\n    ><span class=\"badge-subject\"\n      ><i class=\"fa fa-jsfiddle\" style=\"color: orange\"></i>DNS</span\n    ><span class=\"badge-value bg-DNS\">Aliyun cloud</span></a\n  >\n</div>\n<div class=\"github-badge\">\n  <a\n    style=\"color: #fff\"\n    rel=\"external nofollow noopener noreferrer\"\n    href=\"https://www.upyun.com/?utm_source=lianmeng&amputm_medium=referral\"\n    target=\"_blank\"\n    title=\"又拍云CDN加速\"\n    data-pjax-state=\"\"\n    ><span class=\"badge-subject\"\n      ><img\n        src=\"https://www.upyun.com/static/favicon-16x16.png\"\n        style=\"width: 12px; height: 11px\"\n      />又拍云</span\n    ><span class=\"badge-value bg-blueviolet\">加速 </span></a\n  >\n</div>\n<div class=\"github-badge\">\n  <a\n    style=\"color: #fff\"\n    rel=\"external nofollow noopener noreferrer\"\n    href=\"https://www.beian.miit.gov.cn/\"\n    target=\"_blank\"\n    title=\"备案信息\"\n    data-pjax-state=\"\"\n    ><span class=\"badge-subject\"\n      ><img\n        src=\"xxxxxx\"\n        style=\"width: 12px; height: 11px\"\n      />晋ICP备</span\n    ><span class=\"badge-value bg-orange\">2020009500号-1</span></a\n  >\n</div>\n```\n\n## 看效果图\n\n{% folding green, 查看效果图 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/footer.jpeg)\n{% endfolding %}\n\n## 加入小熊效果\n\n{% folding green, 查看图例 %}\n![](https://7.dusays.com/2021/01/30/e9926e4752b71.gif)\n{% endfolding %}\n\n### 修改footer.pug\n\n1. 末尾位置加入两行代码\n\n```\n.bear\n.bear1\n```\n\n### 将css引入即可\n\n{% folding green, 查看代码 %}\n\n- 手机端已隐藏\n\n```\n/* 底部优化 */\n#footer-wrap .bear{\n  position: absolute;\n  top: 0;\n  width: 200px;\n  height: 100px;\n  background: url(https://7.dusays.com/2021/01/30/ba145b935201b.png) no-repeat;\n  animation: bear .6s steps(8) infinite,bear-move 2s forwards;\n}\n.bear1{\n  position: absolute;\n  top:0;\n  width: 200px;\n  height: 100px;\n  right: 0;\n  background: url(https://7.dusays.com/2021/01/30/68f8d90401d5a.png) no-repeat;\n  transform: rotateY(180deg);\n  animation: bear1 .6s steps(8) infinite,bear-move1 2s forwards;\n}\n@keyframes bear1{\n  0%{\n  }\n  100%{\n      background-position: -1600px 0;\n  }\n}\n@keyframes bear-move1{\n  0%{\n      right: 0%;\n  }\n  100%{\n      right: 25%;\n      /* transform: translate(50%); */\n      /* margin-left: -100px; */\n      margin-right: -100px;\n  }\n}\n\n@keyframes bear{\n  0%{\n  }\n  100%{\n      background-position: -1600px 0;\n  }\n}\n@keyframes bear-move{\n  0%{\n      left: 0%;\n  }\n  100%{\n      left: 25%;\n      transform: translate(-50%);\n      /* margin-left: -100px; */\n  }\n}\n\n@media (max-width: 992px){\n  .bear,.bear1{\n      display: none;\n  }\n}\n```\n\n{% endfolding %}","categories":["技术·教程"]},{"title":"宝塔插件-webhook配置，增加清除日志功能","url":"/posts/8e5b2be1/","content":"\n<div class=\"tip ref font5 fas fa-sync faa-horizontal animated\"><p>在每次同步本地hexo静态文件时，webhooks都会生成一个日志，久而久之日志数量增加，查看日志时不方便，因此添加一个function清除日志功能</p></div>\n\n## 打开webhook文件\n\n1. 打开宝塔webhonk所在的文件位置找到`index.html`\n- 文件路径`/www/server/panel/plugin/webhook/index.html`\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/webhooks_1.jpeg)\n2. 修改`index.html`代码\n3. 修改后效果如下\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/webhooks_0.jpeg)\n\n## 修改html\n\n#### 修改21行左右的代码\n\n- 代码如下-将之前的行限制删除\n\n```html\n<th style=\"text-align: right;\">操作</th> \n```\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/webhook_2.jpeg)\n\n#### 替换79行里面的代码\n\n- 代码如下-直接替换掉\n\n```html\n+'<td>'+mlist[i].title+'</td>'\n\t\t\t\t\t\t\t+'<td>'+getLocalTime(mlist[i].addtime)+'</td>'\n\t\t\t\t\t\t\t+'<td>'+getLocalTime(mlist[i].uptime)+'</td>'\n\t\t\t\t\t\t\t+'<td>'+mlist[i].count+'</td>'\n\t\t\t\t\t\t\t+'<td><a href=\"javascript:showWebHookCode(\\''+mlist[i].url+'\\',\\''+mlist[i].access_key+'\\')\" class=\"btlink\">查看密钥</a></td>'\n                            +'<td><div style=\"text-align: right;\"><a href=\"javascript:RunHook(\\''+mlist[i].access_key+'\\');\" class=\"btlink\">测试</a> | '\n                            +'<a href=\"javascript:OnlineEditFile(0,\\'/www/server/panel/plugin/webhook/script/'+mlist[i].access_key+'\\');\" class=\"btlink\">编辑</a> | '\n                            +'<a href=\"javascript:DeleteHook(\\''+mlist[i].access_key+'\\');\" class=\"btlink\">删除</a></div>'\n                            +'<div style=\"text-align: right;\"><a href=\"javascript:GetLogs(\\'/www/server/panel/plugin/webhook/script/'+mlist[i].access_key+'.log\\');\" class=\"btlink\">日志</a> | '\n                            +'<a href=\"javascript:ClearLogs(\\'/www/server/panel/plugin/webhook/script/'+mlist[i].access_key+'.log\\');\" class=\"btlink\">清除日志</a></div></td>'\n\t\t\t\t\t\t+'</tr>'\n```\n\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/webhoosk_3.jpeg)\n\n#### 在大概138行左右添加function\n\n- 代码如下-这里是添加一个指令可清楚日志\n\n```\n//清除日志\nfunction ClearLogs(path){\nloadT = layer.msg('正在清除...',{icon:16,time:0,shade: [0.3, '#000']});\nvar data='&path='+path\n$.post('/files?action=DeleteFile',data,function(rdata){\nlayer.close(loadT);\nif(!rdata.status) {\nlayer.msg(rdata.msg,{icon:2});\nreturn;\n};\nlayer.msg(rdata.msg,{icon:rdata.status?1:2});\n});\n}\n```\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/webhooks_4.jpeg)\n\n\n","categories":["技术·教程"]},{"title":"hexo本地同时同步服务器和github page","url":"/posts/1bb4b0cb/","content":"\n<div class='tip ffa font5 fas fa-cogs faa-horizontal animated' ><p>由于本人比较懒，但又想实现本地一键同步GitHub和云服务器，所以设置了webhook的脚本指令来实现同步更新并上传</p></div>\n\n## 准备工作\n\n1. 一台云服务器(使用宝塔配置就行)\n2. 一个聪明头\n\n## 注意事项（必看）\n\n>在配置之前必须开放端口，否则会导致配置失败，放行云服务器`7777`端口，宝塔安全组也要开放`7777`端口\n\n- 放行端口可使云服务器连接GitHub仓库\n\n## 思维导图\n\n>本地`hexo d`只能是实现与GitHub的同步，所以要借助GitHub上的webhook实现与云服务器的同步\n\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/dadasdaw_webhook.png)\n\n## 宝塔配置\n\n>使用宝塔想必大家也知道为啥，好用啊（菜鸟专用·me）\n\n1. 使用宝塔的软件商城，下载安装`webhook`\n2. 点击设置将以下代码脚本填入即可\n3. 修改脚本内容，已标`gitpath`和`gitHttp`\n\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/wehookw_2.jpeg)\n\n```\n#!/bin/bash\necho \"\"\n#输出当前时间\ndate --date='0 days ago' \"+%Y-%m-%d %H:%M:%S\"\necho \"Start\"\n\n#git项目路径\ngitPath=\"/www/wwwroot/u.mr90.top\"\n#git要同步的仓库 网址\ngitHttp=\"https://github.com/Rr210/Rr210.github.io.git\"\n \necho \"Web站点路径：$gitPath\"\n \n#判断项目路径是否存在\nif [ -d \"$gitPath\" ]; then\n        cd $gitPath\n        #判断是否存在git目录\n        if [ ! -d \".git\" ]; then\n                echo \"在该目录下克隆 git\"\n               \tsudo git clone $gitHttp gittemp\n                sudo mv gittemp/.git .\n                sudo rm -rf gittemp\n        fi\n        #拉取最新的项目文件\n        sudo git reset --hard origin/master\n        sudo git pull origin master\n        #设置目录权限\n        sudo chown -R www:www $gitPath\n        echo \"End\"\n        exit\nelse\n        echo \"该项目路径不存在\"\n        echo \"End\"\n        exit\nfi\n\n```\n## 复制密钥和链接\n\n1. 打开宝塔webhook然后点击查看密钥，复制`密钥`和`链接`\n\n`注`链接复制`&`前面的哦\n`注`链接复制`&`前面的哦\n`注`链接复制`&`前面的哦\n\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/wehookw_3.jpeg)\n\n## 配置GitHub\n\n1. 打开要仓库点击`settings`设置找到`webhook`\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/wehookw_4.jpeg)\n2. 把刚刚复制的密钥和链接填入即可\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/wehookw_5.png)\n3. 点击update webhook即可\n4. 显示下图状态及配置成功\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/wehookw_6.jpeg)\n\n## 测试配置\n#### 方法一:\n1. 在本地使用`hexo clean`和`hexo g`和`hexo d`\n2. 三连，如果想压缩后上传要使用方法二\n3. 如图所示，则配置成功,查看`宝塔webhook`日志\n\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/wehookw_7.jpeg)\n\n#### 方法二：\n1. 修改文章测试\n2. 使用`gulp`压缩指令\n3. 配置好gulp可使用，看[gulp文章配置]\n(https://www.antmoe.com/posts/b411a3f8/index.html)\n\n```\nhexo clean\nhexo g\ngulp build //相当于压缩后直接hexo d\n```\n\n\n","categories":["技术·教程"]},{"title":"“关于我”界面的美化","url":"/posts/2f211c8e/","content":">灵感来源sakura主题，之前wordpress所使用的关于我界面\n\n- 基于[botui.js](https://botui.org/)制作的,感谢作者[botui](https://github.com/botui/botui) 的框架\n\n## 隐藏按钮\n\n{% checkbox green checked, 使用以下代码实现按钮的隐藏，具体标签外挂的使用看[小康博客](https://www.antmoe.com/posts/3b43914f/index.html) %}\n\n```\n{% hideBlock 这是什么?,#FF7242,#fff %}\n//这里添加自定义内容即可\n{% endhideBlock %}\n```\n## 引入js\n\n- js必须要下载下来自己对照`修改`\n\n{% btn 'https://grr.lanzous.com/iPrqnjhqtqh', 下载地址,fas fa-download, blue larger %}\n\n## 编写about\n\n- 打开`source/about/index.md`将代码填入到合适的位置\n- 主页是添加到隐藏按钮中\n\n```html\n  <div id=\"hello-mashiro\" class=\"popcontainer\" style=\"min-height: 270px; padding: 2px 6px 4px; background-color: rgba(242, 242, 242, 0.5); border-radius: 10px;\">\n    <center>\n    <p>\n    </p>\n    <h4>\n    与 <ruby>\n    Boo（ま)（しろ）<rp>\n    （</rp>\n    <rt>\n    你</rt>\n    <rp>\n    ）</rp>\n    </ruby>\n    对话中...</h4>\n    <p>\n    </p>\n    </center>\n    <bot-ui>\n  </bot-ui>\n</div>\n<script src=\"https://cdn.jsdelivr.net/gh/Rr210/hexofixed@3.0/js/about.js\"></script>//修改这个链接\n<script>\nbot_ui_ini()\n</script>\n  <style>.botui-message {margin: 10px 0;min-height: 20px;}.botui-message-content.human{float:right;margin-bottom:12.2px}.botui-message-content.text{line-height:1.3}.botui-message-content.human{color:#f7f8f8;background-color:#919292}.botui-message-content{width:auto;max-width:85%;display:inline-block}.botui-message-content{padding:7px 13px;border-radius:15px;color:#595a5a;background-color:#ebebeb}</style>\n```\n- `F12`可能会有出错的文件,自己解决一下，能力有限  ","categories":["技术·教程","美化"]},{"title":"Git学习笔记","url":"/posts/21db94ec/","content":"\n<div class=\"snote success\"><p>Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p></div>\n\n\n<span class=\"inline-tag red\">master：默认开发分支</span>   <span class=\"inline-tag green \">orgin：默认远程版本分支 </span>   <span class=\"inline-tag grey\"> head：指向当前分支</span>\n\n## git配置\n\n- 设置用户名\n```\ngit config --global user.name \"username\" //用户名为登录用户名\n```\n\n- 设置邮箱\n```\ngit config --global user.email \"注册时的邮箱\"\n```\n\n## 代码指令\n\n- 克隆github上的仓库源码到本地\n```\ngit clone [url]\n```\n\n## git仓库的创建\n\n1. git初始化\n```\ngit init\n```\n{% checkbox plus green checked, 生成一个隐藏文件git %}\n\n2. 查看文件是否变更\n```\ngit status\n```\n3. 添加文件到缓存区\n```\ngit add .   // 或者git add filename\ngit rm . //删除缓存文件\n```\n{% checkbox checked, 一般使用git add . %}\n`注`在指定文件夹使用git指令\n\n4. 添加备注\n```\ngit commit -m \"这里写备注内容\"\n```\n{% checkbox plus green checked, 在修改添加的文件上会显示备注内容 %}\n\n5. 推送文件到远程仓库master\n```\ngit push origin master\n```\n{% checkbox plus green checked, 可使用其他参数强制推送，在github上存在修改过的文件，要么将他提取到本地，要么使用指令-f直接覆盖 %}\n\n6. 查看历史记录\n```\ngit log\n```\n7. 回溯操作\n```\ngit reset --head 目标版本号\n```\n{% checkbox plus green checked, 恢复到以前发布的指定版本，可使用以下代码 %}\n\n8. 查看文件具体更改内容\n```\ngit diff\n```\n- 可查看修改了哪些内容\n\n## 分支操作\n1. 查看分支\n```\ngit branch\n```\n{% checkbox blue checked, 查看该仓库默认的分支 %}\n\n2. 创建分支\n```\ngit branch 分支名\n```\n{% checkbox blue checked, 本地会生成一个分支 %}\n3. 删除分支\n```\ngit branch -d 分支名\n```\n{% checkbox blue checked, 本地删除一个分支 %}\n\n4. 切换分支\n```\ngit checkout 分支名\n```\n{% checkbox blue checked, 进行分支之间的切换 %}\n\n5. 合并分支\n```\ngit merge 分支名\n```\n{% checkbox blue checked, 进行不同分支之间的合并 %}\n\n## 远程仓库\n1. 解除远程仓库链接\n```\ngit remote rm origin\n```\n\n2. 链接到远程仓库\n```\ngit remote add origin [url]\n```\n{% checkbox blue checked, 本地仓库与远程仓库的链接 %}\n\n3. 拉取远程内容\n```\ngit fetch //或者\ngit pull\n```\n{% checkbox blue checked, 将远程内容拉取到本地origin/master %}\n{% checkbox cyan checked, 相较于git fetch，还进行了merge合并操作，但是需要注意合并的内容是否会产生冲突。 %}\n\n4. 查看远程仓库与本地仓库关系\n```\ngit remote show origin\n```\n{% checkbox cyan checked, 查看远程仓库，以及与本地仓库的关系 %}\n\n\n## 标签指令\n1. 查看标签\n```\ngit tag\n```\n{% checkbox cyan checked, 查看所有的tag %}\n\n2. 添加标签\n```\ngit tag [name]\n```\n添加标签tag，比如v1.0等\n3. 删除本地标签\n```\ngit tag -d <tagname>\n```\n4. 删除远程仓库标签\n```\ngit push origin :refs/tags/<tagname>\n```\n5. 上传单个tag\n```\ngit push origin [tagname]\n```\n\n- 上传所有标签\n```\ngit push origin --tags\n\n```\n\n","categories":["学习笔记","git"]},{"title":"自建网盘利用OneDrive，oneindex网盘","url":"/posts/c1d8341a/","content":">Oneindex不占用服务器空间，不走服务器流量，直接列出 OneDrive 目录，文件直链下载有微软账号即可\n## 准备工作\n\n 1. 微软账号(刚注册的内存空间只有5G大小，需要扩宽内存可自行百度)\n 2. 下载oneindex的源码上传到自己的服务器即可\n 3. 准备一个域名，或者放到自己域名的非根目录下\n 4. 服务器要求PHP空间，PHP 5.6+ 需打开curl支持\n \n## 下载源码并上传\n- <a href=\"\" target=\"_blank\" rel=\"noopener\">下载地址</a>\n- 下载后上传到服务器，根目录或者其他目录，按需安装\n\n## 配置教程\n登录设定的域名，开始部署配置\n\n![](https://img-blog.csdnimg.cn/img_convert/593ee510a026a5c4dfe8e0204d8c4889.png)\n![](https://img-blog.csdnimg.cn/img_convert/c7faab6d7764039c79cb0a49182288b5.png)\n<code>注:第三空将域名填入即可</code>\n>点击蓝色按钮获取`client_id`和`client_secret`\n\n- [ ]  client_secret\n \n![](https://img-blog.csdnimg.cn/img_convert/85bd178412ea2ef928ea472e0134b76a.png)\n\n- [ ] client_id\n >点击上方图片所示的知道了返回快速启动，下滑找到`client_id`\n \n![](https://img-blog.csdnimg.cn/img_convert/e25f8a1d7a76e633a22d68a6258096a9.png)\n- 确认信息后点击下一步\n- <a href=\"\" target=\"_blank\" rel=\"noopener\">演示地址</a> 效果主题为以下主题，按照指示修改即可 \n## 主题使用方法\n\n>主题包中的信息需要修改 主题包<a href=\"\" target=\"_blank\" rel=\"noopener\">下载地址</a>\n\n1. 找到 `nexmoe` 下 `layout.php` 使用打开\n\n   修改 第7行 、第9行 第18行 pan.mr90.top为自己域名（或者自己引用的目录）\n\n   修改 第15行 链接里的QQ 为自己QQ（或者自己引用的图片）\n\n2. 打开 `theme` 下 `style.css` 文件\n\n   修改 第97行、第103行 `pan.mr90.top` 为自己域名（或者自己引用的目录）\n\n   请删除原有 `nexmoe` 主题文件夹，将压缩包内 `nexmoe` 复制到该位置。\n\n3. 将 `theme` 文件夹放在网站根目录.（或者别的地方，可以引用就好）\n\n## Oneindex文件描述\n>文件描述仿照`Github`的README.md文件\n\n 1. 在文件夹底部添加说明\n \n\t\t在 OneDrive 的文件夹中添加`README.md`文件，使用 Markdown 语法。\n\n 2. 在文件夹头部添加说明:\n\n\t\t在 OneDrive 的文件夹中添加`HEAD.md` 文件，使用 Markdown 语法。\n\n 3. 直接输出网页\n\n\t\t在 OneDrive 的文件夹中添加`index.html` 文件，程序会直接输出网页而不列目录。\n配合 文件展示设置-直接输出 效果更佳。\n\n`如图所示`\n\n![](https://img-blog.csdnimg.cn/img_convert/79fffd963f3e055f481e1b13cd251844.png)\n### 给文件夹加密码\n- 新建一个名为`.password`的无后缀格式文件，在其中输入密码\n\n`如图所示`\n![](https://img-blog.csdnimg.cn/img_convert/7913ab22a831027e3e8a152e0308efe6.png)\n`注`密码写入文件夹即可，可以直接在需要加密的文件夹中创建，注意修改文件时看是否有文件后缀(不要犯这个低级错误)\n## 可能出现的问题\n\n - [ ] 安装配置后，域名链接出现了/?/ 如何去掉？\n - [ ] 配置网站的伪静态，代码如下\n - [ ] Nginx 伪静态设置\n\n```\nif (!-f $request_filename){\nset $rule_0 1$rule_0;}\nif (!-d $request_filename){\nset $rule_0 2$rule_0;}\nif ($rule_0 = \"21\"){\nrewrite ^/(.*)$ /index.php?/$1 last;}\n```\n\n`后台`打开去掉`/?/ `(需配合伪静态使用!!)，保存设置\n\n## 命令指示\n>终端命令\n\n```\n//仅能在PHP CLI模式下运行\n//清除缓存：\nphp one.php cache:clear\n//刷新缓存：\nphp one.php cache:refresh\n//刷新令牌：\nphp one.php token:refresh\n//上传文件：\nphp one.php upload:file 本地文件 [OneDrive文件]\n//上传文件夹：\nphp one.php upload:folder 本地文件夹 [OneDrive文件夹]\n```\n\n`例如：`\n\n- //上传`temp.zip` 到OneDrive `根目录`\nphp one.php upload:file temp.zip\n- //上传`temp.zip` 到OneDrive `/test/`目录\nphp one.php upload:file temp.zip /test/\n- //上传`temp.zip` 到OneDrive `/test/`目录并将其命名为 `ad.zip`\nphp one.php upload:file temp.zip /test/ad.zip\n- //上传 `temp/`到OneDrive `/test/`目录(`temp/`为文件夹) \nphp one.php upload:file temp/ /test/\n\n## 定时清除缓存\n- 设置一个定时清除缓存任务\n- 利用宝塔的计划任务\n- 代码如下\n\n```\n*/10 * * * * php /www/wwwroot/pan.mr90.top/one.php cache:refresh\n```\n\n`如图所示`\n\n![](https://img-blog.csdnimg.cn/img_convert/a8b308976dc815a4b20d6ee06095723d.png)\n\n","categories":["技术·教程"]},{"title":"批量修改文件夹名称和文件格式","url":"/posts/d19aae03/","content":"\n<div class=\"tip ban font5 fas fa-ban faa-horizontal animated\"><p>有时候文件过多，文件名很乱，逐一修改特别麻烦，这时候就可使用.bat指令批量修改文件。</p><p></p></div>\n\n## 准备工作\n\n1. 在需要更改的文件夹中新建.bat格式的文件\n2. 按照你的需求复制代码\n\n<code>注:.bat代码可按需修改</code>\n\n## 批量修改文件名\n\n- 复制以下代码到.bat文件中\n\n{% folding green, 查看演示图 %}\n\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/cb0606b5b7a5b64e09011e546ccfb248.jpeg)\n\n{% endfolding %}\n\n```\nset a=1\nsetlocal EnableDelayedExpansion\nFOR /f \"tokens=*\" %%i IN ('dir /a:d /b') \nDO (set /A a+=1ren \"%%i\" \"修改这里，填写文件名称!a!\")\n```\n<code>注:.bat代码可按需修改</code>\n\n## 运行文件\n\n- 双击.bat文件或者右键以管理员身份运行\n\n## 批量修改文件格式\n\n>同理以上操作\n\n```\n@echo off\nset a=1\nsetlocal EnableDelayedExpansion\nfor %%n in (*.jpg) do (set /A a+=1ren \"%%n\" \"文件名称!a!.jpg\")\n```\n<code>注:代码中的文件格式.jpg要前后呼应，按需修改</code>\n\n\n","tags":["windows"],"categories":["技术·教程"]},{"title":"访问GitHub加速，配置Host文件","url":"/posts/c20c86a9/","content":"\n## 查询以下地址的ip\n```\n140.82.114.3 github.com\n185.199.108.153 assets-cdn.github.com\n185.199.109.153 assets-cdn.github.com\n185.199.110.153 assets-cdn.github.com\n185.199.111.153 assets-cdn.github.com\n199.232.5.194 github.global.ssl.fastly.net\n140.82.114.4 gist.github.com\n199.232.96.133 user-images.githubusercontent.com\n199.232.96.133 cloud.githubusercontent.com\n199.232.96.133 camo.githubusercontent.com\n199.232.96.133 avatars2.githubusercontent.com\n199.232.96.133 avatars1.githubusercontent.com\n199.232.96.133 avatars0.githubusercontent.com\n199.232.96.133 avatars3.githubusercontent.com\n199.232.96.133 avatars5.githubusercontent.com\n199.232.96.133 avatars6.githubusercontent.com\n199.232.96.133 avatars4.githubusercontent.com\n199.232.96.133 avatars7.githubusercontent.com\n199.232.96.133 avatars8.githubusercontent.com\n```\n- 为确保无误，自己再去测试以下IP\n- ip查询地址（<a href=\"https://www.ipaddress.com/\" target=\"_blank\" rel=\"noopener noreferrer\">查询</a>)\n\n## 修改Host\n- 修改方法=<a href=\"https://jingyan.baidu.com/article/425e69e6e479a2be15fc16e1.html\" target=\"_blank\" rel=\"noopener noreferrer\">点击这里</a>\n- <code>windows host</code> 路径：C:\\Windows\\System32\\drivers\\etc\\hosts\n- <code>Linux host</code> 路径：/etc/hosts\n- 如图所示\n![](https://img-blog.csdnimg.cn/img_convert/dfe542ad16c45a866e8cb96c19dfba22.png)\n\n## 刷新DNS\n- windows\n```\nipconfig /flushdns\n```\n- Liunx\n```\nsudo /etc/init.d/dns-clean start\nsudo /etc/init.d/networking restart\n```\n","tags":["github"],"categories":["学习笔记","git"]},{"title":"Sakurairo主题的美化篇,底部美化","url":"/posts/2099e19a/","content":"\n## 1.底部美化\n\n>底部加上<code >[站点地图]( https://t.mr90.top/sitemap/)</code>(教程在下篇文章中【[站点地图教程](https://t.mr90.top/build/sitemap_1.html)】关于免责声明，模仿站点地图自建代码，或者自写文章加入即可),响应时间，围观次数，评论次数，文章总数，访问者的ip地址等等，感谢作者<code>KiLLUA</code>\n\n- 底部Github徽章，看文章【[Github徽章效果](https://t.mr90.top/build/git_template.html)】\n![效果](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/35c0cd30e00f93d335cfbd36776dd2d8.jpeg)\n\n## 2.添加代码\n>打开主题theme目录，找到funtion.php文件，将以下代码写入，记得备注，不让到时整理代码，是很难受的 ~ _ ~\n\n```\n//WordPress获取站点总浏览量\nfunction all_view() /*注意这个函数名，调用的就是用它了*/\n{\nglobal wpdb;count=0;\nviews=wpdb->get_results(\"SELECT * FROM wpdb->postmeta WHERE meta_key='views'\");\nforeach(views as key=>value)\n{\nmeta_value=value->meta_value;\nif(meta_value!=' ')\n{count+=(int)meta_value;}\n}\nreturncount;}\n \n/*总评论数*/\nfunction pl_all(){\n    global wpdb;count=0;\n    count=wpdb->get_var(\"SELECT COUNT(*) FROM wpdb->comments\");\n    returncount;\n}\n\n```\n\n- 不需要做修改\n\n## 3.找到footer.php\n\n1.将代码加入到合适的位置，Ctrl+f找到<code>footer-device</code>标签，将以下代码复制进去即可，文字可修改。\n\n```html\n<div class=\"footer-device\"><p style=\"font-family: 'zhanku', sans-serif;\"><span style=\"color: #b9b9b9;\"><a href=\"https://t.mr90.top/sitemap/\" target=\"_blank\" style=\"color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);\">站点地图</a> | <a href=\"#\" target=\"_blank\" style=\"color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);\">免责声明</a> | <?php timer_stop(1); ?>秒\t\t\n </br>\t\t\t\n被围观了：<font style=\"color:#F00; font-weight:bold;\"><?php echo all_view(); ?></font>次\n| 总评论：<font style=\"color:#F00; font-weight:bold;\"><?php echo pl_all()?></font>篇\n| 文章总数：<font style=\"color:#F00; font-weight:bold;\"><?php echo wp_count_posts()->publish;?></font> 篇\n</br>\n<font style=\"color:#00a8ff; font-weight:bold;\">\n<?php\n/*打开文件用于记录访问量，如果文件不存在自动创建*/\n$counterFile = \"counter.txt\";\n$fp = fopen($counterFile,\"a+\");\n/*获取IP*/\n$adress=$_SERVER[\"REMOTE_ADDR\"]; \t\t\t\t\t\n/*统计访问量*/\n$num = fgets($fp,5);\n$num += 1;\nprint  \"您是第\".\"$num\".\" 位访客，\".\" 您的IP是:[\".\"$adress\".\"]\";\n/*关闭文件，重新以只写的方式打开*/\nfclose($fp);\n$fpp=fopen($counterFile,\"w\");\n/*更新变量$fpp的值*/\nfwrite($fpp, $num);\nfclose($fpp);\t\t\t\t\t\t\t\n?>\t</font>\n</br>\n在线人数：<font style=\"color:#F00; font-weight:bold;\">\n<?php\n//首先你要有读写文件的权限，首次访问肯不显示，正常情况刷新即可\n$online_log = \"maplers.dat\"; //保存人数的文件到根目录,\n$timeout = 30;//30秒内没动作者,认为掉线\n$entries = file($online_log);\n$temp = array();\nfor ($i=0;$i<count($entries);$i++){\n$entry = explode(\",\",trim($entries[$i]));\nif(($entry[0] != getenv('REMOTE_ADDR')) && ($entry[1] > time())) {\narray_push($temp,$entry[0].\",\".$entry[1].\"\\n\"); //取出其他浏览者的信息,并去掉超时者,保存进$temp\n}}\narray_push($temp,getenv('REMOTE_ADDR').\",\".(time() + ($timeout)).\"\\n\"); //更新浏览者的时间\n$maplers = count($temp); //计算在线人数\n$entries = implode(\"\",$temp);\n//写入文件\n$fp = fopen($online_log,\"w\");\nflock($fp,LOCK_EX); //flock() 不能在NFS以及其他的一些网络文件系统中正常工作\nfputs($fp,$entries);\nflock($fp,LOCK_UN);\nfclose($fp);\necho \"\".$maplers.\"\";\n?> </font>人\n最后更新：<font style=\"color:#F00; font-weight:bold;\"><?php $last = $wpdb->get_results(\"SELECT MAX(post_modified) AS MAX_m FROM $wpdb->posts WHERE (post_type = 'post' OR post_type = 'page') AND (post_status = 'publish' OR post_status = 'private')\");$last = date('Y年n月j日', strtotime($last[0]->MAX_m));echo $last; ?></font>\n```\n\n- 代码文字可自行删减，建议保留主题原作者\n\n","categories":["技术·教程"]},{"title":"Sakurairo主题的美化篇,底部自制站点地图","url":"/posts/142d48c6/","content":"## 1.sitemap是什么？\n 1.<code>Sitemap</code> 可方便网站管理员通知搜索引擎他们网站上有哪些可供抓取的网页。最简单的 Sitemap 形式，就是XML 文件，在其中列出网站中的网址以及关于每个网址的其他元数据（上次更新的时间、更改的频率以及相对于网站上其他网址的重要程度为何等），以便搜索引擎可以更加智能地抓取网站。\n2. 有两种形式的sitemap：<code>html格式</code>方便用户查看阅读文章；<code>xml格式</code>的方便搜索引擎爬取收录.\n## 2.制作博客底部html格式的sitemap\n- 感谢原作者<code>Killua</code>\n- 将以下代码加入到<code>theme/主题</code>的根目录,新建一个<code>sitemap.php</code>文件\n- 加入之后引入到底部站点地图位置{https://t.mr90.top/sitemap/}\n\n```\n<?php\n/*\n Template Name: Sitemap\n*/\n?>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head profile=\"http://gmpg.org/xfn/11\">\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=<?php bloginfo( 'charset' ); ?>\" />\n<title>站点地图 - <?php bloginfo('name'); ?></title>\n<meta name=\"keywords\" content=\"站点地图,<?php bloginfo('name'); ?>\" />\n<meta name=\"copyright\" content=\"<?php bloginfo('name'); ?>\" />\n<link rel=\"canonical\" href=\"<?php echo get_permalink(); ?>\" />\n<style type=\"text/css\">\n    body {font-family: Microsoft Yahei,Verdana;font-size:13px;margin:0 auto;color: #000000;background: #ffffff;width: 990px;margin: 0 auto}\n    a:link,a:visited {color:#000;text-decoration:none;}\n    a:hover {color:#08d;text-decoration:none;}\n    h1,h2,h3,h4,h5,h6 {font-weight:normal;}\n    img {border:0;}\n    li {margin-top: 8px;}\n    .page {padding: 4px; border-top: 1px #EEEEEE solid}\n    .author {background-color:#EEEEFF; padding: 6px; border-top: 1px #ddddee solid}\n    #nav, #content, #footer {padding: 8px; border: 1px solid #EEEEEE; clear: both; width: 95%; margin: auto; margin-top: 10px;}\n</style>\n</head>\n<body vlink=\"#333333\" link=\"#333333\">\n<h2 style=\"text-align: center; margin-top: 20px\"><?php bloginfo('name'); ?>'s SiteMap </h2>\n<center></center>\n<div id=\"nav\"><a href=\"<?php bloginfo('url'); ?>/\"><strong><?php bloginfo('name'); ?></strong></a> » <a href=\"<?php echo get_permalink(); ?>\">站点地图</a></div>\n<div id=\"content\">\n<h3>最新文章</h3>\n<ul>\n<?php\n$previous_year = $year = 0;\n$previous_month = $month = 0;\n$ul_open = false;\n$myposts = get_posts('numberposts=-1&orderby=post_date&order=DESC');\nforeach($myposts as $post) :\n?>\n<li><a href=\"<?php the_permalink(); ?>\" title=\"<?php the_title(); ?>\" target=\"_blank\"><?php the_title(); ?></a></li>\n<?php endforeach; ?>\n</ul>\n</div>\n<div id=\"content\">\n<li class=\"categories\">分类目录<ul>\n<?php wp_list_categories('title_li='); ?>\n</ul></li>\n</div>\n<div id=\"content\">\n<li class=\"categories\">单面页</li>\n<?php wp_page_menu( $args ); ?>\n</div>\n<div id=\"footer\">查看博客首頁: <strong><a href=\"<?php bloginfo('url'); ?>/\"><?php bloginfo('name'); ?></a></strong></div><br />\n<center>\n<div style=\"text-algin: center; font-size: 11px\"><strong><a href=\"#\" target=\"_blank\">Baidu-SiteMap</a></strong> Latest Update: <?php $last = $wpdb->get_results(\"SELECT MAX(post_modified) AS MAX_m FROM $wpdb->posts WHERE (post_type = 'post' OR post_type = 'page') AND (post_status = 'publish' OR post_status = 'private')\");$last = date('Y-m-d G:i:s', strtotime($last[0]->MAX_m));echo $last; ?><br /><br /></div>\n</center>\n</body>\n</html>\n```\n- 可修改代码，自行解决~~\n\n## 3.制作xml格式sitemap\n\n- 将此文件导入到<code>站点的根目录</code>下，方便搜索引擎爬取\n- 如果不想加入此代码，可使用wordpress插件【[Yoast SEO ](https://downloads.wordpress.org/plugin/wordpress-seo.latest-stable.zip)】\nyoast seo会自动生成站点地图\n\n```html\n<?php\nrequire('./wp-blog-header.php');\nheader(\"Content-type: text/xml\");\nheader('HTTP/1.1 200 OK');\nposts_to_show = 1000;\necho '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\necho '<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:mobile=\"http://www.baidu.com/schemas/sitemap-mobile/1/\">'\n?>\n<!-- generated-on=<?php echo get_lastpostdate('blog'); ?> -->\n  <url>\n      <loc><?php echo get_home_url(); ?></loc>\n      <lastmod><?phpltime = get_lastpostmodified(GMT);ltime = gmdate('Y-m-d\\TH:i:s+00:00', strtotime(ltime)); echo ltime; ?></lastmod>\n      <changefreq>daily</changefreq>\n      <priority>1.0</priority>\n  </url>\n<?php\n/* 文章面頁 */\nheader(\"Content-type: text/xml\");myposts = get_posts( \"numberposts=\" . posts_to_show );\nforeach(myposts as post ) { ?>\n  <url>\n      <loc><?php the_permalink(); ?></loc>\n      <lastmod><?php the_time('c') ?></lastmod>\n      <changefreq>monthly</changefreq>\n      <priority>0.6</priority>\n  </url>\n<?php } /* 文章循環結束 */ ?>\n<?php\n/* 單面頁 */mypages = get_pages();\nif(count(mypages) > 0) {\n    foreach(mypages as page) { ?>\n    <url>\n      <loc><?php echo get_page_link(page->ID); ?></loc>\n      <lastmod><?php echo str_replace(\" \",\"T\",get_page(page->ID)->post_modified); ?>+00:00</lastmod>\n      <changefreq>weekly</changefreq>\n      <priority>0.6</priority>\n  </url>\n<?php }} /* 單面頁循環結束 */ ?>\n<?php\n/* 博客分類  aabbj.com*/terms = get_terms('category', 'orderby=name&hide_empty=0' );\ncountcount = count(terms);\nif(count > 0){\nforeach (terms as term) { ?>\n    <url>\n      <loc><?php echo get_term_link(term, term->slug); ?></loc>\n      <changefreq>weekly</changefreq>\n      <priority>0.8</priority>\n  </url>\n<?php }} /* 分類循環結束 */?>\n<?php\n /* 標籤(可選) */tags = get_terms(\"post_tag\");\nforeach ( tags askey => tag ) {link = get_term_link( intval(tag->term_id), \"post_tag\" );\n         if ( is_wp_error(link ) )\n          return false;\n          tags[key ]->link = link;\n?>\n <url>\n      <loc><?php echolink ?></loc>\n      <changefreq>monthly</changefreq>\n      <priority>0.4</priority>\n  </url>\n<?php  } /* 標籤循環結束 */ ?>\n</urlset>\n```\n\n- 将代码放到站点根目录 不是主题根目录哦，文件名建议sitemap.php,然后修改 <code>.htaccess</code>加入代码\n\n```html\nRewriteRule ^(sitemap)\\.xml1.php\n```\n\n## 4.去各大搜索引擎提交站点地图\n\n- 就比如谷歌收录查询【[谷歌](https://search.google.com/search-console/)】\n- 将你的站点地图填入就行,如图\n\n![sitemap](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/df3d5493857d4f9dbca37ab5834e8d28.jpeg)\n","categories":["技术·教程"]},{"title":"Redis配置教程，大幅度加速WordPress网站","url":"/posts/44bdc15b/","content":"\n## 1.redis\n     Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。\n\n## 2.安装php扩展\n\n- 这里我使用的是<code>宝塔</code>，首先打开软件商城，找到php点击设置安装扩展，如下图\n\n![安装redis即可](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/d7d6c380fd4abe5e4726d961326719bb.jpeg)\n\n## 3.进入wordpress后台\n\n1.安装插件<code>Redis Object Cache</code>和<code>W3 Total Cache</code>\n![](https://cdn.jsdelivr.net/gh/Rr210/image@master/hexo/3/1b8f016c528791f7894c7b52baacf51c.jpeg)\n2.如果显示502无法安装，这里我提供了两种方法\n\n(1)第一种：安装插件 <code>WP-china-Yes</code>国内服务器使用\n\n【[下载地址](https://grr.lanzous.com/iBF5viivlxg)】安装完之后再去下载redis和w3\n\n(2)第二种：直接下载然后上传到wordpress\n\n- <div class=\"github-badge\"><a style=\"color:#FFFFFF\" href=\"https://downloads.wordpress.org/plugin/redis-cache.2.0.15.zip\"><span class=\"badge-subject\"><i style=\"color:#0071b2\" class=\"fa fa-cloud-download\"></i>官网</span><span class=\"badge-value bg-blueviolet\">下载地址</span></a></div>\n\n<ul><li><div class=\"github-badge\"><a style=\"color:#FFFFFF\" href=\"https://grr.lanzous.com/b015wtlcb\" target=\"_blank\" rel=\"noopener noreferrer\"><span class=\"badge-subject\"><i class=\"fa fa-cloud-download\" style=\"color:#0071b2\"></i>蓝奏</span><span class=\"badge-value bg-blueviolet\">下载地址</span></a></div></li></ul>\n\n安装之后打开<code>Redis Object Cache</code>点击第一个按钮，其他默认，显示<code> connect</code> 说明配置已完成\n\n## 4.配置缓存设置\n\n1.网络上好多人都是在wp_config.php中配置，我设置完之后，刷新页面感觉速度明显加强，基本完成，如果效果不明显，继续配置\n2.找到<code>wp_config.php</code>将以下代码写入即可，注意redis的密码是否设置\n\n```\ndefine('WP_REDIS_CLIENT', 'pecl'); // 指定用于与 Redis 通信的客户端, pecl 即 The PHP Extension Community Library\ndefine('WP_REDIS_SCHEME', 'tcp'); // 指定用于与 Redis 实例进行通信的协议\ndefine('WP_REDIS_HOST', '127.0.0.1'); // Redis 服务器的 IP 或主机名\ndefine('WP_REDIS_PORT', '6379'); // Redis 端口\ndefine('WP_REDIS_DATABASE', '0'); // 接受用于使用该 SELECT 命令自动选择逻辑数据库的数值\ndefine('WP_REDIS_PASSWORD', '这里看你自己设定的'); // Redis 密码\ndefine('WP_CACHE_KEY_SALT', 'wp_'); // 设置所有缓存键的前缀（ WordPress 多站点模式下使用）\ndefine('WP_REDIS_MAXTTL', '86400');\n```\n\n\n\n","tags":["PHP"],"categories":["技术·教程"]},{"title":"自制作api图片 简单的步骤","url":"/posts/b9aff39c/","content":"> 原作者：[爱吃猫的鱼](https://blog.csdn.net/qq_43640009/article/details/107945584)\n\n## 1.准备工作\n\n- 准备域名(有一个即可)\n- 服务器 学生机即可\n- 可上传图片CDN的服务器<code>推荐:又拍云</code>\n\n## 2.图片上传\n\n```\n将自己喜欢的图片上传到CDN服务器\n```\n\n- 我这里准备了几个高清的图片\n- 下载地址：【[4k超清动漫壁纸](https://grr.lanzous.com/iZVkIi9r9kd)】\n\n## 3.编写代码\n\n- 准备两个文件 img.txt 和random.php 文件\n- 写入一下代码，上传到服务器\n\n```\n/* img.txt 文件里面编写从又拍云获取的路径 要求所有图片的路径 一行一个*/\n/* random.php 文件中的代码如下 复制粘贴即可 */\n<?php\n//存有美图链接的文件名img.txt\n$filename = \"img.txt\";\nif(!file_exists($filename)){\n    die('文件不存在');\n}\n//从文本获取链接\n$pics = [];\n$fs = fopen($filename, \"r\");\nwhile(!feof($fs)){\n    $line=trim(fgets($fs));\n    if($line!=''){\n        array_push($pics, $line);\n    }\n} \n//从数组随机获取链接\n$pic = $pics[array_rand($pics)]; \n//返回指定格式\n$type=$_GET['type'];\nswitch($type){\n//JSON返回\ncase 'json':\n    header('Content-type:text/json');\n    die(json_encode(['pic'=>$pic]));\ndefault:\n    die(header(\"Location: $pic\"));\n}\n?>\n```\n>将两个文件上传到服务器的域名文件下即可\n\n## 4.访问random.php域名\n\n>https://你的域名/(子文件夹)/random.php\n>文件夹和文件名称可以自定\n","categories":["技术·教程"]},{"title":"关于Font Awesome图标的使用 加入动态效果","url":"/posts/f96403a2/","content":"\n## 1.引入CSS\n\n```\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/font-awesome-animation@0.2.1/dist/font-awesome-animation.min.css\">\n```\n\n## 2.修改HTML\n\n>加入font  parent awesome 的class元素 \n\n```\n<!--<a>标签也可以-->\n<div class=\"faa-parent animated-hover\"><i class=\"fa fa-github faa-horizontal\"></i></div>\n/*<i>标签中空格前半部分为 图标的样式后半部分为图标的动态效果*/\n```\n- 图标样式可参考【[这里](https://www.runoob.com/font-awesome/fontawesome-reference.html)】\n- 动态样式可参考【[这里](https://l-lin.github.io/font-awesome-animation/)】\n- 测试效果可参考我的主页【[演示界面](https://mr90.top)】\n\n## 3.转载注意\n\n- 标明出处即可","tags":["github"],"categories":["技术·教程"]},{"title":"SQL Server express2008的安装方法","url":"/posts/251f2fdc/","content":"\n## 准备工作\n\n>下载sql server文件 和SSMS文件\n\n## 1.下载解压SQL Serve文件\n\n>准备工作确保计算中有net2/net3\n>解压后点击SQLEXPR_x64_CHS.exe\n\n## 2.操作步骤\n\n- 视频教程\n\n- [安装sql教程](https://www.bilibili.com/video/BV12y4y1B71o)\n\n- [视频地址](https://mr90.top/blog/wx-page/sql-server-express.html)\n- 1.可能出现的问题：（防火墙）\n>关闭防火墙\n\n```\nwin+r  打开系统命令行-输入以下指令\ncontrol.exe /name Microsoft.WindowsFirewall\t\n关闭防火墙\n```\n\n- 2.可能出现的问题：（出现跨语言错误）\n>安装过程中切勿关掉 安装安全中心\n\n- [防火墙及等问题](https://www.bilibili.com/video/BV1S54y1r79q)\n- [视频地址](https://mr90.top/blog/wx-page/sql-server-express.html)\n\n## 3.SQL Server环境配置\n\n- 检测SQL Server配置服务的状态\n\n```\n1. Ctrl+alt+delete或者任务栏右键调出【任务管理器】\n2.点击服务 下滑找到3个服务，看是否都已启用\n3.sql service （MssQl SERBER)\n  sql server Anaiysis server(MSSQLSERVER)\n  SQL SERVER VSS Writer\n```\n## 4.安装配置成功后安装SSMS\n\n```\n方法如同SQL Server的步骤基本相同\n```\n\n- [SSMS 视频教程](https://www.bilibili.com/video/BV1h54y1r7j6/)\n\n- [视频地址](https://mr90.top/blog/wx-page/sql-server-express.html)\n\n## 5.分享一下我的公众号和小程序\n\n```\n不定时更新哦！\n感谢关注\n```\n\n- 如有疑问联系客服，小程序即可直接联系\n- 禁止转载，严禁商用，如若转载标明来源","tags":["SQL"],"categories":["学习笔记"]},{"title":"个人主页的小更新（加入实时天数，实时浏览人数，github徽章等）","url":"/posts/3c28c0f5/","content":"\n## 1.加入实时天数\n- 主页【Harry](https://mr90.top)】\n- 代码如下：（直接引用到网页即可）\n\n```\n<span id=\"runtime_span\"></span> \n<script type=\"text/javascript\">function show_runtime(){window.setTimeout(\"show_runtime()\",1000);X=new \nDate(\"12/31/2019 00:00:00\");\nY=new Date();T=(Y.getTime()-X.getTime());M=24*60*60*1000;\na=T/M;A=Math.floor(a);b=(a-A)*24;B=Math.floor(b);c=(b-B)*60;C=Math.floor((b-B)*60);D=Math.floor((c-C)*60);\nruntime_span.innerHTML=\"本站运行:\"+A+\"天\"+B+\"小时\"+C+\"分\"+D+\"秒\"}show_runtime();\n</script> \n```\n## 2.加入实时浏览人数\n\n- 访客github徽章\n- 原作者【[链接](https://visitor-badge.laobi.icu/#)】【[github](https://github.com/hehuapei/visitor-badge)】\n- 使用一行js代码即可\n- 修改【page_id=】添加一个自定义id，例如https://visitor-badge.glitch.me/badge?page_id=mr90.top\n```\n <span>浏览人数：<img src=\"https://visitor-badge.glitch.me/badge?page_id=(添加一个你自己的id)\" alt=\"访客人数\"></span>\n```\n## 3.底部加入github徽章\n\n- 原作者【[链接](https://shields.io/)】\n- 代码如下：<img标签>\n\n```\n<img src=\"https://img.shields.io/badge/<LABEL>-<MESSAGE>-<COLOR>.svg\">\ncolor的颜色有：brightgreen，green，yellow，greenyellow，orange，red，blue，lightgrey，success，important，critical，informational，inactive，blue，violet，ff69b4，9cf\n```\n- 修改中间的<>里面的，用 【- 】链接\n- markdown文章的GitHub徽章的写法如下\n\n```\n[![GitHub]()]()\n或者<img src=\"https://img.shields.io/badge/Github-托管-brightgreen.svg\">\n```\n- 可能遇到的问题，显示图片转存失败直接用【img标签即可】\n- <img src=\"https://img.shields.io/badge/Github-托管-brightgreen.svg\">\n\n## 4.网站加载耗时\n\n- 引入一个js代码即可\n- 代码如下：\n\n```\n    <!--加载耗时-->\n    <body onload=\"onLoad()\">\n    <script src=\"https://cdn.mr90.top/js/timejz.js\"></script>\n    <p id=\"i\"></p> \n    </body>\n```\n- 想获取源代码，直接网址查看即\n\n## 3.分享一下我的公众号和小程序\n\n```\n不定时更新哦！\n感谢关注\n```\n\n- 如有疑问联系客服，小程序即可直接联系\n- 禁止转载，严禁商用，如若转载标明来源\n","categories":["技术·教程"]},{"title":"deepin系统安装后检测不到声卡，无声音","url":"/posts/e4e43667/","content":"\n## 1.准备工作\n\n```\n1.检查电脑是否能够检测到声卡的输入输出\n方法：设置里面-声音-高级设置-看是否有输出输入设备\n2.确认声卡是否出现物理损坏导致的物理信息无法被系统读取\n代码指令：\nsudo lspci | grep audio \nsudo lspci -v\n看是否有类似的声卡反馈\n```\n## 2.修改grub文件内容\n\n```\n1.修改grub文件里面的文件  添加一个指令即可\nGRUB_CMDLINE_LINUX_DEFAULT=\"${这里你的原有配置不要动} snd_hda_intel.dmic_detect=0\"\n指令如下：\n```\n\n```bash\n#进入root模式\nsu \ncd /etc/default/\nvi grub\n# 将此代码snd_hda_intel.dmic_detect=0 加入grub即可\n# 1.按键盘i 进入插入模式，修改添加代码后\n#2.【esc】然后 按【：】输入 【w！】\nreboot #重启即可\n```\n## 3.分享一下我的公众号和小程序\n```\n不定时更新哦！\n感谢关注\n```\n\n- 如有疑问联系客服，小程序即可直接联系\n- 禁止转载，严禁商用，如若转载标明来源\n","tags":["liunx"],"categories":["Liunx"]},{"title":"deepin系统无法连接到自己的wifi","url":"/posts/10c1848e/","content":"\n## 1.deepin系统网卡驱动问题\n```\n1.网卡驱动的问题，无法链接wifi\n需要删除 iwlwifi.conf  \n此文件（路径：/etc/modprobe.d/iwlwifi.conf）\n```\n-如何删除 使用liunx命令\n\n```bash\n#首先进入root模式,按顺序即可\nsu\ncd /etc/modrobe.d/\nrm -f iwlwifi.conf #强制删除文件\nls #检查文件是否删除\nreboot #重启系统\n```\n## 2.分享一下我的公众号和小程序\n\n```\n不定时更新哦！\n感谢关注\n```\n\n- 如有疑问联系客服，小程序即可直接联系\n- 禁止转载，严禁商用，如若转载标明来源\n\n","tags":["liunx"],"categories":["Liunx"]},{"title":"安装双系统 windows系统+deepin（liunx）系统","url":"/posts/d8b03f83/","content":"## 1.准备工作\n\n```\n准备一个u盘，用来制作deepin启动盘，在deepin官网安装镜像文件并制作u盘\n安装系统前，检查电脑是否有空闲的硬盘空间，大概需要25g  没有要进行分盘操作\n分盘方法/步骤\n1.右键点击此电脑，点击管理。\n2.点击磁盘管理。\n3.鼠标右键点击你要进行分区的磁盘，点击压缩卷。\n4.点击压缩（压缩大概102400MB）。\n5.显示可用空间为100g即可，准备工作就完成了\n点击完成即可。\n```\n\n- 制作U盘操作看官网【[deepin官网](https://www.deepin.org/zh/download/)】\n\n## 2.如何安装\n\n```\n双系统是手动装盘哦，步骤简单，看官网就OK\n如何安装我就不说了，注意安装过程中最后【勾选】集成NVidia驱动\n看官网的操作就行\n链接如下：\n```\n- 如何安装？【[点击](https://www.deepin.org/zh/installation/)】\n\n## 3.分享一下我的公众号和小程序\n```\n不定时更新哦！\n感谢关注\n```\n\n- 如有疑问联系客服，小程序即可直接联系\n- 禁止转载，严禁商用，如若转载标明来源\n\n\n\n","tags":["liunx"],"categories":["Liunx"]},{"title":"Python学习笔记","url":"/posts/297a89d9/","content":"\n## Python||基础学习\n\n>Python基础已更新到微信公众号中，文章如下 复制链接(或者直接打开)\n\n1. <a href=\"https://mp.weixin.qq.com/s/FIMF2Yml4EJGhuJH96ywnA\" target=\"_blank\" rel=\"noopener noreferrer\">Python||了解Python并安装环境</a>\n\n2. <a href=\"https://mp.weixin.qq.com/s/Z1r6RBsE3csMjOx-tWDccw\" target=\"_blank\" rel=\"noopener noreferrer\">Python||编辑器的安装和环境配置</a>\n\n3. <a href=\"https://mp.weixin.qq.com/s/9T_adO4-KVn4-5n_yO4oFQ\" target=\"_blank\" rel=\"noopener noreferrer\">Python||Python的基础语法</a>\n\n4. <a href=\"https://mp.weixin.qq.com/s/vwkbnBYZddSHcBxoya_GJQ\" target=\"_blank\" rel=\"noopener noreferrer\">Python||Python3的基础数据类型</a>\n\n5. <a href=\"https://mp.weixin.qq.com/s/RCztBYQ2oqE0c06BYP-WRQ\" target=\"_blank\" rel=\"noopener noreferrer\">Python||注释，运算符，解释器</a>\n\n6. <a href=\"https://mp.weixin.qq.com/s/4R4VjGlO1lqttgMzna8ZkA\" target=\"_blank\" rel=\"noopener noreferrer\">Python||字符串的学习-基础</a>\n\n7. <a href=\"https://mp.weixin.qq.com/s/-YTTTdboBAeVMZiPRrkxvQ\" target=\"_blank\" rel=\"noopener noreferrer\">Python||Python 的字符串内建函数</a>\n\n<h6><a id=\"_20\" class=\" cc_cursor\"></a>来源：菜鸟教程</h6>\n\n<blockquote>笔记自行学习整理\n\n仅供个人学习，感兴趣可以去了解一下</blockquote>","tags":["Python"],"categories":["Python"]},{"title":"markdown学习笔记","url":"/posts/d7bdf81a/","content":"<code>本文主要记录markdown常用的符号</code>\n\n<hr />\n\n<h4>标题</h4>\n\n<pre><code class=\"line-numbers\">使用`#`\n</code></pre>\n\n<h4>换行</h4>\n\n<pre><code class=\"line-numbers\">末尾空两格(或者使用换行符>_)\n</code></pre>\n\n<h4>删除线</h4>\n\n<pre><code class=\"line-numbers\">~~你好~~\n</code></pre>\n\n<h4>脚注</h4>\n\n<pre><code class=\"line-numbers\">你好朋友[¹]\n</code></pre>\n\n<h4>列表</h4>\n\n<pre><code class=\"line-numbers\">1.无序列表  \n*或者 +或者-，使用之前后方需要加空格 \n2.有序列表  \n数字+ .  \n3.列表嵌套  \n比如:  \n1.第一章:   - 第一  \n#### Markdown 代码  \n>使用`printf()`  ` 此符号`` `\n</code></pre>\n\n<h4>链接</h4>\n\n<pre><code class=\"line-numbers\">[链接](https://mr90.top)  \n格式:链接(链接地址)\n</code></pre>","tags":["markdown"],"categories":["学习笔记","md"]},{"title":"回顾html基础学习","url":"/posts/9ba05e65/","content":"\n\n<div class=\"tip ban font5 fas fa-ban faa-horizontal animated\"><p>html基础教程复习</p><p></p></div>\n\n## 开头部分\n\n1. `<!DOCTYPE html>`文档类型声明标签，最新版本\n2. `<html lang=\"en\">`声明网页的语言，`zh-CN`\n3. `<meta charset=\"UTF-8\">`字符集，utf-8表示万国码\n\n\n## 常用标签\n\n1. `h1-h6`标题标签\n2. `p,br`段落换行标签\n3. `strong,em,del,ins,u`文本格式化标签，加粗，倾斜，删除，下划线\n4. 盒子标签`div,span`块级(独占一行)和行级\n5. `align`位置，`border`边框,`cellspacing`单元格之间的距离，`cellpadding`文本与边框之间的距离\n6. 表格属性 `table`，`thead`定义头部，`tr`行标签，`th`表示表头，`tbady`表示表格的主体部分,`td`单元格标签,`colspan`跨列合并，`rowspan`跨行合并\n\n### 列表标签\n\n1. `ul`表示无序列表`li`\n2. `ol`表示有序列表`li`\n3. 自定义列表`dl` ,`dt`,`dd`,一环套一环\n\n### 表单标签\n\n1. 表单由表单域，表单信息，表单提示\n2. `<form>`发送给服务器，表单域\n3. form属性 action提交位置  method方法\n\n#### input标签\n\n<span class=\"inline-tag blued\">type</span>\n\n1. `input`单标签，type(password密码属性)\n2. type属性`radio`单选，`checkbox`多选,加入相同的name属性，value值预选显示\n3. 单选按钮可加入`checkd=\"checked\"`属性，`maxlength`约束最大字符\n4. `submit`提交按钮，`reset`重置按钮，`button`普通按钮，`file`上传文件\n\n#### label标签\n\n\n1. `<lable for=\"1\">`联系input标签`<input id=\"1\">`\n\n#### select标签\n\n```\n<select>\n<option select=\"selected\"></option>\n</select>//表示默认选中\n```\n#### textarea标签\n\n{% folding green, 查看测试代码 %}\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>表单</title>\n</head>\n\n<body>\n    <h4>青春不常在</h4>\n    <form action=\"xx.php\" method=\"post\">\n    <table width=\"600\" border=\"1\" cellspacing=\"0\">\n        <thead>\n            <tr>\n                <th>属性</th>\n                <th>内容</th>\n            </tr>\n        </thead>\n        <tbady>\n            <!-- 第一行 -->\n            <tr>\n                <td>性别</td>\n                <td>\n                    <label for=\"nan\"><input type=\"radio\" name=\"sex\" id=\"nv\">男</label>\n                    <label for=\"nv\"><input type=\"radio\" name=\"sex\" id=\"nv\">女</label>\n                </td>\n            </tr>\n            <!-- 第二行 -->\n            <tr>\n                <td>生日</td>\n                <td>\n                    <select>\n                        <option select=\"selected\">==请选择年==</option>\n                        <option>2000年</option>\n                        <option>2001年</option>\n                        <option>2002年</option>\n                        <option>2003年</option>\n                    </select>\n                    <select>\n                        <option select=\"selected\">==请选择月==</option>\n                        <option>1月</option>\n                        <option>2月</option>\n                        <option>3月</option>\n                        <option>4月</option>\n                    </select>\n                    <select>\n                        <option select=\"selected\">==请选择日==</option>\n                        <option>1日</option>\n                        <option>2</option>\n                        <option>3</option>\n                        <option>4</option>\n                    </select>\n                </td>\n            </tr>\n            <!-- 第三行 -->\n            <tr>\n                <td>所在地区</td>\n                <td>\n                    <input type=\"text\" value=\"请填写地区例如\"/>\n                </td>\n            </tr>\n            <!-- 第四行 -->\n            <tr>\n                <td>婚姻状况</td>\n                <td>\n                    <label for=\"m1\"><input type=\"radio\" name=\"marry\" id=\"m1\"/>未婚</label>\n                    <label for=\"m2\"><input type=\"radio\" name=\"marry\" id=\"m2\"/>已婚</label>\n                    <label for=\"m3\"><input type=\"radio\" name=\"marry\" id=\"m3\"/>离婚</label>\n                </td>\n            </tr>\n            <!-- 第五行 -->\n            <tr>\n                <td>学历</td>\n                <td>\n                    <input type=\"text\" value=\"填写学历\"/>\n                </td>\n            </tr>\n            <!-- 第六行 -->\n            <tr>\n                <td>喜欢的类型</td>\n                <td>\n                    <label for=\"type1\"><input type=\"checkbox\" name=\"like\" id=\"type1\"/>妩媚的</label>\n                    <label for=\"type2\"><input type=\"checkbox\" name=\"like\" id=\"type2\"/>可爱的</label>\n                    <label for=\"type3\"><input type=\"checkbox\" name=\"like\" id=\"type3\"/>小鲜肉</label>\n                    <label for=\"type4\"><input type=\"checkbox\" name=\"like\" id=\"type4\"/>老腊肉</label>\n                    <label for=\"type5\"><input type=\"checkbox\" name=\"like\" id=\"type5\"/>都喜欢</label>\n                </td>\n            </tr>\n            <!-- 第七行 -->\n            <tr>\n                <td>自我介绍</td>\n                <td>\n                    <textarea>个人简介</textarea>\n                </td>\n            </tr>\n            <!-- 第八行 -->\n            <tr>\n                <td></td>\n                <td>\n                    <button type=\"submit\">免费注册</button>\n                </td>\n            </tr>\n            </tdaby>\n\n    </table>\n    </form>\n</body>\n\n</html>\n```\n{% endfolding %}\n\n## Emmet语法\n\n1. 生成标签直接tab或者回车\n2. 生成多个标签 `div*3`\n3. 生成父子关系`ul>li` 或者  `tr>td*5`或者`(td>tr)*5`或者`(tr>td*2)*3或者`(tr>td*2>lable*2)*4`\n4. 生成兄弟标签`div+p`\n5. 生成代类名或者id的，`.demo`或者`#demo` tab键\n6. 生成有顺序的div 自增符号 $ `.demo$*5`\n\n>css emmet输入开头字母回车也可快速生成代码","categories":["web","HTML"]},{"title":"Vscode常用的快捷键","url":"/posts/37b7f1d1/","content":"\n<div class=\"tip ban font5 fas fa-ban faa-horizontal animated\"><p>掌握Vscode快捷键</p><p></p></div>\n\n## vs code 的常用快捷键\n1. 注释：\n\n　　- 单行注释：[ctrl+k,ctrl+c] 或 ctrl+/\n\n　　- 取消单行注释：[ctrl+k,ctrl+u] (按下ctrl不放，再按k + u)\n\n　　- 多行注释：[alt+shift+A]\n\n　　- 多行注释：/**\n\n2. 移动行：alt+up/down\n\n3. 显示/隐藏左侧目录栏 ctrl + b\n\n4. 复制当前行：shift + alt +up/down\n\n5. 删除当前行：shift + ctrl + k\n\n6. 控制台终端显示与隐藏：ctrl + ~\n\n7. 查找文件/安装vs code 插件地址：ctrl + p\n\n8. 代码格式化：shift + alt +f\n\n9. 新建一个窗口 : ctrl + shift + n\n\n10. 行增加缩进: ctrl + [\n\n11. 行减少缩进: ctrl + ]\n\n12. 裁剪尾随空格(去掉一行的末尾那些没用的空格) : ctrl + shift + x\n\n13. 字体放大/缩小: ctrl + ( + 或 - )\n\n14. 拆分编辑器 : ctrl + 1/2/3\n\n15. 切换窗口 : ctrl + shift + left/right\n\n16. 关闭编辑器窗口 : ctrl + w\n\n17. 关闭所有窗口 : ctrl + k + w\n\n18. 切换全屏 : F11\n\n19. 自动换行 : alt + z\n\n20. 显示git : ctrl + shift + g\n\n21. 全局查找文件：ctrl + shift + f\n\n22. 显示相关插件的命令(如：git log)：ctrl + shift + p\n\n23. 选中文字：shift + left / right / up / down\n\n24. 折叠代码： ctrl + k + 0-9 (0是完全折叠)\n\n25. 展开代码： ctrl + k + j (完全展开代码)\n\n26. 删除行 ： ctrl + shift + k\n\n27. 快速切换主题：ctrl + k / ctrl + t\n\n28. 快速回到顶部 ： ctrl + home\n\n29. 快速回到底部 : ctrl + end\n\n30. 格式化选定代码 ：ctrl + k / ctrl +f\n\n31. 选中代码 ： shift + 鼠标左键\n\n32. 多行同时添加内容（光标） ：ctrl + alt + up/down\n\n33. 全局替换：ctrl + shift + h\n\n34. 当前文件替换：ctrl + h\n\n35. 打开最近打开的文件：ctrl + r\n\n36. 打开新的命令窗：ctrl + shift + c\n\n## vs code 的常用插件\n1. Auto Rename Tag 修改html标签，自动帮你完成尾部闭合标签的同步修改，和webstorm一样。\n\n2. Auto Close Tag 自动闭合HTML标签\n\n4. Beautiful 格式化代码的工具\n\n5. Dash Dash是MacOS的API文档浏览器和代码段管理器\n\n6. Ejs Snippets ejs 代码提示\n\n7. ESLint 检查javascript语法错误与提示\n\n8. File Navigator 快速查找文件\n\n9. Git History(git log) 查看git log\n\n10. Gulp Snippets 写gulp时用到，gulp语法提示。\n\n11. HTML CSS Support 在HTML标签上写class智能提示当前项目所支持的样式\n\n12. HTML Snippets 超级好用且初级的H5代码片段以及提示\n\n13. Debug for Chrome 让vs code映射chrome的debug功能，静态页面都可以用vscode来打断点调试.配饰稍微复杂一点\n\n14. Document this Js的注释模板\n\n15. jQuery Code Snippets jquery提示工具\n\n16. Html2jade html模板转pug模板\n\n17. JS-CSS-HTML Formatter 格式化\n\n18. Npm intellisense require 时的包提示工具\n\n19. Open in browser 打开默认浏览器\n\n20. One Dark Theme 一个vs code的主题\n\n21. Path Intellisense 自动路径补全.默认不带这个功能\n\n22. Project Manager 多个项目之间快速切换的工具\n\n23. Pug(Jade) snippets pug语法提示\n\n24. React Components 根据文件名创建反应组件代码。\n\n25. React Native Tools reactNative工具类为React Native项目提供了开发环境。\n\n26. Stylelint css/sass代码审查\n\n27. Typings auto installer 安装vscode 的代码提示依赖库，基于typtings的\n\n28. View In Browser 　默认浏览器查看HTML文件（快捷键Ctrl+F1可以修改）\n\n29. Vscode-icons 让vscode资源目录加上图标.必备\n\n30. VueHelper Vue2代码段（包括Vue2 api.vue-router2.vuex2）\n\n31. Vue 2 Snippets vue必备vue代码提示\n\n32. Vue-color vue语法高亮主题\n\n33. Auto-Open Markdown Preview markdown文件自动开启预览\n\n34. EverMonkey 印象笔记\n\n35. atom one dark atom的一个高亮主题(个人推荐)\n\n## 常用的电脑快捷键\n\n1. ctrl + shift + delete 快速清除浏览器缓存\n\n2. ctrl + alt + delete 快速进入任务管理器页面\n\n3. window + L 快速锁定电脑\n\n4. window + d 所有窗口最小化\n\n5. window + e 打开我的资源管理器(我的电脑)\n\n6. window + f 快速打开搜索窗口\n\n7. alt + tab 快速查看打开的应用与窗口","categories":["学习笔记"]},{"title":"Hexo文章编写格式","url":"/posts/44e930a5/","content":"<div class=\"tip key font5 fas fa-key faa-horizontal animated\"><p>Hexo编写文章时所用的标签集合，已整理在下方</p><p>使用了Tab标签-点击按钮可展开</p></div>\n\n## Hexo 编写文章格式\n\n\n{% tabs 1, -1 %}\n<!-- tab _Post格式 -->\n```\n---\ntitle: //标题\ndate: //例如：2020-03-02 21:31\nupdated:   //更新时间\ntags: [  ,  ]  //便签\ncategories: //分类\nkeywords:  //关键词\ndescription:  //文章描述\ntop_img: //顶部图片\ncomments: //评论\ncover: //封面图\ntoc:\ntoc_number : false /true\ncopyright: //版权\nhighlight_shrink: //表示代码框是否收缩，默认“false”\nauto_open: toc\nsticky: 置顶操作数值越大越靠前\n---\n```\n<!-- endtab -->\n\n<!-- tab _Page格式 -->\n|  key   | value  |\n|  ----  | :--:  |\n| title  | 标题 |\n| date  | 发表日期 |\n| updated | 文章更新日期 |\n| type|类型，tags,link,categories 分别是“标签”，“友链”，“分类” 加“”引号|\n| comments |是否显示评论，默认 true|\n| description |描述|\n| top_img |顶部图|\n| mathjax |数学公式|\n| katex |数学公式|\n|aside|\ttrue 表示显示右边信息卡片，默认值；false 表示不显示|\n|highlight_shrink|\t代码高亮是否收缩，默认“false”|\n<!-- endtab -->\n{% endtabs %}\n\n## Note标签写法\n{% tabs 3, -1 %}\n<!-- tab 普通note -->\n```html\n<div class=\"note default icon flat\"><p>default</p></div>\n{% note default icon %}\ndefault\n{% endnote %}\n\n<div class=\"note primary icon flat\"><p>primary</p></div>\n{% note primary icon %}\nprimary\n{% endnote %}\n\n<div class=\"note success icon flat\"><p>success</p></div>\n{% note success icon %}\nsuccess\n{% endnote %}\n\n<div class=\"note info icon flat\"><p>info</p></div>\n{% note info icon %}\ninfo\n{% endnote %}\n\n<div class=\"note warning icon flat\"><p>warning</p></div>\n{% note warning icon %}\nwarning\n{% endnote %}\n\n<div class=\"note danger icon flat\"><p>danger</p></div>\n{% note danger icon %}\ndanger\n{% endnote %}\n\n<div class=\"note primary no-icon flat\"><p>primary</p></div>\n{% note primary no-icon%}\n无icon\n{% endnote %}\n```\n<div class=\"note default icon flat\"><p>default</p></div>\n{% note default icon %}\ndefault\n{% endnote %}\n\n<div class=\"note primary icon flat\"><p>primary</p></div>\n{% note primary icon %}\nprimary\n{% endnote %}\n\n<div class=\"note success icon flat\"><p>success</p></div>\n{% note success icon %}\nsuccess\n{% endnote %}\n\n<div class=\"note info icon flat\"><p>info</p></div>\n{% note info icon %}\ninfo\n{% endnote %}\n\n<div class=\"note warning icon flat\"><p>warning</p></div>\n{% note warning icon %}\nwarning\n{% endnote %}\n\n<div class=\"note danger icon flat\"><p>danger</p></div>\n{% note danger icon %}\ndanger\n{% endnote %}\n\n<div class=\"note primary no-icon flat\"><p>primary</p></div>\n{% note primary no-icon%}\n无icon\n{% endnote %}\n<!-- endtab -->\n\n<!-- tab 自定义font5图标c -->\n```html\n/* 链接 */\n<div\n  class=\"note icon font5 fa-fw fa fa-link\"\n  style=\"background: #eef7fa;border-left-color: #428bca;\"\n>\n  <p>info</p>\n</div>\n/* 小喇叭 */\n<div\n  class=\"note icon font5 fas fa-bullhorn\"\n  style=\"background: #fcf1f2;border-left-color: #d9534f;\"\n>\n  <p>info</p>\n</div>\n/* BUG */\n<div\n  class=\"note icon font5 fas fa-bug\"\n  style=\"background: #fcf1f2;border-left-color: #d9534f;\"\n>\n  <p>info</p>\n</div>\n/* idea */\n<div\n  class=\"note icon font5 far fa-lightbulb\"\n  style=\"background: #fdf8ea;border-left-color: #f0ad4e;\"\n>\n  <p>info</p>\n</div>\n```\n<div\n  class=\"note icon font5 fa-fw fa fa-link\"\n  style=\"background: #eef7fa;border-left-color: #428bca;\"\n>\n  <p>info</p>\n</div>\n/* 小喇叭 */\n<div\n  class=\"note icon font5 fas fa-bullhorn\"\n  style=\"background: #fcf1f2;border-left-color: #d9534f;\"\n>\n  <p>info</p>\n</div>\n/* BUG */\n<div\n  class=\"note icon font5 fas fa-bug\"\n  style=\"background: #fcf1f2;border-left-color: #d9534f;\"\n>\n  <p>info</p>\n</div>\n/* idea */\n<div class=\"note icon font5 far fa-lightbulb\" style=\"background:#fdf8ea;border-left-color:#f0ad4e;\">\n  <p>info</p>\n</div>\n<!-- endtab -->\n<!-- tab 自定义小标签 -->\n```html\n<div class=\"snote red\"><p>默认red</p></div>\n<div class=\"snote quote\"><p>quote</p></div>\n<div class=\"snote info\"><p>info</p></div>\n<div class=\"snote done\"><p>done</p></div>\n<div class=\"snote success\"><p>success</p></div>\n<div class=\"snote danger\"><p>danger</p></div>\n<div class=\"snote error\"><p>error</p></div>\n<div class=\"snote radiation\"><p>radiation</p></div>\n<div class=\"snote bug\"><p>bug</p></div>\n<div class=\"snote idea yellow\"><p>idea-yellow</p></div>\n<div class=\"snote link blue\"><p>link- blue</p></div>\n<div class=\"snote paperclip\"><p>paperclip</p></div>\n<div class=\"snote todo\"><p>todo</p></div>\n<div class=\"snote msg cyan\"><p>msg cyan</p></div>\n<div class=\"snote guide\"><p>guide</p></div>\n<div class=\"snote download\"><p>download</p></div>\n<div class=\"snote up\"><p>up</p></div>\n<div class=\"snote undo\"><p>undo</p></div>\n/* 引用 */\n<div class=\"snote quote\"><p class='p subtitle'>小标题</p>\n\n这是个引用\n\n</div>\n```\n<div class=\"snote red\"><p>默认red</p></div>\n<div class=\"snote quote\"><p>quote</p></div>\n<div class=\"snote info\"><p>info</p></div>\n<div class=\"snote done\"><p>done</p></div>\n<div class=\"snote success\"><p>success</p></div>\n<div class=\"snote danger\"><p>danger</p></div>\n<div class=\"snote error\"><p>error</p></div>\n<div class=\"snote radiation\"><p>radiation</p></div>\n<div class=\"snote bug\"><p>bug</p></div>\n<div class=\"snote idea yellow\"><p>idea-yellow</p></div>\n<div class=\"snote link blue\"><p>link- blue</p></div>\n<div class=\"snote paperclip\"><p>paperclip</p></div>\n<div class=\"snote todo\"><p>todo</p></div>\n<div class=\"snote msg cyan\"><p>msg cyan</p></div>\n<div class=\"snote guide\"><p>guide</p></div>\n<div class=\"snote download\"><p>download</p></div>\n<div class=\"snote up\"><p>up</p></div>\n<div class=\"snote undo\"><p>undo</p></div>\n/* 引用 */\n<div class=\"snote quote\"><p class='p subtitle'>小标题</p>\n\n这是个引用\n\n</div>\n- 颜色\n```\nclear, light, gray, red, yellow, green, cyan, blue\n```\n<!-- endtab -->\n<!-- tab 渐变标签 -->\n```html\n<div class='tip faa-horizontal animated'><p>默认情况<p></div>\n<div class='tip info faa-horizontal animated'><p>info<p></div>\n<div class='tip success faa-horizontal animated'><p>success<p></div>\n<div class='tip error faa-horizontal animated'><p>error<p></div>\n<div class='tip warning faa-horizontal animated'><p>warning<p></div>\n<div class='tip font5 fas fa-atom faa-horizontal animated'><p>自定义font5图标<p></div>\n<div class='tip custom icon-QQ2 faa-horizontal animated'><p>自定义iconfont图标<p></div>\n<div class=\"tip wtgo font5 fas fa-bolt faa-horizontal animated\"><p>文字</p><p></p></div>\n<div class=\"tip ban font5 fas fa-ban faa-horizontal animated\"><p>文字</p><p></p></div>\n<div class=\"tip home font5 fas fa-home faa-horizontal animated\"><p>文字</p><p></p></div>\n<div class=\"tip important font5 fas fa-home faa-horizontal animated\"><p>魔改标签4</p><p></p></div>\n<div class=\"tip ref font5 fas fa-sync faa-horizontal animated\"><p>魔改标签5</p><p></p></div>\n<div class=\"tip ffa font5 fas fa-cogs faa-horizontal animated\"><p>魔改标签6</p><p></p></div>\n<div class=\"tip key font5 fas fa-key faa-horizontal animated\"><p>魔改标签7</p><p></p></div>\n<div class=\"tip socd font5 fas fa-bell faa-horizontal animated\"><p>魔改标签8</p><p></p></div>\n<div class=\"tip qq font5 fab fa-qq faa-horizontal animated\"><p>魔改标签9</p><p></p></div>\n```\n<div class='tip'><p>默认情况<p></div>\n<div class='tip info'><p>info<p></div>\n<div class='tip success'><p>success<p></div>\n<div class='tip error'><p>error<p></div>\n<div class='tip warning'><p>warning<p></div>\n<div class='tip font5 fas fa-atom'><p>自定义font5图标<p></div>\n<div class='tip custom icon-QQ2'><p>自定义iconfont图标<p></div>\n<div class=\"tip wtgo font5 fas fa-bolt\"><p>文字</p><p></p></div>\n<div class=\"tip ban font5 fas fa-ban\"><p>文字</p><p></p></div>\n<div class=\"tip home font5 fas fa-home\"><p>文字</p><p></p></div>\n<div class=\"tip important font5 fas fa-home\"><p>魔改标签4</p><p></p></div>\n<div class=\"tip ref font5 fas fa-sync\"><p>魔改标签5</p><p></p></div>\n<div class=\"tip ffa font5 fas fa-cogs\"><p>魔改标签6</p><p></p></div>\n<div class=\"tip key font5 fas fa-key\"><p>魔改标签7</p><p></p></div>\n<div class=\"tip socd font5 fas fa-bell\"><p>魔改标签8</p><p></p></div>\n<div class=\"tip qq font5 fab fa-qq\"><p>魔改标签9</p><p></p></div>\n<!-- endtab -->\n<!-- tab 小标签 -->\n<span class=\"inline-tag [red|green|blue|yellow|grey]\">语法</span>\n<span class=\"inline-tag red\">红色小标签</span>\n<span class=\"inline-tag green\">绿色小标签</span>\n<span class=\"inline-tag blue\">蓝色小标签</span>\n<span class=\"inline-tag yellow\">黄色小标签</span>\n<span class=\"inline-tag grey\">灰色小标签</span>\n```html\n<span class=\"inline-tag [red|green|blue|yellow|grey]\">语法</span>\n<span class=\"inline-tag red\">红色小标签</span>\n<span class=\"inline-tag green\">绿色小标签</span>\n<span class=\"inline-tag blue\">蓝色小标签</span>\n<span class=\"inline-tag yellow\">黄色小标签</span>\n<span class=\"inline-tag grey\">灰色小标签</span>\n<span class=\"inline-tag\" style=\"--Color:#881B12\">自定义颜色小标签</span>\n```\n<!-- endtab -->\n{% endtabs %}\n\n## 行内小标签\n{% tabs 4, -1 %}\n<!-- tab 下划线 -->\n<u>下划线</u>\n```html\n<u>下划线</u>\n```\n<!-- endtab -->\n<!-- tab 着重线 -->\n<emp>着重线</emp>\n```html\n<emp>着重线</emp>\n```\n<!-- endtab -->\n<!-- tab 波浪线 -->\n<wavy>波浪线</wavy>\n```html\n<wavy>波浪线</wavy>\n```\n<!-- endtab -->\n<!-- tab 删除线 -->\n<del>删除线</del>\n```html\n<del>删除线</del>\n```\n<!-- endtab -->\n<!-- tab 按键 -->\n<kbd>command</kbd>\n```html\n<kbd>command</kbd>\n```\n<!-- endtab -->\n<!-- tab 隐藏键 -->\n<psw>这里没有验证码</psw>\n```html\n<psw>这里没有验证码</psw>\n```\n<!-- endtab -->\n{% endtabs %}\n\n## 隐藏内容写法\n\n{% tabs 5, -1 %}\n<!-- tab hidesnote -->\n|隐藏属性|含义|\n|----|:--:|\n|content|文本内容|\n|dispaly|按钮显示的文字(可选)|\n|bg|按钮的颜色|\n|color|按钮文字的颜色(可选)|\n|inline|只限文字|\n|hideblock|可以隐藏图片，代码块等|\n<!-- endtab -->\n<!-- tab 写法 -->\n```\n{% hideInline content,display,bg,color %}\n\n{% hideBlock display,bg,color %}\ncontent\n{% endhideBlock %}\n```\n<!-- endtab -->\n\n<!-- tab 样式 -->\n\n- 实例\n1. 隐藏inline内容\n{% hideInline display,red,blue %}\n2. 隐藏代码块\n{% hideBlock display,red,blue %}\n```\ncontent\n```\n{% endhideBlock %}\n<!-- endtab -->\n<!-- tab hideTaggle -->\n|属性|文本内容|\n|----|:--:|\n|content|文本内容|\n|display|显示的文字(可选)|\n|bg|背景颜色(可选)|\n|color|文字颜色(可选)|\n<!-- endtab -->\n<!-- tab 写法 ——>\n```html\n{% hideToggle display,bg,color %}\ncontent\n{% endhideToggle %}\n\n<div class=\"hide-toggle\"><div class=\"hide-button toggle-title\" style=\"\"><i class=\"fa fa-caret-right fa-fw\"></i><span>文字</span></div>\n<div class=\"hide-content\"><p>默认效果</p></div></div>\n```\n<!-- endtab -->\n<!-- tab 演示 -->\n{% hideToggle display,red,blue %}\ncontent\n{% endhideToggle %}\n\n<div class=\"hide-toggle\"><div class=\"hide-button toggle-title\" style=\"\"><i class=\"fa fa-caret-right fa-fw\"></i><span>文字</span></div>\n<div class=\"hide-content\"><p>默认效果</p></div></div>\n<!-- endtab -->\n{% endtabs %}\n\n## Checkbox & Radio\n{% tabs 6, -1 %}\n<!-- tab checknox -->\n```markdown\n{% checkbox 纯文本测试 %}\n{% checkbox checked, 支持简单的 [markdown](https://guides.github.com/features/mastering-markdown/) 语法 %}\n{% checkbox red, 支持自定义颜色 %}\n{% checkbox green checked, 绿色 + 默认选中 %}\n{% checkbox yellow checked, 黄色 + 默认选中 %}\n{% checkbox cyan checked, 青色 + 默认选中 %}\n{% checkbox blue checked, 蓝色 + 默认选中 %}\n{% checkbox plus green checked, 增加 %}\n{% checkbox minus yellow checked, 减少 %}\n{% checkbox times red checked, 叉 %}\n{% radio 纯文本测试 %}\n{% radio checked, 支持简单的 [markdown](https://guides.github.com/features/mastering-markdown/) 语法 %}\n{% radio red, 支持自定义颜色 %}\n{% radio green, 绿色 %}\n{% radio yellow, 黄色 %}\n{% radio cyan, 青色 %}\n{% radio blue, 蓝色 %}\n```\n```html\n<div class=\"checkbox\">\n  <input type=\"checkbox\" />\n  <p>纯文本测试</p>\n</div>\n\n<div class=\"checkbox checked\">\n  <input type=\"checkbox\" checked />\n  <p>\n    支持简单的\n    <a\n      href=\"https://guides.github.com/features/mastering-markdown/\"\n      target=\"_blank\"\n      rel=\"noopener\"\n      >markdown</a\n    >\n    语法\n  </p>\n</div>\n\n<div class=\"checkbox red\">\n  <input type=\"checkbox\" />\n  <p>支持自定义颜色</p>\n</div>\n\n<div class=\"checkbox green checked\">\n  <input type=\"checkbox\" checked />\n  <p>绿色 + 默认选中</p>\n</div>\n\n<div class=\"checkbox yellow checked\">\n  <input type=\"checkbox\" checked />\n  <p>黄色 + 默认选中</p>\n</div>\n\n<div class=\"checkbox cyan checked\">\n  <input type=\"checkbox\" checked />\n  <p>青色 + 默认选中</p>\n</div>\n\n<div class=\"checkbox blue checked\">\n  <input type=\"checkbox\" checked />\n  <p>蓝色 + 默认选中</p>\n</div>\n\n<div class=\"checkbox plus green checked\">\n  <input type=\"checkbox\" checked />\n  <p>增加</p>\n</div>\n\n<div class=\"checkbox minus yellow checked\">\n  <input type=\"checkbox\" checked />\n  <p>减少</p>\n</div>\n\n<div class=\"checkbox times red checked\">\n  <input type=\"checkbox\" checked />\n  <p>叉</p>\n</div>\n\n<div class=\"checkbox\">\n  <input type=\"radio\" />\n  <p>纯文本测试</p>\n</div>\n\n<div class=\"checkbox checked\">\n  <input type=\"radio\" checked />\n  <p>\n    支持简单的\n    <a\n      href=\"https://guides.github.com/features/mastering-markdown/\"\n      target=\"_blank\"\n      rel=\"noopener\"\n      >markdown</a\n    >\n    语法\n  </p>\n</div>\n\n<div class=\"checkbox red\">\n  <input type=\"radio\" />\n  <p>支持自定义颜色</p>\n</div>\n\n<div class=\"checkbox green\">\n  <input type=\"radio\" />\n  <p>绿色</p>\n</div>\n\n<div class=\"checkbox yellow\">\n  <input type=\"radio\" />\n  <p>黄色</p>\n</div>\n\n<div class=\"checkbox cyan\">\n  <input type=\"radio\" />\n  <p>青色</p>\n</div>\n\n<div class=\"checkbox blue\">\n  <input type=\"radio\" />\n  <p>蓝色</p>\n</div>\n```\n<!-- endtab -->\n<!-- tab 演示 -->\n{% checkbox 纯文本测试 %}\n{% checkbox checked, 支持简单的 [markdown](https://guides.github.com/features/mastering-markdown/) 语法 %}\n{% checkbox red, 支持自定义颜色 %}\n{% checkbox green checked, 绿色 + 默认选中 %}\n{% checkbox yellow checked, 黄色 + 默认选中 %}\n{% checkbox cyan checked, 青色 + 默认选中 %}\n{% checkbox blue checked, 蓝色 + 默认选中 %}\n{% checkbox plus green checked, 增加 %}\n{% checkbox minus yellow checked, 减少 %}\n{% checkbox times red checked, 叉 %}\n{% radio 纯文本测试 %}\n{% radio checked, 支持简单的 [markdown](https://guides.github.com/features/mastering-markdown/) 语法 %}\n{% radio red, 支持自定义颜色 %}\n{% radio green, 绿色 %}\n{% radio yellow, 黄色 %}\n{% radio cyan, 青色 %}\n{% radio blue, 蓝色 %}\n<!-- endtab -->\n{% endtabs %}\n\n## 按钮\n{% tabs 7, -1 %}\n<!-- tab 按钮 -->\n```\n{% btn [url],[text],[icon],[color] [style] [layout] [position] [size] %}\n\n[url]         : 链接\n[text]        : 按钮文字\n[icon]        : [可选] 图标\n[color]       : [可选] 按钮背景顔色(默认style时）\n                      按钮字体和边框顔色(outline时)\n                      default/blue/pink/red/purple/orange/green\n[style]       : [可选] 按钮样式 默认实心\n                      outline/留空\n[layout]      : [可选] 按钮佈局 默认为line\n                      block/留空\n[position]    : [可选] 按钮位置 前提是设置了layout为block 默认为左边\n                      center/right/留空\n[size]        : [可选] 按钮大小\n                      larger/留空\n```\n<!-- endtab -->\n<!-- tab 演示 -->\n<div class=\"btn-center\">\n{% btn 'http://u.mr90.top',Harryの心阁,far fa-hand-point-right,outline larger %}\n{% btn 'http://u.mr90.top',Harryの心阁,far fa-hand-point-right,outline blue larger %}\n{% btn 'http://u.mr90.top',Harryの心阁,far fa-hand-point-right,outline pink larger %}\n{% btn 'http://u.mr90.top',Harryの心阁,far fa-hand-point-right,outline red larger %}\n{% btn 'http://u.mr90.top',Harryの心阁,far fa-hand-point-right,outline purple larger %}\n{% btn 'http://u.mr90.top',Harryの心阁,far fa-hand-point-right,outline orange larger %}\n{% btn 'http://u.mr90.top',Harryの心阁,far fa-hand-point-right,outline green larger %}\n</div>\n<!-- endtab -->\n{% endtabs %}\n\n## Folding写法\n\n{% tabs e8, -1 %}\n<!-- tab MD写法 -->\n```markdown\n{% folding 查看图片测试 %}\n\n![](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/5031c5f90d9148b9.jpg)\n\n{% endfolding %}\n\n{% folding cyan open, 查看默认打开的折叠框 %}\n\n这是一个默认打开的折叠框。\n\n{% endfolding %}\n\n{% folding green, 查看代码测试 %}\n\n{% endfolding %}\n\n{% folding yellow, 查看列表测试 %}\n\n- haha\n- hehe\n\n{% endfolding %}\n\n{% folding red, 查看嵌套测试 %}\n\n{% folding blue, 查看嵌套测试2 %}\n\n{% folding 查看嵌套测试3 %}\n\n嘿嘿 <span><img src='https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/5031c5f90d9148b9.jpg' style='height:24px'></span>\n\n{% endfolding %}\n\n{% endfolding %}\n\n{% endfolding %}\n```\n<!-- endtab -->\n\n<!-- tab Html写法 -->\n```html\n<details>\n  <summary>\n    <p>查看图片测试</p>\n  </summary>\n  <div class=\"content\">\n    <p>\n      <img\n      src=https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/loading.gif\n      data-src=\"https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/5031c5f90d9148b9.jpg\"\n      alt=\"\" />\n    </p>\n  </div>\n</details>\n\n<details cyan open>\n  <summary>\n    <p>查看默认打开的折叠框</p>\n  </summary>\n  <div class=\"content\">\n    <p>这是一个默认打开的折叠框。</p>\n  </div>\n</details>\n\n<details green>\n  <summary>\n    <p>查看代码测试</p>\n  </summary>\n  <div class=\"content\"></div>\n</details>\n\n<details yellow>\n  <summary>\n    <p>查看列表测试</p>\n  </summary>\n  <div class=\"content\">\n    <ul>\n      <li>haha</li>\n      <li>hehe</li>\n    </ul>\n  </div>\n</details>\n\n<details red>\n  <summary>\n    <p>查看嵌套测试</p>\n  </summary>\n  <div class=\"content\">\n    <details blue>\n      <summary>\n        <p>查看嵌套测试2</p>\n      </summary>\n      <div class=\"content\">\n        <details>\n          <summary>\n            <p>查看嵌套测试3</p>\n          </summary>\n          <div class=\"content\">\n            <p>\n              hahaha\n              <span\n                ><img\n                src=https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/loading.gif\n                data-src='https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/5031c5f90d9148b9.jpg'\n                style='height:24px'></span\n              >\n            </p>\n          </div>\n        </details>\n      </div>\n    </details>\n  </div>\n</details>\n```\n<!-- endtab -->\n\n<!-- tab 演示 -->\n\n{% folding 查看图片测试 %}\n\n![](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/5031c5f90d9148b9.jpg)\n\n{% endfolding %}\n\n{% folding cyan open, 查看默认打开的折叠框 %}\n\n这是一个默认打开的折叠框。\n\n{% endfolding %}\n\n{% folding yellow, 查看列表测试 %}\n\n- haha\n- hehe\n\n{% endfolding %}\n\n{% folding red, 查看嵌套测试 %}\n\n{% folding blue, 查看嵌套测试2 %}\n\n{% folding 查看嵌套测试3 %}\n\n嘿嘿 <span><img src='https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/5031c5f90d9148b9.jpg' style='height:24px'></span>\n\n{% endfolding %}\n\n{% endfolding %}\n\n{% endfolding %}\n\n<!-- endtab -->\n\n{% endtabs %}\n\n## 媒体写法\n<span class=\"inline-tag red\">图片-Photo</span> <span class=\"inline-tag green\">视频-video</span> <span class=\"inline-tag blue\">音频-Audio</span>\n\n### 图片-Photo写法\n\n{% tabs e9, -1 %}\n\n<!-- tab 单图片 -->\n\n- 第一种\n\n```markdown\n{% image https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/558c3dfea39cb752.jpg 图片描述。 %}\n\n指定宽度：\n\n{% image https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/558c3dfea39cb752.jpg 300px %}\n\n指定宽度并添加描述：\n\n{% image https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/558c3dfea39cb752.jpg 300px 图片描述。 %}\n```\n{% image https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/558c3dfea39cb752.jpg 300px 图片描述 %}\n\n- 第二种\n\n```markdown\n\n{% fancybox %}\n![图片描述](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/558c3dfea39cb752.jpg)\n{% endfancybox %}\n```\n\n{% fancybox %}\n![图片描述](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/558c3dfea39cb752.jpg)\n{% endfancybox %}\n\n<!-- endtab -->\n\n<!-- tab 单行图片 -->\n```\n{% fancybox %}\n![图片描述](https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/B18FCBB3-67FD-48CC-B4F3-457BA145F17A.jpeg)\n![图片描述](https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/67239FBB-E15D-4F4F-8EE8-0F1C9F3C4E7C.jpeg)\n![图片描述](https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/00E0F0ED-9F1C-407A-9AA6-545649D919F4.jpeg)\n{% endfancybox %}\n```\n{% fancybox %}\n![图片描述](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/20374cc2168c47cc.jpg)\n![图片描述](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/4cced339c5086d3.jpg)\n![图片描述](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/5a77cce6c0bea887.jpg)\n{% endfancybox %}\n<!-- endtab -->\n\n<!-- tab 多行图片 -->\n```\n\n{% fancybox stretch, 4 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/181329e200ba1c11.jpg)\n![](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/26836dd87c0d57a5.jpg)\n![](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/2ae5b713777378e1.jpg)\n![](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/1106c2f5b3431d2a.jpg)\n![](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/181329e200ba1c11.jpg)\n![](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/26836dd87c0d57a5.jpg)\n![](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/2ae5b713777378e1.jpg)\n![](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/1106c2f5b3431d2a.jpg)\n{% endfancybox %}\n```\n{% fancybox stretch, 4 %}\n![](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/181329e200ba1c11.jpg)\n![](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/26836dd87c0d57a5.jpg)\n![](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/2ae5b713777378e1.jpg)\n![](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/1106c2f5b3431d2a.jpg)\n![](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/181329e200ba1c11.jpg)\n![](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/26836dd87c0d57a5.jpg)\n![](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/2ae5b713777378e1.jpg)\n![](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/phone/1106c2f5b3431d2a.jpg)\n{% endfancybox %}\n<!-- endtab -->\n{% endtabs %}\n\n### 视频-video写法\n\n{% tabs e120, -1 %}\n\n<!-- tab 演示效果 -->\n<!-- endtab -->\n\n<!-- tab 写法 -->\n- 100% 宽度\n\n```\n{% video https://cdn.jsdelivr.net/gh/Rr210/hexofixed@3.06/img/video/1.mp4 %}\n```\n- 50% 宽度\n\n```\n{% videos, 2 %}\n{% video https://cdn.jsdelivr.net/gh/Rr210/hexofixed@3.06/img/video/1.mp4 %}\n{% video https://cdn.jsdelivr.net/gh/Rr210/hexofixed@3.06/img/video/1.mp4 %}\n{% video https://cdn.jsdelivr.net/gh/Rr210/hexofixed@3.06/img/video/1.mp4 %}\n{% video https://cdn.jsdelivr.net/gh/Rr210/hexofixed@3.06/img/video/1.mp4 %}\n{% endvideos %}\n```\n\n- 25% 宽度\n\n```\n{% videos, 4 %}\n{% video https://cdn.jsdelivr.net/gh/Rr210/hexofixed@3.06/img/video/1.mp4%}\n{% video https://cdn.jsdelivr.net/gh/Rr210/hexofixed@3.06/img/video/1.mp4 %}\n{% video https://cdn.jsdelivr.net/gh/Rr210/hexofixed@3.06/img/video/1.mp4 %}\n{% video https://cdn.jsdelivr.net/gh/Rr210/hexofixed@3.06/img/video/1.mp4 %}\n{% video https://cdn.jsdelivr.net/gh/Rr210/hexofixed@3.06/img/video/1.mp4 %}\n{% video https://cdn.jsdelivr.net/gh/Rr210/hexofixed@3.06/img/video/1.mp4 %}\n{% video https://cdn.jsdelivr.net/gh/Rr210/hexofixed@3.06/img/video/1.mp4 %}\n{% video https://cdn.jsdelivr.net/gh/Rr210/hexofixed@3.06/img/video/1.mp4 %}\n{% endvideos %}\n```\n\n<!-- endtab -->\n<!-- tab 参数说明 -->\n- 单个视频\n\n```\n{% video 视频链接 %}\n```\n\n- 多个视频\n\n```\n{% videos 对齐方向, 列数 %}\n{% video 视频链接 %}\n{% video 视频链接 %}\n{% video 视频链接 %}\n{% endvideos %}\n```\n对齐方向：`left, center, right`\n\n列数：逗号后面直接写列数，支持 1 ～ 4 列。\n<!-- endtab -->\n{% endtabs %}\n\n### 音频-Audio\n{% tabs e11, -1 %}\n\n<!-- tab 演示效果 -->\n<audio controls=\"\" preload=\"\" __idm_id__=\"269361153\">\n  <source\n    src=\"https://cdn.mr90.top/music/tazhishijingguo.mp3\"\n    type=\"audio/mp3\"\n  />\n  Your browser does not support the audio tag.\n</audio>\n<!-- endtab -->\n\n<!-- tab 写法 -->\n```\n{% audio https://cdn.mr90.top/music/tazhishijingguo.mp3 %}\n```\n```\n<audio controls=\"\" preload=\"\" __idm_id__=\"269361153\">\n  <source\n    src=\"https://cdn.mr90.top/music/tazhishijingguo.mp3\"\n    type=\"audio/mp3\"\n  />\n  Your browser does not support the audio tag.\n</audio>\n```\n<!-- endtab -->\n\n<!-- tab 参数说明 -->\n```\n{% audio 音频链接 %}\n```\n<!-- endtab -->\n\n{% endtabs %}\n\n## 任意元素动画 \n{% tabs e12, -1 %}\n<!-- tab 演示效果 -->\n<table><thead><tr><th style=\"text-align:center\">On DOM load</th><th style=\"text-align:center\">On hover</th><th style=\"text-align:center\">On parent hover</th></tr></thead><tbody><tr><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-wrench faa-wrench animated\"></i>&nbsp;faa-wrench animated</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-wrench faa-wrench animated-hover\"></i>&nbsp;faa-wrench animated-hover</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\" class=\"faa-parent animated-hover\"><i class=\"fas fa-wrench faa-wrench\"></i>&nbsp;faa-wrench</a></td></tr><tr><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-bell faa-ring animated\"></i>&nbsp;faa-ring animated</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-bell faa-ring animated-hover\"></i>&nbsp;faa-ring animated-hover</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\" class=\"faa-parent animated-hover\"><i class=\"fas fa-bell faa-ring\"></i>&nbsp;faa-ring</a></td></tr><tr><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-envelope faa-horizontal animated\"></i>&nbsp;faa-horizontal animated</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-envelope faa-horizontal animated-hover\"></i>&nbsp;faa-horizontal animated-hover</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\" class=\"faa-parent animated-hover\"><i class=\"fas fa-envelope faa-horizontal\"></i>&nbsp;faa-horizontal</a></td></tr><tr><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-thumbs-up faa-vertical animated\"></i>&nbsp;faa-vertical animated</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-thumbs-up faa-vertical animated-hover\"></i>&nbsp;faa-vertical animated-hover</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\" class=\"faa-parent animated-hover\"><i class=\"fas fa-thumbs-up faa-vertical\"></i>&nbsp;faa-vertical</a></td></tr><tr><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-exclamation-triangle faa-flash animated\"></i>&nbsp;faa-flash animated</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-exclamation-triangle faa-flash animated-hover\"></i>&nbsp;faa-flash animated-hover</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\" class=\"faa-parent animated-hover\"><i class=\"fas fa-exclamation-triangle faa-flash\"></i>&nbsp;faa-flash</a></td></tr><tr><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-thumbs-up faa-bounce animated\"></i>&nbsp;faa-bounce animated</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-thumbs-up faa-bounce animated-hover\"></i>&nbsp;faa-bounce animated-hover</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\" class=\"faa-parent animated-hover\"><i class=\"fas fa-thumbs-up faa-bounce\"></i>&nbsp;faa-bounce</a></td></tr><tr><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-spinner faa-spin animated\"></i>&nbsp;faa-spin animated</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-spinner faa-spin animated-hover\"></i>&nbsp;faa-spin animated-hover</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\" class=\"faa-parent animated-hover\"><i class=\"fas fa-spinner faa-spin\"></i>&nbsp;faa-spin</a></td></tr><tr><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-plane faa-float animated\"></i>&nbsp;faa-float animated</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-plane faa-float animated-hover\"></i>&nbsp;faa-float animated-hover</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\" class=\"faa-parent animated-hover\"><i class=\"fas fa-plane faa-float\"></i>&nbsp;faa-float</a></td></tr><tr><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-heart faa-pulse animated\"></i>&nbsp;faa-pulse animated</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-heart faa-pulse animated-hover\"></i>&nbsp;faa-pulse animated-hover</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\" class=\"faa-parent animated-hover\"><i class=\"fas fa-heart faa-pulse\"></i>&nbsp;faa-pulse</a></td></tr><tr><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-envelope faa-shake animated\"></i>&nbsp;faa-shake animated</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-envelope faa-shake animated-hover\"></i>&nbsp;faa-shake animated-hover</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\" class=\"faa-parent animated-hover\"><i class=\"fas fa-envelope faa-shake\"></i>&nbsp;faa-shake</a></td></tr><tr><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-trophy faa-tada animated\"></i>&nbsp;faa-tada animated</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-trophy faa-tada animated-hover\"></i>&nbsp;faa-tada animated-hover</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\" class=\"faa-parent animated-hover\"><i class=\"fas fa-trophy faa-tada\"></i>&nbsp;faa-tada</a></td></tr><tr><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-space-shuttle faa-passing animated\"></i>&nbsp;faa-passing animated</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-space-shuttle faa-passing animated-hover\"></i>&nbsp;faa-passing animated-hover</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\" class=\"faa-parent animated-hover\"><i class=\"fas fa-space-shuttle faa-passing\"></i>&nbsp;faa-passing</a></td></tr><tr><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-space-shuttle faa-passing-reverse animated\"></i>&nbsp;faa-passing-reverse animated</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-space-shuttle faa-passing-reverse animated-hover\"></i>&nbsp;faa-passing-reverse animated-hover</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\" class=\"faa-parent animated-hover\"><i class=\"fas fa-space-shuttle faa-passing-reverse\"></i>&nbsp;faa-passing-reverse</a></td></tr><tr><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-circle faa-burst animated\"></i>&nbsp;faa-burst animated</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-circle faa-burst animated-hover\"></i>&nbsp;faa-burst animated-hover</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\" class=\"faa-parent animated-hover\"><i class=\"fas fa-circle faa-burst\"></i>&nbsp;faa-burst</a></td></tr><tr><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-star faa-falling animated\"></i>&nbsp;faa-falling animated</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-star faa-falling animated-hover\"></i>&nbsp;faa-falling animated-hover</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\" class=\"faa-parent animated-hover\"><i class=\"fas fa-star faa-falling\"></i>&nbsp;faa-falling</a></td></tr><tr><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-rocket faa-rising animated\"></i>&nbsp;faa-rising animated</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\"><i class=\"fas fa-rocket faa-rising animated-hover\"></i>&nbsp;faa-rising animated-hover</a></td><td style=\"text-align:center\"><a href=\"javascript:void(0);\" class=\"faa-parent animated-hover\"><i class=\"fas fa-rocket faa-rising\"></i>&nbsp;faa-rising</a></td></tr></tbody></table>\n<!-- endtab -->\n<!-- tab 注意事项 -->\n例如网址导航栏可以写为- 收藏夹 || http://u.mr90.top || fas fa-infinity faa-shake animated\n\n`注意`：如果使用 `On parent hover` 需要向父级元素添加 `class`名` faa-parent animated-hover`。其余两个不需要。\n<!-- endtab -->\n{% endtabs %}\n\n## 相册图库写法\n\n{% tabs 2, -1 %}\n<!-- tab 相册 -->\n```\n{% gallery %}\n图片使用md格式\n{% endgallery %}\n```\n<!-- endtab -->\n\n<!-- tab 相册图库 -->\n```html\n<div class=\"gallery-group-main\">\n  {% galleryGroup name description link img-url %} {% galleryGroup name\n  description link img-url %} {% galleryGroup name description link img-url %}\n</div>\n```\n|属性|含义|\n| ----|:--:|\n|name|图库的名称|\n|link|链接对应的相册地址可以是页面也可以是文章页(或者其他图库地址)|\n|img-url|图片封面的地址|\n|description|图库的描述|\n|注意事项|`加引号使用`|\n\n<!-- endtab -->\n{% endtabs %}\n{% folding green, 查看图片测试 %}\n\n![](https://tva3.sinaimg.cn/large/0072Vf1pgy1foxk7j6oxuj31hc0u0k6u.jpg)![](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/dm/ccfd6acea1a35b3.jpg)![](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/dm/594f37eac9f32b7.jpg)![](https://cdn.jsdelivr.net/gh/Rr210/hexofixed@1.07.01/img/api/dm/ccfd6acea1a35b3.jpg)\n\n{% endfolding %}\n\n\n","tags":["markdown"],"categories":["学习笔记","md"]},{"title":"debug测试页面","url":"/posts/a9a8b2be/","content":"\n>测试页面i✌","tags":["debug"],"categories":["技术·教程"]}]